module tryfrege.repl.FregeReplServlet where

import frege.Prelude hiding (print)
import Compiler.Data (Symbol, linkAll, DefinitionT)
import Compiler.BaseTypes (Position)
import Compiler.Import
import Data.List (intercalate)
import Interpreter.FregeInterpreter
import Repl.FregeRepl (eval, slurp, Repl, ReplResult, ReplEnv, Command)
import tryfrege.repl.ServletSupport

read :: Web -> ReplEnv -> IO ([Message] | Command)
read web state = do
   line <- fmap (maybe "" id) $ web.request.getParameter "cmd"
   let readResource resource = do
                                 res <- slurp resource
                                 return $ either (\a -> Left [a]) Right res
   case Command.parse line of
     Left err -> return $ Left [Message.error err]
     Right Reload -> maybe err readResource state.lastExternalScript where
       err = return $ Left [Message.error "No source to reload!"]
     Right (Load path) -> readResource path
     Right cmd -> return $ Right cmd

print :: Command -> ReplResult -> ReplEnv -> IO [Message]
print Java (JavaSource src) _ = return [Message.info src]
print (HelpDoc src) (DocHelp doc) _ = return [Message.info doc]
print _ (ReplInfo msgs) env = return msgs
print (cmd@(Eval line)) (CodeInfo sourceRepr g msgs) env = case sourceRepr of
  Expression sym | isVariable g sym =
    if isString g sym
      then do
              valMaybe <- sandboxFieldValue (symbolClass sym g) (symbolVar sym) env.state.classLoader
              outMaybe <- fieldValue "scripting.PreludeScripting" "stdoutWriter" env.state.classLoader
              errMaybe <- fieldValue "scripting.PreludeScripting" "stderrWriter" env.state.classLoader
              let out = maybe "" (toString . asObject) outMaybe
                  err = maybe "" (toString . asObject) errMaybe
              return $ maybe [Message.error "undefined"]
                             (\m -> [Message.info m, Message.hint out, Message.error err]) valMaybe
           `catch` (\err -> return [Message.error $ showThrowableCause err])
      else do
        let evalShow = do
                          let varDecl = variableDeclScript sym.name.base line
                          when (line /= sym.name.base) $
                            Repl.modify ReplEnv.{config <- InterpreterConfig.{predefs <- ((:) varDecl)}}
                          eval (Eval $ buildShowScript sym.name.base g sym)
        let (res, newEnv) = Repl.run evalShow env
        case res of
          CodeInfo{} -> print cmd res newEnv
          _ -> return [Message.info (":: " ++ (getSymbolType g sym))]
  Expression sym = return [Message.info (":: " ++ (getSymbolType g sym))]
  Definitions syms = do
    let symLabels = map (showSymbol g) $ filter (not . Symbol.{alias?}) syms
        lineStart = case env.config.predefs of
                  [] -> 0
                  (_:xs) -> fold (\z \x -> z + length (lines x)) 2 xs -- Ignore module line and import PreludeScripting
    return (Message.info (intercalate newLine symLabels) : filter (\msg -> msg.pos.line > lineStart) msgs)
  Module moduleName = return (Message.info ("Module " ++ moduleName) : msgs)
print (LoadExternal path script) res env = print (Eval script) res env
print _ _ _ = return []

preludeImport = ImpDcl {pos=Position.null, pack="scripting.PreludeScripting", as=Nothing, imports = linkAll}

transformDefs defs = do
  uniqdefs <- removeDuplicateDefs defs
  return (preludeImport : uniqdefs)

doGet :: MutableIO HttpServlet -> MutableIO HttpServletRequest -> MutableIO HttpServletResponse -> IO ()
doGet = doPost

doPost :: MutableIO HttpServlet -> MutableIO HttpServletRequest -> MutableIO HttpServletResponse -> IO ()
doPost !servlet !request !response = do
  let web = Web servlet request response
  session <- request.getSession
  env <- buildReplEnv web
  input <- read web env
  case input of
    Left msgs -> sendReplResult response msgs
    Right cmd -> do
       let (res, newEnv) = Repl.run (eval cmd) env
       msgs <- print cmd res newEnv
       saveSession newEnv session
       sendReplResult response msgs

buildReplEnv :: Web -> IO ReplEnv
buildReplEnv (Web{servlet=servlet,request=request}) = do
  session <- request.getSession
  lastExpr <- sessionAttr session (return . Just . asString) (return Nothing) "lastExpr"
  lastExternalScript <- sessionAttr session (return . Just . asString) (return Nothing) "lastExternalScript"
  let stringArrToList s = do
                            sarr <- asStringArr s
                            arr <- readonly id sarr
                            return arr.toList
  predefs <- sessionAttr session stringArrToList (return []) "predefs"
  context <- servlet.getServletContext
  classes <- sessionAttr session asClassesMap (initClasses context) "classes"
  classLoader <- InterpreterClassLoader.new classes >>= Mutable.freeze
  return $ ReplEnv {
                     lastExpr = lastExpr,
                     lastExternalScript = lastExternalScript,
                     prompt = "",
                     config = InterpreterConfig predefs transformDefs,
                     state = InterpreterState classLoader
                   }

initClasses :: MutableIO ServletContext -> IOMutable (JMap String ByteArr)
initClasses context = do
  preludeClassesMaybe <- context.getAttribute "classes"
  maybe (HashMap.new () :: STMutable s (JMap String ByteArr)) asClassesMap preludeClassesMaybe

sessionAttr :: Mutable s HttpSession -> (Object -> ST s b) -> ST s b -> String -> ST s b
sessionAttr session f default name = do
  attrObj <- session.getAttribute name
  maybe default f attrObj


saveSession :: ReplEnv -> MutableIO HttpSession -> IO ()
saveSession replEnv session = do
  let extScriptStr = maybe "" id replEnv.lastExternalScript
      lastExpr = maybe "" id replEnv.lastExpr
  putSession session "predefs" (StringArr.fromList replEnv.config.predefs)
  putSession session "classes" replEnv.state.classLoader.classes
  putSession session "lastExternalScript" extScriptStr
  putSession session "lastExpr" lastExpr

sendReplResult :: MutableIO HttpServletResponse -> [Message] -> IO ()
sendReplResult response msgs = do
  response.setContentType "text/xml;charset=UTF-8"
  out <- response.getWriter
  out.println $ messagesToXml msgs

putSession :: Mutable s HttpSession -> String -> a -> ST s ()
putSession session name value = session.setAttribute name (asObject value)

messagesToXml :: [Message] -> String
messagesToXml msgs = render [
                      "<repl>",
                      "  <messages>",
                           msgsToXml,
                      "  </messages>",
                      "</repl>"
                     ] where
  render = unlines
  msgsToXml = render $ map msgToXml msgs
  msgToXml msg = render [
                          "<message>",
                          "  <type>",
                               show $ msg.msgType,
                          "  </type>",
                          "  <position>",
                               show $ msg.pos,
                          "  </position>",
                          "  <text><![CDATA[",
                               msg.text,
                          "  ]]></text>",
                          "</message>"
                        ]


native asClassesMap "(java.util.Map)" :: Object -> STMutable s (JMap String ByteArr)

pure native asString "(java.lang.String)" :: Object -> String

native asStringArr "(java.lang.String[])" :: Object -> STMutable s StringArr

pure native asObject "(Object)" :: a -> Object

pure native toString :: Object -> String