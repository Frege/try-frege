module tryfrege.repl.FregeReplServlet where

import Data.List
import frege.interpreter.FregeInterpreter
import frege.interpreter.FregeScriptCompiler hiding(compile)
import frege.compiler.Import
import frege.Version
import frege.java.Net 
import frege.compiler.Data
import frege.compiler.EclipseUtil as EU()
import tryfrege.repl.ServletSupport
import frege.compiler.DocUtils as DU(docit, docSym, DL, Doc, emitHtml)

buildInterpreterState :: Web -> IO InterpreterState 
buildInterpreterState (web@Web{request=request}) = do
  session <- request.getSession
  classesMaybe <- session.getAttribute "classes" 
  context <- session.getServletContext
  classes <- maybe (initClasses web) asClassesMap classesMaybe
  strMaybe <- session.getAttribute "script"
  currentScript <- maybe (return initScript) (return . asString) strMaybe
  urlarr <- URLArray.new 0
  loader <- ClassLoader.current >>= URLClassLoader.new urlarr
  moduleNameMaybe <- session.getAttribute "moduleName"
  moduleName <- maybe initModuleName (return . asString) moduleNameMaybe
  return InterpreterState {
      loader = loader,
      classes = classes,
      moduleName = moduleName,
      currentScript = currentScript,
      transformDefs = \defs -> defs ++ [preludeImport]
  }

preludeImport = ImpDcl {pos=Position.null, pack="scripting.PreludeScripting", as=Nothing, imports = linkAll}

initClasses (Web{servlet=servlet}) = do
  context <- servlet.getServletContext
  preludeClassesMaybe <- context.getAttribute "classes" 
  m <- maybe (HashMap.new () :: STMutable s (JMap String ByteArr)) asClassesMap preludeClassesMaybe
  return m

initModuleName = currentTimeMillis () >>= (\id -> return $ "repl" ++ show id ++ ".Repl")
                 
initScript = "import frege.Prelude hiding " ++
           "(stdout, stderr, print, println, trace, traceLn, printStr, printStrLn, traceStr, traceStrLn)\n" ++
           "import scripting.PreludeScripting"

evalScript :: Web -> Command -> Repl ReplResult
evalScript _ (Eval line) = do
    oldInterpState <- Repl . lift $ Interpreter.get
    fregecRes <- Repl . lift $ compile line
    case fregecRes of
        CompilationSuccess (c@CompilationInfo{javaSource=javaSrc,sourceInfo=sourceInfo,state=g}) -> do
            Repl.modify $ ReplState.{lastJavaSource = Just javaSrc}
            case sourceInfo of
                Module -> return $ ReplMessage ("Loaded module: " ++ moduleName g)           
                Definitions -> do
                    s <- Repl . lift $ Interpreter.get
                    Repl . lift . Interpreter.put $ s.{currentScript <- (++ newLine ++ line)}
                    return NoOutput
                Expression{variableName=var} -> do
                    res <- Repl . lift $ evalShow line
                    Repl . lift $ Interpreter.put oldInterpState
                    case res of
                        Left err -> return $ ReplError err
                        Right (res, out, err) -> return $ ReplSuccess res out err
        CompilationFailure err -> return $ ReplError err

evalScript _ (BrowseModule m) = do
    let moduleName = trim m
    state <- Repl . lift $ Interpreter.get
    javac <- liftIO $ MemoryJavaCompiler.new state.loader state.classes
    global <- liftIO $ javac.classLoader >>= standardOptions
    let res = outlineModule moduleName global
    return $ ReplMessage (intercalate newLine res)
    
evalScript web Browse = do
    state <- Repl . lift $ Interpreter.get
    interpreterState <- Repl . lift $ Interpreter.get
    if isEmpty . trim $ interpreterState.currentScript then
        return NoOutput
    else
        evalScript web (BrowseModule state.moduleName)

evalScript _ (Type expr) = Repl.get >>= Repl . lift . interpret where
  interpret replState = do
        oldState <- Interpreter.get
        typeOfExpression <- typeOfExpression expr
        Interpreter.put oldState
        case typeOfExpression of
            Right typ -> return $ ReplMessage typ
            Left errs -> return $ ReplError errs

evalScript web (Load (urlSpec@#.*?://#)) = do
    urle <- liftIO $ URL.new urlSpec
    let update res = case res of
            ReplError _ -> return res
            _ -> updateExternalScript urlSpec >> return res
    evalURL web urle >>= update
    
evalScript _ (Load invalidUrl) = return $ ReplError ["Invalid URL: " ++ invalidUrl]

evalScript _ Java = do
  state <- Repl.get
  return $ maybe NoOutput ReplMessage state.lastJavaSource
        
evalScript web Reload = do
    state <- Repl.get
    case state.lastExternalScript of
        Just extScript -> evalScript web (Load extScript)
        Nothing -> return NoOutput --Nothing to reload 
            
evalScript _ History = do
    interpreterState <- Repl . lift $ Interpreter.get
    let removeInitScript = packed . drop len . toList
        len = initScript.length
    return . ReplMessage $ removeInitScript interpreterState.currentScript
    
evalScript (web@Web{request=request}) Reset = do
     classes <- liftIO $ initClasses web
     moduleName <- liftIO initModuleName
     Repl . lift $ Interpreter.modify (InterpreterState.{
          classes = classes,
          currentScript=initScript,
          moduleName=moduleName})
     Repl.put ReplState.init
     return NoOutput
  
evalScript _ Skip = return NoOutput
evalScript _ Help = return $ ReplMessage help

evalScript _ (HelpDoc source) = do
  fregecRes <- Repl . lift $ compile "\"\"" -- Import current definitions
  let errmsg = ReplError [source ++ " cannot be resolved!"]
      response = return . maybe errmsg ReplMessage
  case fregecRes of
    CompilationSuccess (c@CompilationInfo{state=global}) -> oneof [symtDoc, symvDoc, packDoc] where
       oneof =  response . listToMaybe . catMaybes
       symtDoc = qnameDoc TName{pack=global.thisPack, base=source}
       symvDoc = qnameDoc VName{pack=global.thisPack, base=source}
       qnameDoc qname = fmap (flip symdoc global) $ qname.findit global
       packDoc = fst $ StG.run (packDocumentation source) global
       symdoc sym global = fst $ StG.run (symbolDocumentation sym) global
    _ -> response $ Just ""

evalScript _ Version = Repl.get >>= (\s -> return $ ReplMessage version)

data ReplState = ReplState {
    lastExternalScript :: Maybe String,
    lastJavaSource :: Maybe String
} where
  init = ReplState {lastExternalScript = Nothing,
                    lastJavaSource = Nothing}

data Repl a = Repl {un :: StateT ReplState Interpreter a} where
    get = Repl $ StateT (\s -> return (s, s)) 
    put s = Repl $ StateT (\_ -> return ((), s))
    modify f = Repl.get >>= Repl.put . f

instance Monad Repl where
    return = Repl . return
    (Repl x) >>= f = Repl $ x >>= (\y -> Repl.un $ f y)
    
instance MonadIO Repl where
    liftIO = Repl . lift . liftIO

data ReplResult = ReplError [String] | 
     ReplMessage String |
     ReplSuccess {result :: String, stderr :: String, stdout :: String } | 
     NoOutput

ioException :: IOException -> Repl ReplResult    
ioException e = return $ ReplError [Throwable.getMessage e]

evalURL :: Web -> URL -> Repl ReplResult
evalURL web url = do
    replState <- Repl.get
    let contents = fetch `catch` handleIOE
        fetch = urlContents url >>= (return . Right)
        handleIOE :: IOException -> IO (Either String Script)
        handleIOE ioe = return $ Left ioe.getMessage
    scriptMay <- liftIO contents
    case scriptMay of 
        Right script -> evalScript web (Eval script)
        Left err -> return $ ReplError [err]

updateExternalScript script = do
    replState <- Repl.get
    Repl.put $ replState.{lastExternalScript=Just script}
    
moduleName global = show $ sub.thisPack.className global where
    sub = Global.sub global

handleMalformedURLException :: MalformedURLException -> Repl ReplResult   
handleMalformedURLException malformed = return $ ReplError [malformed.getMessage]

outlineModule pack g = fst $ State.run (outlineModule' pack)  g where
    outlineModule' pack = do
        let p = Pack.new pack
        importClass Position.null p
        g <- getST
        case g.packages.lookup p of
            Nothing -> return []
            Just env -> return $ map (EU.label g) $ EU.symbols env

positionAndName a b = case Symbol.pos a <=> Symbol.pos b of
                                    Eq -> comparing (QName.base . Symbol.name) a b
                                    ne -> ne 
                                    
cmdHelp = [(":type <expression>", "Display the type of an expression."),
            (":browse <module name>", "Display the names in a module if " ++
                "a module name is provided otherwise display the names in the default REPL module."),
            (":load <url>", "Load Frege code snippets from an URL."),
            (":java", "Show the generated Java code for the last successful compilation."),
            (":r", "Reload the last URL script."),
            (":history", "Display the source history for definitions in the default REPL module."),
            (":reset", "Reset the session discarding all evaluated scripts."),
            (":clear", "Clear the REPL window. The session continues to be active."),
            (":version", "Display Frege version."),
            (":{", "Start multiline definitions."),
            (":}", "End multiline defintions."),
            (":help <name>", "Display the documentation for the given name." ++
                " If the name is not provided, display this help message.")]
            
f `on` g = \x \y -> f (g x) (g y)

renderCmdHelp cmdHelp = map render cmdHelp where
    maxLeftIndent = length . fst $ maximumBy (compare `on` (length . fst)) cmdHelp
    indent cmd desc width = cmd ++ (concat $ replicate (width - cmd.length) " ") ++
        " - " ++ desc
    render (cmd, desc) = indent cmd desc maxLeftIndent
        
help = intercalate newLine $ header ++ body where
    header = ["At the prompt, you can enter Frege code snippets to get them evaluated.",
            "The output or compilation errors will be printed below the prompt.",
            "In addition to Frege code, the following commands are supported:\n"]
    body = renderCmdHelp cmdHelp
            
urlContents url = do
    inStream <- URL.openStream url
    scanner <- Scanner.new inStream
    scanner.useDelimiter "\\Z"
    scanner.next

data Scanner = mutable native java.util.Scanner where
    native new :: InputStream -> IO Scanner
    native fromFile new :: MutableIO File -> String -> IO Scanner throws FileNotFoundException
    native useDelimiter :: Scanner -> String -> IO ()
    native next :: Scanner -> IO String   
    
evalRepl repl state = evalStateT (Repl.un repl) state

pure native isEmpty :: String -> Bool

data Command = Version | Help | HelpDoc String | Browse | BrowseModule String | Type String |
    Load String | Eval String | Java | History | Reload | Reset | Skip where
    
    parse   :: String -> Either String Command
    parse s = parse' $ trim s where
        parse' "" = Right Skip
        parse' #^:# = parseCommand s
        parse' script = Right $ Eval script

    parseCommand (m~#:browse\s+(.*)#) = maybe (Right Browse) (Right . BrowseModule) $ m.group 1
    parseCommand ":browse" = Right Browse
    parseCommand (m~#^:l.*?\s+(.*)#) = 
        maybe (Left "Missing external script path!") (Right . Load) $ m.group 1
    parseCommand  ":version" = Right Version
    parseCommand (m~#:help\s+(.*)#) = maybe (Right Help) (Right . HelpDoc) $ m.group 1
    parseCommand ":help" = Right Help
    parseCommand (m~#^:t.*?\s+(.*)#) = 
        maybe (Left "Missing expression!") (Right . Type) $ m.group 1
    parseCommand ":java" = Right Java
    parseCommand ":history" = Right History
    parseCommand ":r" = Right Reload
    parseCommand ":reset" = Right Reset
    parseCommand otherwise = Left "Invalid Command"
    
derive Eq Command
derive Show Command

symbolDocumentation :: Symbol -> StG String
symbolDocumentation sym = do
    sw <-  doio $  StringWriter.new ()
    p  <-  doio $  StringWriter.printer sw
    changeST Global.{gen <- GenSt.{printer=p}}
    g <- getST
    let ds = docSym g sym
        dl = DL (Just "func") [ds]
        doc = Doc [dl]
    emitHtml true doc      -- html without CSS, eclipse does not understand
    doio $ g.printer.close
    -- doio $ sw.flush
    result <- doio $ sw.toString
    return result

packDocumentation :: String -> StG (Maybe String)
packDocumentation pack = do
    g <- getST
    r <- getFP pack
    case r of
        Right (Just fp) -> case fp.doc of
            ""   -> return . Just $ ("Undocumented package " ++ pack)
            text -> do
                let doc = Doc $ docit g (Just text)
                sw <-  doio $  StringWriter.new ()
                p  <-  doio $  StringWriter.printer sw
                changeST Global.{gen <- GenSt.{printer=p}}
                emitHtml false doc      -- html without CSS, eclipse does not understand
                doio $ g.printer.close
                -- doio $ sw.flush
                result <- doio $ sw.toString
                return . Just $ result
        Left ex -> return Nothing
        sonst   -> return . Just $ ("(java class?) " ++ pack)

buildReplState :: Web -> IO ReplState
buildReplState (Web{request=request}) = do
  session <- request.getSession
  lastScriptMaybe <- session.getAttribute "lastExternalScript"
  lastJavaSourceObj <- session.getAttribute "lastJavaSource"
  let lastJavaSource = maybe Nothing f lastJavaSourceObj
      lastScript = maybe Nothing f lastScriptMaybe
      f obj = if s == "" then Nothing else Just s where s = asString obj
  return ReplState{lastExternalScript = lastScript,
                   lastJavaSource = lastJavaSource}

evalShow :: Script -> Interpreter (Either [String] (String, String, String))
evalShow source = do
  fregecRes <- compile source
  case fregecRes of
    -- The script is a set of definitions
    CompilationSuccess (c@CompilationInfo{javaSource=jsrc,sourceInfo=sourceInfo,state=g}) ->
        case sourceInfo of
            Module -> return $ Left ["Not an expression!"]
            Definitions -> return $ Left ["Not an expresssion!"]
            Expression{variableName=var} -> showVariable source var g
    CompilationFailure err -> return $ Left err

showVariable source var g = do
      let symbolMay = lookupVarSymbol g.thisTab var
      case symbolMay of
        Nothing -> return . Left $ ["Not found: " ++ var]
        Just symbol -> showSymbol source var symbol g

showSymbol source var symbol g | isVariable g symbol =
    case symbol of
      SymL{alias} -> do
         state <- Interpreter.get
         Interpreter.put $ state.{currentScript <- (++ newLine ++ var ++ " = " ++ source)}
         maybe (return . Right $ ("", "", "")) (evalShow . buildShowScript var g) $ alias.findit g
      _      -> do
            state <- Interpreter.get
            if isString g symbol then liftIO $
              do
                let loader = g.sub.loader
                v <- secureFetchFieldValue state.moduleName var loader
                case v of
                    Left err -> return $ Left [err.getMessage]
                    Right value -> do
                        let result = toString $ asObject value
                        out <- fieldValue "scripting.PreludeScripting" "stdoutWriter" loader
                        outStr <- either (\e -> return e.getMessage)
                                         (return . toString . asObject) out
                        err <- fieldValue "scripting.PreludeScripting" "stderrWriter" loader
                        errStr <- either (\e -> return e.getMessage)
                                         (return . toString . asObject) err
                        return $ Right (result, outStr, errStr)
            else do
                Interpreter.put $ state.{currentScript <- (++ newLine ++ var ++ " = " ++ source)}
                let showScript = buildShowScript var g symbol
                evalShow showScript
showSymbol _ _ symbol g = 
           return . Right $ (getSymbolType symbol g, "", "") --Not a variable

native secureFetchFieldValue tryfrege.jdeps.Sandbox.secureFetchFieldValue :: 
  String -> String -> ClassLoader -> IO (Either ScriptException a)

native fieldValue frege.memoryjavac.JavaUtils.fieldValue :: 
  String -> String -> ClassLoader -> IO (Either ScriptException a)
  
putSession :: Mutable s HttpSession -> String -> a -> ST s ()
putSession session name value = session.setAttribute name (asObject value)

data Web = Web {
     servlet :: MutableIO HttpServlet,
     request :: MutableIO HttpServletRequest,
     response :: MutableIO HttpServletResponse }

doGet :: MutableIO HttpServlet -> MutableIO HttpServletRequest -> MutableIO HttpServletResponse -> IO ()
doGet = doPost

doPost :: MutableIO HttpServlet -> MutableIO HttpServletRequest -> MutableIO HttpServletResponse -> IO ()
doPost !servlet !request !response = do
  input <- request.getParameter "cmd"
  case input of
    Nothing -> sendReplResult servlet request response (ReplError ["Invalid Script!"])
    Just cmdStr -> do
       let c = Command.parse cmdStr
       case c of
         Left err -> sendReplResult servlet request response (ReplError [err])
         Right cmd -> processCommand (Web servlet request response) cmd

processCommand :: Web -> Command -> IO ()
processCommand (web@Web{servlet=servlet,request=request,response=response}) cmd = do
    session <- request.getSession
    interpreterState <- buildInterpreterState web
    replState <- buildReplState web
    let repl  = do
                      res <- evalScript web cmd
                      session <- liftIO $ request.getSession
                      interpreterState <- Repl . lift $ Interpreter.get
                      case res of
                                  ReplError _ -> liftIO $ sendReplResult servlet request response res
                                  _ -> saveSession session >> (liftIO $ sendReplResult servlet request response res)
    evalInterpreter (evalRepl repl replState) interpreterState

saveSession :: MutableIO HttpSession -> Repl ()
saveSession session = do
            replState <- Repl.get
            interpreterState <- Repl . lift $ Interpreter.get
            let extScriptStr = maybe "" id replState.lastExternalScript
                lastJavaSource = maybe "" id replState.lastJavaSource
            liftIO $ do
                        putSession session "script" interpreterState.currentScript
                        putSession session "classes" interpreterState.classes 
                        putSession session "moduleName" interpreterState.moduleName
                        putSession session "lastExternalScript" extScriptStr
                        putSession session "lastJavaSource" lastJavaSource
            
sendReplResult :: MutableIO HttpServlet -> MutableIO HttpServletRequest -> MutableIO HttpServletResponse -> ReplResult -> IO ()
sendReplResult servlet request response (ReplError errs) = do
    let msg = asObject $ intercalate newLine errs
    request.setAttribute "msgType" (asObject "ERROR")
    request.setAttribute "msg" msg
    forwardRequest servlet request response
sendReplResult servlet request response (ReplSuccess message out err) = do
    request.setAttribute "msgType" (asObject "SUCCESS")
    request.setAttribute "msg" (asObject message)
    request.setAttribute "out" (asObject out)
    request.setAttribute "err" (asObject err)
    forwardRequest servlet request response
sendReplResult servlet request response (ReplMessage message) = do
    request.setAttribute "msgType" (asObject "MESSAGE")
    request.setAttribute "msg" (asObject message)
    forwardRequest servlet request response
sendReplResult servlet request response (NoOutput) = do
    request.setAttribute "msgType" (asObject "NOOUTPUT")
    request.setAttribute "msg" (asObject "")
    forwardRequest servlet request response

forwardRequest :: MutableIO HttpServlet -> MutableIO HttpServletRequest -> MutableIO HttpServletResponse -> IO ()
forwardRequest servlet request response = do
    dispatcher <- request.getRequestDispatcher $ "/WEB-INF/pages/replResponse.jsp"
    dispatcher.forward request response

native asClassesMap "(java.util.Map)" :: Object -> STMutable s (JMap String ByteArr)

pure native asString "(java.lang.String)" :: Object -> String

native currentTimeMillis java.lang.System.currentTimeMillis :: () -> IO Long

pure native toString :: Object -> String

pure native asObject "(Object)" :: a -> Object
