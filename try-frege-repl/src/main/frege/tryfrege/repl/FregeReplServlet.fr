module tryfrege.repl.FregeReplServlet where

import frege.Prelude hiding (print)
import Compiler.Data (Symbol, linkAll, DefinitionT, ImportList, ImportItem, SName)
import Compiler.BaseTypes (Position, TokenID, Token)
import Compiler.Import
import Data.List (intercalate)
import Interpreter.FregeInterpreter
import Repl.FregeRepl (eval, slurp, Repl, ReplResult, ReplEnv, Command, help)
import tryfrege.repl.ServletSupport

read :: Web -> ReplEnv -> IO ([Message] | Command)
read web state = do
   line <- fmap (maybe "" id) $ web.request.getParameter "cmd"
   let readResource resource = do
                                 res <- slurp resource
                                 return $ either (\a -> Left [a]) Right res
   case Command.parse line of
     Left err -> return $ Left [Message.error err]
     Right Reload -> maybe err readResource state.lastExternalScript where
       err = return $ Left [Message.error "No source to reload!"]
     Right (Load path) -> readResource path
     Right cmd -> return $ Right cmd

print :: Web -> Command -> ReplEnv -> ReplResult -> IO [Message]
print _ Java _ (JavaSource src) = return [Message.info src]
print _ (HelpDoc src) _ (DocHelp doc) = return [Message.info doc]
print _ _ _ (ReplInfo msgs) = return msgs
print web (cmd@(Eval line)) env (CodeInfo sourceRepr g msgs) = case sourceRepr of
  Expression sym | isVariable g sym =
    if isString g sym
      then do
              stdoutWriter <- StringWriter.new ()
              stderrWriter <- StringWriter.new ()
              stdin <- fmap (maybe "" id) $ web.request.getParameter "stdin"
              valMaybe <- sandboxFieldValue (symbolClass sym g) (symbolVar sym) stdin stdoutWriter stderrWriter env.state.classLoader
              out <- stdoutWriter.toString
              err <- stderrWriter.toString
              return $ maybe [Message.error "undefined"]
                             (\m -> [Message.info m, Message.hint out, Message.error err]) valMaybe
           `catch` (\err -> return [Message.error $ showThrowableCause err])
      else do
        let evalShow = do
                          let varDecl = variableDeclScript sym.name.base line
                          when (line /= sym.name.base) $
                            Repl.modify ReplEnv.{config <- InterpreterConfig.{predefs <- ((:) varDecl)}}
                          eval (Eval $ buildShowScript sym.name.base g sym)
        let (res, newEnv) = Repl.run evalShow env
        case res of
          CodeInfo{} -> print web cmd newEnv res
          _ -> return [Message.hint (":: " ++ (getSymbolType g sym))]
  Expression sym = return [Message.hint (":: " ++ (getSymbolType g sym))]
  Definitions syms = do
    let symLabels = map (showSymbol g) $ filter (not . Symbol.{alias?}) newSyms
        newSyms = filter (\sym -> sym.pos.line > lineStart) syms
        lineStart = case env.config.predefs of
                  [] -> 0
                  (_:xs) -> fold (\z \x -> z + length (lines x)) 1 xs -- Ignore module line and import PreludeScripting
    return (Message.hint (intercalate newLine symLabels) : filter (\msg -> msg.pos.line > lineStart) msgs)
  Module moduleName = return (Message.info ("Module " ++ moduleName) : msgs)
print web (LoadExternal path script) env res = print web (Eval script) env res
print _ _ _ _ = return []

doGet :: MutableIO HttpServlet -> MutableIO HttpServletRequest -> MutableIO HttpServletResponse -> IO ()
doGet = doPost

doPost :: MutableIO HttpServlet -> MutableIO HttpServletRequest -> MutableIO HttpServletResponse -> IO ()
doPost !servlet !request !response = do
  let web = Web servlet request response
  session <- request.getSession
  env <- buildReplEnv web
  input <- read web env
  case input of
    Left msgs -> sendReplResult response msgs
    Right Reset -> clearSession session >> sendReplResult response []
    Right Help -> sendReplResult response [Message.info (help cmdHelp)]
    Right cmd -> do
       let (res, newEnv) = Repl.run (eval cmd) env
       msgs <- print web cmd newEnv res
       saveSession newEnv session
       sendReplResult response msgs

buildReplEnv :: Web -> IO ReplEnv
buildReplEnv (Web{servlet=servlet,request=request}) = do
  session <- request.getSession
  let strToMaybe "" = Nothing
      strToMaybe s = Just s
  lastJavaGenSrc <- sessionAttr session (return . strToMaybe . asString) (return Nothing) "lastJavaGenSrc"
  lastExternalScript <- sessionAttr session (return . strToMaybe . asString) (return Nothing) "lastExternalScript"
  let stringArrToList s = do
                            sarr <- asStringArr s
                            arr <- readonly id sarr
                            return arr.toList
  predefs <- sessionAttr session stringArrToList (return []) "predefs"
  context <- servlet.getServletContext
  classes <- sessionAttr session asClassesMap (initClasses context) "classes"
  classLoader <- InterpreterClassLoader.new classes >>= Mutable.freeze
  return $ ReplEnv {
                     lastJavaGenSrc = lastJavaGenSrc,
                     lastExternalScript = lastExternalScript,
                     prompt = "",
                     config = InterpreterConfig predefs transformDefs,
                     state = InterpreterState classLoader
                   }

initClasses :: MutableIO ServletContext -> IOMutable (JMap String ByteArray)
initClasses context = do
  preludeClassesMaybe <- context.getAttribute "classes"
  maybe (HashMap.new () :: STMutable s (JMap String ByteArray)) asClassesMap preludeClassesMaybe

interpreterPreludeImport = ImpDcl {pos=Position.null, pack="tryfrege.interpreter.PreludeInterpreter", as=Nothing, imports = linkAll}

preludeHidingImport = ImpDcl {
  pos = Position.null,
  pack = "frege.Prelude",
  as = Nothing,
  imports = Imports {
              publik = false,
              except = true,
              items = [
                fnImport "getLine", fnImport "getChar", fnImport "getContents"
              ]
            }
} where
  fnImport name = Item {publik = false, name = fn name, members = Nothing, alias=""}
  fn name = Simple {id = Token VARID name 1 0 0 []}

transformDefs defs = do
  uniqdefs <- removeDuplicateDefs defs
  return (interpreterPreludeImport : preludeHidingImport : uniqdefs)

sessionAttr :: Mutable s HttpSession -> (Object -> ST s b) -> ST s b -> String -> ST s b
sessionAttr session f default name = do
  attrObj <- session.getAttribute name
  maybe default f attrObj


saveSession :: ReplEnv -> MutableIO HttpSession -> IO ()
saveSession replEnv session = do
  let extScriptStr = maybe "" id replEnv.lastExternalScript
      lastJavaGenSrc = maybe "" id replEnv.lastJavaGenSrc
  predefsArr <- StringArray.fromList replEnv.config.predefs
  putStrArraySession session "predefs" predefsArr
  putSession session "classes" replEnv.state.classLoader.classes
  putSession session "lastExternalScript" extScriptStr
  putSession session "lastJavaGenSrc" lastJavaGenSrc

clearSession :: MutableIO HttpSession -> IO ()
clearSession session = do
  session.removeAttribute "predefs"
  session.removeAttribute "classes"
  session.removeAttribute "lastExternalScript"
  session.removeAttribute "lastJavaGenSrc"

sendReplResult :: MutableIO HttpServletResponse -> [Message] -> IO ()
sendReplResult response msgs = do
  response.setContentType "text/xml;charset=UTF-8"
  out <- response.getWriter
  out.println $ messagesToXml msgs

putSession :: Mutable s HttpSession -> String -> a -> ST s ()
putSession session name value = session.setAttribute name (asObject value)

putStrArraySession :: Mutable s HttpSession -> String -> ArrayOf s String -> ST s ()
putStrArraySession session name arr = do
  arrObj <- strArrToObject arr
  session.setAttribute name arrObj

pure native isControl java.lang.Character.isISOControl :: Char -> Bool

removeControlChars :: String -> String
removeControlChars s = packed . reverse $ go [] s.toList where
  go acc [] = acc
  go acc (x: xs) | wanted x = go (x:acc) xs
  go acc (_: xs) = go acc xs
  wanted x = not (isControl x) || x == '\n' || x == '\r' || x == '\t'

native strArrToObject "(Object)" :: ArrayOf s String -> ST s Object

pure native escapeXml org.apache.commons.lang3.StringEscapeUtils.escapeXml :: String -> String

cmdHelp = [(":t or :type <expression>", "Display the type of an expression."),
            (":browse <module name>", "Display the names in a module if " ++
                "a module name is provided otherwise display the names in the default REPL module."),
            (":load <url>", "Load Frege code snippets from an URL."),
            (":java", "View Java translation of last compiled Frege source. In the source window, " ++
                      "press ctrl+q to expand or collapse a line."),
            (":r", "Reload the last url source."),
            (":history", "Display the source history for definitions in the default REPL module."),
            (":version", "Display Frege version."),
            (":{", "Start multiline snippets."),
            (":}", "End multiline snippets."),
            (":stdin", "Edit Console Input."),
            (":reset", "Reset the session discarding all evaluated scripts."),
            (":clear", "Clear REPL window. Session will continue to be active."),
            (":help <name>", "Display the documentation for the given name." ++
                            " If the name is not provided, display this help message.")]

messagesToXml :: [Message] -> String
messagesToXml msgs = render [
                      "<repl>",
                      "  <messages>",
                           msgsToXml,
                      "  </messages>",
                      "</repl>"
                     ] where
  render = unlines
  msgsToXml = render $ map msgToXml msgs
  msgToXml msg = render [
                          "<message>",
                          "  <type>",
                               show $ msg.msgType,
                          "  </type>",
                          "  <position>",
                               show $ msg.pos,
                          "  </position>",
                          "  <text>",
                               escapeXml . removeControlChars $ msg.text,
                          "  </text>",
                          "</message>"
                        ]

type StringArray = JArray String

native asClassesMap "(java.util.Map)" :: Object -> STMutable s (JMap String ByteArray)

pure native asString "(java.lang.String)" :: Object -> String

native asStringArr "(java.lang.String[])" :: Object -> STMutable s (JArray String)

pure native asObject "(Object)" :: a -> Object

pure native toString :: Object -> String