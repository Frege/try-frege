module tryfrege.repl.FregeReplServlet where

import frege.Prelude hiding (print)
import Compiler.Data (Symbol, linkAll, DefinitionT, ImportList, ImportItem, SName)
import Compiler.BaseTypes (Position, TokenID, Token)
import Compiler.Import
import Data.List (intercalate)
import Interpreter.FregeInterpreter
import Repl.FregeRepl (eval, slurp, Repl, ReplResult, ReplEnv, Command, help)
import tryfrege.repl.ServletSupport

read :: Web -> ReplEnv -> IO ([Message] | Command)
read web state = do
   line <- fmap (maybe "" id) $ web.request.getParameter "cmd"
   let readResource resource = do
                                 res <- slurp resource
                                 return $ either (\a -> Left [a]) Right res
   case Command.parse line of
     Left err -> return $ Left [Message.error err]
     Right Reload -> maybe err readResource state.lastExternalScript where
       err = return $ Left [Message.error "No source to reload!"]
     Right (Load path) -> readResource path
     Right cmd -> return $ Right cmd

print :: Command -> ReplResult -> ReplEnv -> IO [Message]
print Java (JavaSource src) _ = return [Message.info src]
print (HelpDoc src) (DocHelp doc) _ = return [Message.info doc]
print _ (ReplInfo msgs) env = return msgs
print (cmd@(Eval line)) (CodeInfo sourceRepr g msgs) env = case sourceRepr of
  Expression sym | isVariable g sym =
    if isString g sym
      then do
              valMaybe <- sandboxFieldValue (symbolClass sym g) (symbolVar sym) env.state.classLoader
              outMaybe <- fieldValue "scripting.PreludeScripting" "stdoutWriter" env.state.classLoader
              errMaybe <- fieldValue "scripting.PreludeScripting" "stderrWriter" env.state.classLoader
              let out = maybe "" (toString . asObject) outMaybe
                  err = maybe "" (toString . asObject) errMaybe
              return $ maybe [Message.error "undefined"]
                             (\m -> [Message.info m, Message.hint out, Message.error err]) valMaybe
           `catch` (\err -> return [Message.error $ showThrowableCause err])
      else do
        let evalShow = do
                          let varDecl = variableDeclScript sym.name.base line
                          when (line /= sym.name.base) $
                            Repl.modify ReplEnv.{config <- InterpreterConfig.{predefs <- ((:) varDecl)}}
                          eval (Eval $ buildShowScript sym.name.base g sym)
        let (res, newEnv) = Repl.run evalShow env
        case res of
          CodeInfo{} -> print cmd res newEnv
          _ -> return [Message.hint (":: " ++ (getSymbolType g sym))]
  Expression sym = return [Message.hint (":: " ++ (getSymbolType g sym))]
  Definitions syms = do
    let symLabels = map (showSymbol g) $ filter (not . Symbol.{alias?}) newSyms
        newSyms = filter (\sym -> sym.pos.line > lineStart) syms
        lineStart = case env.config.predefs of
                  [] -> 0
                  (_:xs) -> fold (\z \x -> z + length (lines x)) 1 xs -- Ignore module line and import PreludeScripting
    return (Message.hint (intercalate newLine symLabels) : filter (\msg -> msg.pos.line > lineStart) msgs)
  Module moduleName = return (Message.info ("Module " ++ moduleName) : msgs)
print (LoadExternal path script) res env = print (Eval script) res env
print _ _ _ = return []

scriptingPreludeImport = ImpDcl {pos=Position.null, pack="scripting.PreludeScripting", as=Nothing, imports = linkAll}

preludeHidingImport = ImpDcl {
  pos = Position.null,
  pack = "frege.Prelude",
  as = Nothing,
  imports = Imports {
              publik = false,
              except = true,
              items = [
                fnImport "print", fnImport "println", fnImport "printStr", fnImport "printStrLn",
                fnImport "trace", fnImport "traceLn", fnImport "traceStr", fnImport "traceStrLn",
                fnImport "stderr", fnImport "stdout"
              ]
            }
} where
  fnImport name = Item {publik = false, name = fn name, members = Nothing, alias=""}
  fn name = Simple {id = Token VARID name 1 0 0 []}

transformDefs defs = do
  uniqdefs <- removeDuplicateDefs defs
  return (scriptingPreludeImport : preludeHidingImport : uniqdefs)

doGet :: MutableIO HttpServlet -> MutableIO HttpServletRequest -> MutableIO HttpServletResponse -> IO ()
doGet = doPost

doPost :: MutableIO HttpServlet -> MutableIO HttpServletRequest -> MutableIO HttpServletResponse -> IO ()
doPost !servlet !request !response = do
  let web = Web servlet request response
  session <- request.getSession
  env <- buildReplEnv web
  input <- read web env
  case input of
    Left msgs -> sendReplResult response msgs
    Right Reset -> clearSession session >> sendReplResult response []
    Right Help -> sendReplResult response [Message.info (help cmdHelp)]
    Right cmd -> do
       let (res, newEnv) = Repl.run (eval cmd) env
       msgs <- print cmd res newEnv
       saveSession newEnv session
       sendReplResult response msgs

buildReplEnv :: Web -> IO ReplEnv
buildReplEnv (Web{servlet=servlet,request=request}) = do
  session <- request.getSession
  let strToMaybe "" = Nothing
      strToMaybe s = Just s
  lastJavaGenSrc <- sessionAttr session (return . strToMaybe . asString) (return Nothing) "lastJavaGenSrc"
  lastExternalScript <- sessionAttr session (return . strToMaybe . asString) (return Nothing) "lastExternalScript"
  let stringArrToList s = do
                            sarr <- asStringArr s
                            arr <- readonly id sarr
                            return arr.toList
  predefs <- sessionAttr session stringArrToList (return []) "predefs"
  context <- servlet.getServletContext
  classes <- sessionAttr session asClassesMap (initClasses context) "classes"
  classLoader <- InterpreterClassLoader.new classes >>= Mutable.freeze
  return $ ReplEnv {
                     lastJavaGenSrc = lastJavaGenSrc,
                     lastExternalScript = lastExternalScript,
                     prompt = "",
                     config = InterpreterConfig predefs transformDefs,
                     state = InterpreterState classLoader
                   }

initClasses :: MutableIO ServletContext -> IOMutable (JMap String ByteArr)
initClasses context = do
  preludeClassesMaybe <- context.getAttribute "classes"
  maybe (HashMap.new () :: STMutable s (JMap String ByteArr)) asClassesMap preludeClassesMaybe

sessionAttr :: Mutable s HttpSession -> (Object -> ST s b) -> ST s b -> String -> ST s b
sessionAttr session f default name = do
  attrObj <- session.getAttribute name
  maybe default f attrObj


saveSession :: ReplEnv -> MutableIO HttpSession -> IO ()
saveSession replEnv session = do
  let extScriptStr = maybe "" id replEnv.lastExternalScript
      lastJavaGenSrc = maybe "" id replEnv.lastJavaGenSrc
  putSession session "predefs" (StringArr.fromList replEnv.config.predefs)
  putSession session "classes" replEnv.state.classLoader.classes
  putSession session "lastExternalScript" extScriptStr
  putSession session "lastJavaGenSrc" lastJavaGenSrc

clearSession :: MutableIO HttpSession -> IO ()
clearSession session = do
  session.removeAttribute "predefs"
  session.removeAttribute "classes"
  session.removeAttribute "lastExternalScript"
  session.removeAttribute "lastJavaGenSrc"

sendReplResult :: MutableIO HttpServletResponse -> [Message] -> IO ()
sendReplResult response msgs = do
  response.setContentType "text/xml;charset=UTF-8"
  out <- response.getWriter
  out.println $ messagesToXml msgs

putSession :: Mutable s HttpSession -> String -> a -> ST s ()
putSession session name value = session.setAttribute name (asObject value)

cmdHelp = [(":t or :type <expression>", "Display the type of an expression."),
            (":browse <module name>", "Display the names in a module if " ++
                "a module name is provided otherwise display the names in the default REPL module."),
            (":load <url>", "Load Frege code snippets from an URL."),
            (":java", "View Java translation of last compiled Frege source. In the source window, " ++
                      "press ctrl+q to expand or collapse a line."),
            (":r", "Reload the last url source."),
            (":history", "Display the source history for definitions in the default REPL module."),
            (":reset", "Reset the session discarding all evaluated scripts."),
            (":version", "Display Frege version."),
            (":{", "Start multiline definitions."),
            (":}", "End multiline defintions."),
            (":help <name>", "Display the documentation for the given name." ++
                            " If the name is not provided, display this help message.")]

messagesToXml :: [Message] -> String
messagesToXml msgs = render [
                      "<repl>",
                      "  <messages>",
                           msgsToXml,
                      "  </messages>",
                      "</repl>"
                     ] where
  render = unlines
  msgsToXml = render $ map msgToXml msgs
  msgToXml msg = render [
                          "<message>",
                          "  <type>",
                               show $ msg.msgType,
                          "  </type>",
                          "  <position>",
                               show $ msg.pos,
                          "  </position>",
                          "  <text><![CDATA[",
                               msg.text,
                          "  ]]></text>",
                          "</message>"
                        ]


native asClassesMap "(java.util.Map)" :: Object -> STMutable s (JMap String ByteArr)

pure native asString "(java.lang.String)" :: Object -> String

native asStringArr "(java.lang.String[])" :: Object -> STMutable s StringArr

pure native asObject "(Object)" :: a -> Object

pure native toString :: Object -> String