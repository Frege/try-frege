<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<META http-equiv="Content-Type" content="text/html;charset=utf-8">
<TITLE>frege.prelude.PreludeMonad - frege documentation</TITLE>
<style TYPE="text/css">
body { font-family: helvetica, arial, sans-serif }
pre { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(0%,0%,60%) }
h3  { font-weight: lighter }
dt.func { background: rgb(95%, 95%, 80%); margin-top: 10px }
dt.clas { background: rgb(80%, 95%, 95%); margin-top: 10px }
dt.inst { background: rgb(95%, 90%, 95%); margin-top: 10px }
dt.data { background: rgb(95%, 95%, 95%); margin-top: 10px }
span.code { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(0%,0%,60%) }
span.unknown { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: red }
a.fref { text-decoration: none; font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(30%, 30%, 0%) }
a.tref { text-decoration: none; font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(40%, 0%,  40%) }
</style>
<BODY>
<h1>
<a name="package">Package <SPAN CLASS="code">frege.prelude.PreludeMonad</SPAN></a></h1>
<p>
Compiled: Mon Nov 18 01:41:28 CET 2013 from source file: <SPAN CLASS="code">frege/prelude/PreludeMonad.fr</SPAN></p>
<h3>
Package Documentation</h3>
<p>
This package provides the <a class="tref" href="#Monad">Monad</a> class and related classes and functions.</p>
<p>
The class hierarchy is derived from the (Haskell) proposal <b>/The Other Prelude/</b> but the traditional method names have been kept.</p>
<p>
The functions in this library use the following naming conventions:</p>
<ul>
<LI>
 A postfix "M"" always stands for a function in the Kleisli category: The monad type constructor <i>m</i> is added to function results (modulo currying) and nowhere else. So, for example,</LI>
</ul>
<PRE>
 filter ::               (a -&gt; Bool) -  &gt; [a] -&gt; [a]
 filterM :: (Monad m) =&gt; (a -&gt; m Bool) -&gt; [a] -&gt; m [a]</PRE>
<ul>
<LI>
 A postfix "<i>" changes the result type from (</i>m a<i>) to (</i>m ()_). Thus, for example: </LI>
</ul>
<PRE>
 sequence  :: Monad m =&gt; [m a] -&gt; m [a]
 sequence_ :: Monad m =&gt; [m a] -&gt; m ()</PRE>
<ul>
<LI>
 A prefix "m" generalizes an existing function to a monadic form. Thus, for example: </LI>
</ul>
<PRE>
 sum :: Num a =&gt; [a] -&gt; a
 msum :: MonadPlus m =&gt; [m a] -&gt; m a</PRE>
<p>
This package is <i>implementation specific</i> insofar as the compiler may assume that certain items are defined here in a certain way. Changes may thus lead to compiler crashes or java code that will be rejected by the java compiler.</p>
<p>
In particular, desugared <b><SPAN CLASS="code">do</SPAN></b> expressions will reference <a class="tref" href="#Monad">Monad</a>, <a class="fref" href="#Bind._gt_gt_eq">Bind.&gt;&gt;=</a> and <a class="fref" href="#Monad._gt_gt">Monad.&gt;&gt;</a>.</p>
<p>
This package is implicitly imported and besides the additional stuff covers most of what one would get by importing <i>Control.Monad</i> and <i>Control.Applicative</i> in Hasekll.</p>
<h3>
Table of Content</h3>
<ul>
<li>
<div>
<a HREF="#type">Type Aliases</a></div>
<div>
<a class="tref" href="#Reader">Reader</a></div>
</li>
<li>
<div>
<a HREF="#class">Classes</a></div>
<div>
<a class="tref" href="#Alt">Alt</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#Applicative">Applicative</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#Apply">Apply</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#Bind">Bind</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#Functor">Functor</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#Monad">Monad</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#MonadAlt">MonadAlt</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#MonadFail">MonadFail</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#MonadOr">MonadOr</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#MonadPlus">MonadPlus</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#MonadZero">MonadZero</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#Plus">Plus</a></div>
</li>
<li>
<div>
<a HREF="#instance">Instances</a></div>
<div>
<a class="tref" href="#Applicative__minus_gt">Applicative_-&gt;</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#Functor_l_c_r">Functor_(,)</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#Functor_l_cc_r">Functor_(,,)</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#Functor__lbrack_rbrack">Functor_[]</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#MonadFail_Either">MonadFail_Either</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#MonadFail__lbrack_rbrack">MonadFail_[]</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#MonadPlus__lbrack_rbrack">MonadPlus_[]</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#Monad__minus_gt">Monad_-&gt;</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#Monad_Either">Monad_Either</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#Monad_ST">Monad_ST</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#Monad__lbrack_rbrack">Monad_[]</a></div>
</li>
<li>
<div>
<a HREF="#let">Functions and Values (alphabetically)</a></div>
<div>
<a class="fref" href="#_lt$_gt">&lt;$&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#_lt_eq_lt">&lt;=&lt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#_eq_lt_lt">=&lt;&lt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#_gt_eq_gt">&gt;=&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#ap">ap</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#apply">apply</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#filterM">filterM</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#foldM">foldM</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#foldM_">foldM_</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#forM">forM</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#forM_">forM_</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#forever">forever</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#guard">guard</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#liftA">liftA</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#liftA2">liftA2</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#liftA3">liftA3</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#liftA4">liftA4</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#liftA5">liftA5</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#liftM">liftM</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#liftM2">liftM2</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#liftM3">liftM3</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#liftM4">liftM4</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#liftM5">liftM5</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#mapAndUnzipM">mapAndUnzipM</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#mapM">mapM</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#mapM_">mapM_</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#mapReader">mapReader</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#msum">msum</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#replicateM">replicateM</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#replicateM_">replicateM_</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#runReader">runReader</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#sequence">sequence</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#sequence_">sequence_</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#unless">unless</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#_void">void</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#when">when</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#withReader">withReader</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#zipWithM">zipWithM</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#zipWithM_">zipWithM_</a></div>
</li>
<li>
<div>
<a HREF="#case">Functions and Values (by type)</a></div>
<div>
<a class="fref" href="#_lt$_gt">&lt;$&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#_lt_eq_lt">&lt;=&lt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#_eq_lt_lt">=&lt;&lt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#_gt_eq_gt">&gt;=&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#ap">ap</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#apply">apply</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#filterM">filterM</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#foldM">foldM</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#foldM_">foldM_</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#forM">forM</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#forM_">forM_</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#forever">forever</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#guard">guard</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#liftA">liftA</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#liftA2">liftA2</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#liftA3">liftA3</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#liftA4">liftA4</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#liftA5">liftA5</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#liftM">liftM</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#liftM2">liftM2</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#liftM3">liftM3</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#liftM4">liftM4</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#liftM5">liftM5</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#mapAndUnzipM">mapAndUnzipM</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#mapM">mapM</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#mapM_">mapM_</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#mapReader">mapReader</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#msum">msum</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#replicateM">replicateM</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#replicateM_">replicateM_</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#runReader">runReader</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#sequence">sequence</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#sequence_">sequence_</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#unless">unless</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#_void">void</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#when">when</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#withReader">withReader</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#zipWithM">zipWithM</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#zipWithM_">zipWithM_</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Alt._lt_bar_gt">Alt.&lt;|&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Applicative._lt_star">Applicative.&lt;*</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Applicative._star_gt">Applicative.*&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Applicative.pure">Applicative.pure</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Apply._lt_star_gt">Apply.&lt;*&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Bind._gt_gt_eq">Bind.&gt;&gt;=</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Functor.fmap">Functor.fmap</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad.join">Monad.join</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad._gt_gt">Monad.&gt;&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad._lt_star_gt">Monad.&lt;*&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad.fmap">Monad.fmap</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad._return">Monad.return</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad.pure">Monad.pure</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#MonadAlt._lt_plus_gt">MonadAlt.&lt;+&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#MonadFail.fail">MonadFail.fail</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#MonadOr.orElse">MonadOr.orElse</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#MonadPlus.mplus">MonadPlus.mplus</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#MonadZero.mzero">MonadZero.mzero</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Plus.pzero">Plus.pzero</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Applicative__minus_gt._lt_star">Applicative_-&gt;.&lt;*</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Applicative__minus_gt._star_gt">Applicative_-&gt;.*&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Applicative__minus_gt.fmap">Applicative_-&gt;.fmap</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Applicative__minus_gt._lt_star_gt">Applicative_-&gt;.&lt;*&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Applicative__minus_gt.pure">Applicative_-&gt;.pure</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Functor_l_c_r.fmap">Functor_(,).fmap</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Functor_l_cc_r.fmap">Functor_(,,).fmap</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Functor__lbrack_rbrack.fmap">Functor_[].fmap</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#MonadFail_Either.fail">MonadFail_Either.fail</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#MonadFail__lbrack_rbrack.fail">MonadFail_[].fail</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#MonadPlus__lbrack_rbrack.mzero">MonadPlus_[].mzero</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#MonadPlus__lbrack_rbrack.mplus">MonadPlus_[].mplus</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad__minus_gt._gt_gt_eq">Monad_-&gt;.&gt;&gt;=</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad__minus_gt._gt_gt">Monad_-&gt;.&gt;&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad__minus_gt._return">Monad_-&gt;.return</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad__minus_gt.join">Monad_-&gt;.join</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad_Either._gt_gt">Monad_Either.&gt;&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad_Either._lt_star">Monad_Either.&lt;*</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad_Either._star_gt">Monad_Either.*&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad_Either._lt_star_gt">Monad_Either.&lt;*&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad_Either.fmap">Monad_Either.fmap</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad_Either._gt_gt_eq">Monad_Either.&gt;&gt;=</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad_Either.pure">Monad_Either.pure</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad_Either.join">Monad_Either.join</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad_Either._return">Monad_Either.return</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad_ST._gt_gt">Monad_ST.&gt;&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad_ST._lt_star">Monad_ST.&lt;*</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad_ST._star_gt">Monad_ST.*&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad_ST._lt_star_gt">Monad_ST.&lt;*&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad_ST.join">Monad_ST.join</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad_ST.fmap">Monad_ST.fmap</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad_ST.pure">Monad_ST.pure</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad__lbrack_rbrack._gt_gt">Monad_[].&gt;&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad__lbrack_rbrack._lt_star">Monad_[].&lt;*</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad__lbrack_rbrack._star_gt">Monad_[].*&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad__lbrack_rbrack._lt_star_gt">Monad_[].&lt;*&gt;</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad__lbrack_rbrack.join">Monad_[].join</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad__lbrack_rbrack._gt_gt_eq">Monad_[].&gt;&gt;=</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad__lbrack_rbrack._return">Monad_[].return</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Monad__lbrack_rbrack.pure">Monad_[].pure</a></div>
</li>
</ul>
<h3>
Imports</h3>
<ul>
<li>
<div>
import <a HREF="./PreludeList.html">frege.prelude.PreludeList</a> as PreludeList</div>
</li>
<li>
<div>
import <a HREF="./PreludeBase.html">frege.prelude.PreludeBase</a> as PreludeBase</div>
</li>
<li>
<div>
import <a HREF="../control/Category.html">frege.control.Category</a> as Category</div>
</li>
<li>
<div>
import <a HREF="../control/Semigroupoid.html">frege.control.Semigroupoid</a> as Semigroupoid</div>
</li>
</ul>
<h2>
<a name="type">Type Aliases</a></h2>
<dl class="clas">
<dt class="clas">
<SPAN CLASS="code"><b>type </b><a name="Reader">Reader</a>  = <a class="tref" href="./PreludeBase.html#Function">-&gt;</a></SPAN></dt>
<dd class="clas">
</dd>
</dl>
<h2>
<a name="class">Classes</a></h2>
<dl class="clas">
<dt class="clas">
<SPAN CLASS="code"><b>class </b><a name="Alt">Alt</a> <a class="tref" href="#Functor">Functor</a> f =&gt;  f</SPAN></dt>
<dd class="clas">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="Alt._lt_bar_gt">&lt;|&gt;</a> :: <a class="tref" href="#Alt">Alt</a> f =&gt; f a -&gt; f a -&gt; f a</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="clas">
<SPAN CLASS="code"><b>class </b><a name="Applicative">Applicative</a> (<a class="tref" href="#Functor">Functor</a> p, <a class="tref" href="#Apply">Apply</a> p) =&gt;  p</SPAN></dt>
<dd class="clas">
<p>
A functor with application, providing operations to</p>
<ul>
<LI>
 embed pure expressions (<a class="fref" href="#Applicative.pure">Applicative.pure</a>), and </LI>
<LI>
 sequence computations and combine their results (<a class="fref" href="#Apply._lt_star_gt">Apply.&lt;*&gt;</a>). </LI>
</ul>
<p>
A minimal complete definition must include implementations of these functions satisfying the following laws:</p>
<dl>
<dt>
<i>identity</i></dt>
<dd>
<div>
 <SPAN CLASS="code">pure id &lt;*&gt; v = v</SPAN></div>
</dd>
<dt>
<i>composition</i></dt>
<dd>
<div>
 <SPAN CLASS="code">pure (•) &lt;<b>&gt; u &lt;</b>&gt; v &lt;<b>&gt; w = u &lt;</b>&gt; (v &lt;*&gt; w)</SPAN></div>
</dd>
<dt>
<i>homomorphism</i></dt>
<dd>
<div>
 <SPAN CLASS="code">pure f &lt;*&gt; pure x = pure (f x)</SPAN></div>
</dd>
<dt>
<i>interchange</i></dt>
<dd>
<div>
 <SPAN CLASS="code">u &lt;<b>&gt; pure y = pure ($ y) &lt;</b>&gt; u</SPAN></div>
</dd>
</dl>
<p>
The other methods have the following default definitions, which may be overridden with equivalent specialized implementations:</p>
<PRE>
  u *&gt; v = pure (const id)  &lt;*&gt; u &lt;*&gt; v
  u &lt;* v = pure const &lt;*&gt; u &lt;*&gt; v</PRE>
<p>
As a consequence of these laws, the <a class="tref" href="#Functor">Functor</a> instance for <SPAN CLASS="code">f</SPAN> will satisfy</p>
<PRE>
 fmap f x = pure f &lt;*&gt; x</PRE>
<p>
If <SPAN CLASS="code">f</SPAN> is also a <a class="tref" href="#Monad">Monad</a>, it should satisfy</p>
<PRE>
 (&lt;*&gt;) = ap</PRE>
<p>
(which implies that <a class="fref" href="#Applicative.pure">Applicative.pure</a> and <a class="fref" href="#Apply._lt_star_gt">Apply.&lt;*&gt;</a> satisfy the applicative functor laws).</p>
<p>
Minimal complete definition: <a class="fref" href="#Applicative.pure">Applicative.pure</a> and <a class="fref" href="#Apply._lt_star_gt">Apply.&lt;*&gt;</a>.</p>
<h3>
Known Instances</h3>
<p>
<a class="tref" href="#Monad__lbrack_rbrack">[]</a>, <a class="tref" href="#Monad_ST">ST</a>, <a class="tref" href="#Monad_Either">Either</a>, <a class="tref" href="#Applicative__minus_gt">-&gt;</a></p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="Applicative._star_gt">*&gt;</a> :: <a class="tref" href="#Applicative">Applicative</a> p =&gt; p a -&gt; p b -&gt; p b</SPAN></dt>
<dd class="func">
<p>
Sequence actions, discarding the value of the first argument.   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Applicative._lt_star">&lt;*</a> :: <a class="tref" href="#Applicative">Applicative</a> p =&gt; p a -&gt; p b -&gt; p a</SPAN></dt>
<dd class="func">
<p>
Sequence actions, discarding the value of the second argument.   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Applicative.pure">pure</a> :: <a class="tref" href="#Applicative">Applicative</a> p =&gt; a -&gt; p a</SPAN></dt>
<dd class="func">
<p>
Lift a value   </p>
</dd>
</dl>
</dd>
<dt class="clas">
<SPAN CLASS="code"><b>class </b><a name="Apply">Apply</a> <a class="tref" href="#Functor">Functor</a> f =&gt;  f</SPAN></dt>
<dd class="clas">
<h3>
Known Instances</h3>
<p>
<a class="tref" href="#Monad__lbrack_rbrack">[]</a>, <a class="tref" href="#Monad_ST">ST</a>, <a class="tref" href="#Monad_Either">Either</a>, <a class="tref" href="#Applicative__minus_gt">-&gt;</a></p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="Apply._lt_star_gt">&lt;*&gt;</a> :: <a class="tref" href="#Apply">Apply</a> f =&gt; f (a-&gt;b) -&gt; f a -&gt; f b</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="clas">
<SPAN CLASS="code"><b>class </b><a name="Bind">Bind</a> (<a class="tref" href="#Functor">Functor</a> f, <a class="tref" href="#Apply">Apply</a> f) =&gt;  f</SPAN></dt>
<dd class="clas">
<h3>
Known Instances</h3>
<p>
<a class="tref" href="#Monad__lbrack_rbrack">[]</a>, <a class="tref" href="#Monad_ST">ST</a>, <a class="tref" href="#Monad__minus_gt">-&gt;</a>, <a class="tref" href="#Monad_Either">Either</a></p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="Bind._gt_gt_eq">&gt;&gt;=</a> :: <a class="tref" href="#Bind">Bind</a> f =&gt; f a -&gt; (a -&gt; f b) -&gt; f b</SPAN></dt>
<dd class="func">
<p>
Sequentially compose two actions, passing any value produced by the first as an argument to the second.   </p>
</dd>
</dl>
</dd>
<dt class="clas">
<SPAN CLASS="code"><b>class </b><a name="Functor">Functor</a>  f</SPAN></dt>
<dd class="clas">
<p>
The <a class="tref" href="#Functor">Functor</a> class is used for types that can be mapped over. Instances of <a class="tref" href="#Functor">Functor</a> should satisfy the following laws:</p>
<PRE>
 fmap id == id
 fmap (f . g) ==
 fmap f . fmap g</PRE>
<h3>
Known Instances</h3>
<p>
<a class="tref" href="#Monad_ST">ST</a>, <a class="tref" href="#Monad_Either">Either</a>, <a class="tref" href="#Applicative__minus_gt">-&gt;</a>, <a class="tref" href="#Functor_l_cc_r">(,,)</a>, <a class="tref" href="#Functor_l_c_r">(,)</a>, <a class="tref" href="#Functor__lbrack_rbrack">[]</a></p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="Functor.fmap">fmap</a> :: <a class="tref" href="#Functor">Functor</a> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</SPAN></dt>
<dd class="func">
<p>
Map a function over a <a class="tref" href="#Functor">Functor</a>   </p>
</dd>
</dl>
</dd>
<dt class="clas">
<SPAN CLASS="code"><b>class </b><a name="Monad">Monad</a> (<a class="tref" href="#Functor">Functor</a> m, <a class="tref" href="#Apply">Apply</a> m, <a class="tref" href="#Bind">Bind</a> m, <a class="tref" href="#Applicative">Applicative</a> m) =&gt;  m</SPAN></dt>
<dd class="clas">
<p>
The <a class="tref" href="#Monad">Monad</a> class defines the basic operations over a <i>monad</i>, a concept from a branch of mathematics known as <i>category theory</i>. From the perspective of a Frege programmer, however, it is best to think of a monad as an <i>abstract datatype</i> of actions.</p>
<p>
Frege’s <b><SPAN CLASS="code">do</SPAN></b> expressions provide a convenient syntax for writing monadic expressions.</p>
<p>
Instances of Monad should satisfy the following laws:</p>
<PRE>
 return a &gt;&gt;= k == k a
 m &gt;&gt;= return == m
 m &gt;&gt;= (\x -&gt; k x &gt;&gt;= h) == (m &gt;&gt;= k) &gt;&gt;= h</PRE>
<p>
Since instances of <a class="tref" href="#Monad">Monad</a> are also instances of <a class="tref" href="#Functor">Functor</a>, they additionally shall satisfy the law:</p>
<PRE>
 fmap f xs == xs &gt;&gt;= return • f</PRE>
<p>
which is also the default implementation of <a class="fref" href="#Functor.fmap">Functor.fmap</a>.</p>
<p>
The instances of <a class="tref" href="#Monad">Monad</a> for lists, <a class="tref" href="./PreludeBase.html#Maybe">Maybe</a> and <a class="tref" href="./PreludeBase.html#ST">ST</a> defined in the Prelude satisfy these laws.</p>
<p>
Minimal complete definition: <a class="fref" href="#Bind._gt_gt_eq">Bind.&gt;&gt;=</a> and (<a class="fref" href="#Applicative.pure">Applicative.pure</a> or <a class="fref" href="#Monad._return">Monad.return</a>)</p>
<h3>
Known Instances</h3>
<p>
<a class="tref" href="#Monad__lbrack_rbrack">[]</a>, <a class="tref" href="#Monad_ST">ST</a>, <a class="tref" href="#Monad__minus_gt">-&gt;</a>, <a class="tref" href="#Monad_Either">Either</a></p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="Monad._lt_star_gt">&lt;*&gt;</a> :: <a class="tref" href="#Monad">Monad</a> m =&gt; m (a-&gt;b) -&gt; m a -&gt; m b</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad._gt_gt">&gt;&gt;</a> :: <a class="tref" href="#Monad">Monad</a> m =&gt; m a -&gt; m b -&gt; m b</SPAN></dt>
<dd class="func">
<p>
Sequentially compose two actions, discarding any value produced by the first, this works like sequencing operators (such as the semicolon) in imperative languages.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad.fmap">fmap</a> :: <a class="tref" href="#Monad">Monad</a> m =&gt; (a -&gt; b) -&gt; m a -&gt; m b</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad.join">join</a> :: <a class="tref" href="#Monad">Monad</a> m =&gt; m (m a) -&gt; m a</SPAN></dt>
<dd class="func">
<p>
The <a class="fref" href="#Monad.join">Monad.join</a> function is the conventional monad <b>join</b> operator. It is used to remove one level of monadic structure, projecting its bound argument into the outer level.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad.pure">pure</a> :: <a class="tref" href="#Monad">Monad</a> m =&gt; <b>a</b> -&gt; m a</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad._return">return</a> :: <a class="tref" href="#Monad">Monad</a> m =&gt; <b>a</b> -&gt; m a</SPAN></dt>
<dd class="func">
<p>
Inject a value into the <a class="tref" href="#Monad">Monad</a>. This is the same as <a class="fref" href="#Applicative.pure">Applicative.pure</a>.</p>
</dd>
</dl>
</dd>
<dt class="clas">
<SPAN CLASS="code"><b>class </b><a name="MonadAlt">MonadAlt</a> (<a class="tref" href="#Functor">Functor</a> f, <a class="tref" href="#Alt">Alt</a> f, <a class="tref" href="#Plus">Plus</a> f, <a class="tref" href="#Apply">Apply</a> f, <a class="tref" href="#Bind">Bind</a> f, <a class="tref" href="#Applicative">Applicative</a> f, <a class="tref" href="#Monad">Monad</a> f) =&gt;  f</SPAN></dt>
<dd class="clas">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="MonadAlt._lt_plus_gt">&lt;+&gt;</a> :: <a class="tref" href="#MonadAlt">MonadAlt</a> f =&gt; f a -&gt; f a -&gt; f a</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="clas">
<SPAN CLASS="code"><b>class </b><a name="MonadFail">MonadFail</a> (<a class="tref" href="#Functor">Functor</a> m, <a class="tref" href="#Apply">Apply</a> m, <a class="tref" href="#Bind">Bind</a> m, <a class="tref" href="#Applicative">Applicative</a> m, <a class="tref" href="#Monad">Monad</a> m) =&gt;  m</SPAN></dt>
<dd class="clas">
<p>
The <a class="tref" href="#MonadFail">MonadFail</a> class augments <a class="tref" href="#Monad">Monad</a> by adding the <a class="fref" href="#MonadFail.fail">MonadFail.fail</a> operation. This operation is not part of the mathematical definition of a monad.</p>
<h3>
Known Instances</h3>
<p>
<a class="tref" href="#MonadFail_Either">Either</a>, <a class="tref" href="#MonadFail__lbrack_rbrack">[]</a></p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="MonadFail.fail">fail</a> :: <a class="tref" href="#MonadFail">MonadFail</a> m =&gt; <b><a class="tref" href="./PreludeBase.html#String">String</a></b> -&gt; m a</SPAN></dt>
<dd class="func">
<p>
Fail with a message.    </p>
</dd>
</dl>
</dd>
<dt class="clas">
<SPAN CLASS="code"><b>class </b><a name="MonadOr">MonadOr</a> (<a class="tref" href="#Functor">Functor</a> mo, <a class="tref" href="#Apply">Apply</a> mo, <a class="tref" href="#Bind">Bind</a> mo, <a class="tref" href="#Applicative">Applicative</a> mo, <a class="tref" href="#Monad">Monad</a> mo, <a class="tref" href="#MonadZero">MonadZero</a> mo) =&gt;  mo</SPAN></dt>
<dd class="clas">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="MonadOr.orElse">orElse</a> :: <a class="tref" href="#MonadOr">MonadOr</a> mo =&gt; mo a -&gt; mo a -&gt; mo a</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="clas">
<SPAN CLASS="code"><b>class </b><a name="MonadPlus">MonadPlus</a> (<a class="tref" href="#Functor">Functor</a> mp, <a class="tref" href="#Apply">Apply</a> mp, <a class="tref" href="#Bind">Bind</a> mp, <a class="tref" href="#Applicative">Applicative</a> mp, <a class="tref" href="#Monad">Monad</a> mp, <a class="tref" href="#MonadZero">MonadZero</a> mp) =&gt;  mp</SPAN></dt>
<dd class="clas">
<p>
A <a class="tref" href="#Monad">Monad</a> that also supports choice and failure and observes the following laws:</p>
<PRE>
 mzero `mplus`  v = v
 v `mplus` mzero  = v
 (a `mplus` b) `mplus` c = a `mplus` (b `mplus` c)
 (a `mplus` b) &gt;&gt;= f = (a &gt;&gt;= f) `mplus` (b &gt;&gt;= f)</PRE>
<h3>
Known Instances</h3>
<p>
<a class="tref" href="#MonadPlus__lbrack_rbrack">[]</a></p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="MonadPlus.mplus">mplus</a> :: <a class="tref" href="#MonadPlus">MonadPlus</a> mp =&gt; mp a -&gt; mp a -&gt; mp a</SPAN></dt>
<dd class="func">
<p>
an associative operation   </p>
</dd>
</dl>
</dd>
<dt class="clas">
<SPAN CLASS="code"><b>class </b><a name="MonadZero">MonadZero</a> (<a class="tref" href="#Functor">Functor</a> mz, <a class="tref" href="#Apply">Apply</a> mz, <a class="tref" href="#Bind">Bind</a> mz, <a class="tref" href="#Applicative">Applicative</a> mz, <a class="tref" href="#Monad">Monad</a> mz) =&gt;  mz</SPAN></dt>
<dd class="clas">
<p>
A <a class="tref" href="#Monad">Monad</a> with a left identity.</p>
<h3>
Known Instances</h3>
<p>
<a class="tref" href="#MonadPlus__lbrack_rbrack">[]</a></p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="MonadZero.mzero">mzero</a> :: <a class="tref" href="#MonadZero">MonadZero</a> mz =&gt; mz a</SPAN></dt>
<dd class="func">
<p>
This value should satisfy /left zero/:</p>
<PRE>
 mzero &gt;&gt;= f = mzero   </PRE>
</dd>
</dl>
</dd>
<dt class="clas">
<SPAN CLASS="code"><b>class </b><a name="Plus">Plus</a> (<a class="tref" href="#Functor">Functor</a> f, <a class="tref" href="#Alt">Alt</a> f) =&gt;  f</SPAN></dt>
<dd class="clas">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="Plus.pzero">pzero</a> :: <a class="tref" href="#Plus">Plus</a> f =&gt; f a</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
</dl>
<h2>
<a name="instance">Instances</a></h2>
<dl class="inst">
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name="Applicative__minus_gt"> </a> <a class="tref" href="#Applicative">Applicative</a> <a class="tref" href="./PreludeBase.html#Function">-&gt;</a> a</SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="Applicative__minus_gt._star_gt">*&gt;</a> :: (β-&gt;γ) -&gt; (β-&gt;α) -&gt; β -&gt; α</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Applicative._star_gt">Applicative.*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Applicative__minus_gt._lt_star">&lt;*</a> :: (<b>β-&gt;γ</b>) -&gt; (β-&gt;α) -&gt; β -&gt; γ</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Applicative._lt_star">Applicative.&lt;*</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Applicative__minus_gt._lt_star_gt">&lt;*&gt;</a> :: (<b>β-&gt;γ-&gt;α</b>) -&gt; (β-&gt;γ) -&gt; β -&gt; α</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Applicative__minus_gt.fmap">fmap</a> :: (γ -&gt; α) -&gt; (β-&gt;γ) -&gt; β -&gt; α</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Applicative__minus_gt.pure">pure</a> :: <b>α</b> -&gt; β -&gt; α</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name="Functor_l_c_r"> </a> <a class="tref" href="#Functor">Functor</a> (a)</SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="Functor_l_c_r.fmap">fmap</a> :: (γ -&gt; α) -&gt; <b>(β, γ)</b> -&gt; (β, α)</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name="Functor_l_cc_r"> </a> <a class="tref" href="#Functor">Functor</a> (a, b)</SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="Functor_l_cc_r.fmap">fmap</a> :: (δ -&gt; α) -&gt; <b>(γ, β, δ)</b> -&gt; (γ, β, α)</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name="Functor__lbrack_rbrack"> </a> <a class="tref" href="#Functor">Functor</a> <a class="tref" href="./PreludeBase.html#List">[]</a></SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="Functor__lbrack_rbrack.fmap">fmap</a> :: (α -&gt; β) -&gt; <b>[α]</b> -&gt; [β]</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name="MonadFail_Either"> </a> <a class="tref" href="#MonadFail">MonadFail</a> <a class="tref" href="./PreludeBase.html#Either">Either</a> <a class="tref" href="./PreludeBase.html#String">String</a></SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="MonadFail_Either.fail">fail</a> :: <a class="tref" href="./PreludeBase.html#String">String</a> -&gt; (<a class="tref" href="./PreludeBase.html#String">String</a> | α)</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name="MonadFail__lbrack_rbrack"> </a> <a class="tref" href="#MonadFail">MonadFail</a> <a class="tref" href="./PreludeBase.html#List">[]</a></SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="MonadFail__lbrack_rbrack.fail">fail</a> :: <a class="tref" href="./PreludeBase.html#String">String</a> -&gt; [α]</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name="MonadPlus__lbrack_rbrack"> </a> <a class="tref" href="#MonadPlus">MonadPlus</a> <a class="tref" href="./PreludeBase.html#List">[]</a></SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="MonadPlus__lbrack_rbrack.mplus">mplus</a> :: <b>[α]</b> -&gt; [α] -&gt; [α]</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="MonadPlus__lbrack_rbrack.mzero">mzero</a> :: [α]</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name="Monad__minus_gt"> </a> <a class="tref" href="#Monad">Monad</a> <a class="tref" href="./PreludeBase.html#Function">-&gt;</a> a</SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="Monad__minus_gt._gt_gt">&gt;&gt;</a> :: (β-&gt;γ) -&gt; (<b>β-&gt;α</b>) -&gt; β -&gt; α</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad__minus_gt._gt_gt_eq">&gt;&gt;=</a> :: (β-&gt;γ) -&gt; (<b>γ -&gt; β-&gt;α</b>) -&gt; β -&gt; α</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad__minus_gt.join">join</a> :: (<b>α-&gt;α-&gt;β</b>) -&gt; α -&gt; β</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad.join">Monad.join</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad__minus_gt._return">return</a> :: <b>α</b> -&gt; β -&gt; α</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name="Monad_Either"> </a> <a class="tref" href="#Monad">Monad</a> <a class="tref" href="./PreludeBase.html#Either">Either</a> left</SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="Monad_Either._star_gt">*&gt;</a> :: (β | γ) -&gt; (β | α) -&gt; (β | α)</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Applicative._star_gt">Applicative.*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad_Either._lt_star">&lt;*</a> :: (β | γ) -&gt; (β | α) -&gt; (β | γ)</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Applicative._lt_star">Applicative.&lt;*</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad_Either._lt_star_gt">&lt;*&gt;</a> :: (β | γ-&gt;α) -&gt; (β | γ) -&gt; (β | α)</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad._lt_star_gt">Monad.&lt;*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad_Either._gt_gt">&gt;&gt;</a> :: <b>(β | γ)</b> -&gt; (β | α) -&gt; (β | α)</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad._gt_gt">Monad.&gt;&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad_Either._gt_gt_eq">&gt;&gt;=</a> :: <b>(β | γ)</b> -&gt; (γ -&gt; (β | α)) -&gt; (β | α)</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad_Either.fmap">fmap</a> :: (γ -&gt; α) -&gt; <b>(β | γ)</b> -&gt; (β | α)</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad_Either.join">join</a> :: <b>(α | (α | β))</b> -&gt; (α | β)</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad.join">Monad.join</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad_Either.pure">pure</a> :: <b>α</b> -&gt; (β | α)</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad.pure">Monad.pure</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad_Either._return">return</a> :: α -&gt; (β | α)</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name="Monad_ST"> </a> <a class="tref" href="#Monad">Monad</a> <a class="tref" href="./PreludeBase.html#ST">ST</a> s</SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="Monad_ST._star_gt">*&gt;</a> :: <a class="tref" href="./PreludeBase.html#ST">ST</a> β γ -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> β α -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> β α</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Applicative._star_gt">Applicative.*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad_ST._lt_star">&lt;*</a> :: <a class="tref" href="./PreludeBase.html#ST">ST</a> β γ -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> β α -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> β γ</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Applicative._lt_star">Applicative.&lt;*</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad_ST._lt_star_gt">&lt;*&gt;</a> :: <a class="tref" href="./PreludeBase.html#ST">ST</a> β (γ-&gt;α) -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> β γ -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> β α</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad._lt_star_gt">Monad.&lt;*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad_ST._gt_gt">&gt;&gt;</a> :: <b><a class="tref" href="./PreludeBase.html#ST">ST</a> β γ</b> -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> β α -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> β α</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad_ST._gt_gt_eq">&gt;&gt;=</a> :: <b><a class="tref" href="./PreludeBase.html#ST">ST</a> γ α</b> -&gt; (α-&gt;<a class="tref" href="./PreludeBase.html#ST">ST</a> γ β) -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> γ β</SPAN></dt>
<dd class="func">
<p>
Alias for <a class="fref" href="#Bind._gt_gt_eq">Bind.&gt;&gt;=</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad_ST.fmap">fmap</a> :: (γ -&gt; α) -&gt; <b><a class="tref" href="./PreludeBase.html#ST">ST</a> β γ</b> -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> β α</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad.fmap">Monad.fmap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad_ST.join">join</a> :: <b><a class="tref" href="./PreludeBase.html#ST">ST</a> α (<a class="tref" href="./PreludeBase.html#ST">ST</a> α β)</b> -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> α β</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad.join">Monad.join</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad_ST.pure">pure</a> :: <b>α</b> -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> β α</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad.pure">Monad.pure</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad_ST._return">return</a> :: α -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> β α</SPAN></dt>
<dd class="func">
<p>
Alias for <a class="fref" href="#Monad._return">Monad.return</a></p>
</dd>
</dl>
</dd>
<dt class="inst">
<SPAN CLASS="code"><b>instance </b><a name="Monad__lbrack_rbrack"> </a> <a class="tref" href="#Monad">Monad</a> <a class="tref" href="./PreludeBase.html#List">[]</a></SPAN></dt>
<dd class="inst">
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="Monad__lbrack_rbrack._star_gt">*&gt;</a> :: [α] -&gt; [β] -&gt; [β]</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Applicative._star_gt">Applicative.*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad__lbrack_rbrack._lt_star">&lt;*</a> :: [α] -&gt; [β] -&gt; [α]</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Applicative._lt_star">Applicative.&lt;*</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad__lbrack_rbrack._lt_star_gt">&lt;*&gt;</a> :: [α-&gt;β] -&gt; [α] -&gt; [β]</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad._lt_star_gt">Monad.&lt;*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad__lbrack_rbrack._gt_gt">&gt;&gt;</a> :: <b>[α]</b> -&gt; [β] -&gt; [β]</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad._gt_gt">Monad.&gt;&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad__lbrack_rbrack._gt_gt_eq">&gt;&gt;=</a> :: <b>[α]</b> -&gt; (α -&gt; [β]) -&gt; [β]</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad__lbrack_rbrack.join">join</a> :: <b>[[α]]</b> -&gt; [α]</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad.join">Monad.join</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad__lbrack_rbrack.pure">pure</a> :: <b>α</b> -&gt; [α]</SPAN></dt>
<dd class="func">
<p>
inherited from <a class="fref" href="#Monad.pure">Monad.pure</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Monad__lbrack_rbrack._return">return</a> :: α -&gt; [α]</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
</dl>
<h2>
<a name="let">Functions and Values</a></h2>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="_lt$_gt">&lt;$&gt;</a> :: <a class="tref" href="#Functor">Functor</a> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</SPAN></dt>
<dd class="func">
<p>
An infix synonym for <a class="fref" href="#Functor.fmap">Functor.fmap</a>. Left associative with precedence 4.   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="_lt_eq_lt">&lt;=&lt;</a> :: <a class="tref" href="#Bind">Bind</a> β =&gt; (δ-&gt;β α) -&gt; (γ-&gt;β δ) -&gt; γ -&gt; β α</SPAN></dt>
<dd class="func">
<p>
Right-to-left Kleisli composition of monads. (<a class="fref" href="#_gt_eq_gt">&gt;=&gt;</a>), with the arguments flipped   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="_eq_lt_lt">=&lt;&lt;</a> :: <a class="tref" href="#Bind">Bind</a> α =&gt; (γ-&gt;α β) -&gt; α γ -&gt; α β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#_eq_lt_lt">=&lt;&lt;</a> is the same as <a class="fref" href="#Bind._gt_gt_eq">Bind.&gt;&gt;=</a> with the arguments flipped       </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="_gt_eq_gt">&gt;=&gt;</a> :: <a class="tref" href="#Bind">Bind</a> β =&gt; (α-&gt;β δ) -&gt; (δ-&gt;β γ) -&gt; α -&gt; β γ</SPAN></dt>
<dd class="func">
<p>
left to right Kleisli composition of monads   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="ap">ap</a> :: <a class="tref" href="#Monad">Monad</a> α =&gt; α (γ-&gt;β) -&gt; α γ -&gt; α β</SPAN></dt>
<dd class="func">
<p>
In many situations, the <a class="fref" href="#liftM">liftM</a> operations can be replaced by uses of <a class="fref" href="#ap">ap</a>, which promotes function application.</p>
<PRE>
       return f `ap` x1 `ap` ... `ap` xn</PRE>
<p>
is equivalent to</p>
<PRE>
       liftMn f x1 x2 ... xn</PRE>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="apply">apply</a> :: <a class="tref" href="#Apply">Apply</a> p =&gt; p (a-&gt;b) -&gt; p a -&gt; p b</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="filterM">filterM</a> :: (<a class="tref" href="./PreludeList.html#ListSource">ListSource</a> γ, <a class="tref" href="#Monad">Monad</a> β) =&gt; (α-&gt;β <a class="tref" href="./PreludeBase.html#Bool">Bool</a>) -&gt; γ α -&gt; β [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#filterM">filterM</a> generalizes the list-based <a class="fref" href="./PreludeList.html#filter">filter</a> function.   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="foldM">foldM</a> :: <a class="tref" href="#Monad">Monad</a> α =&gt; (β-&gt;γ-&gt;α β) -&gt; β -&gt; <b>[γ]</b> -&gt; α β</SPAN></dt>
<dd class="func">
<p>
<SPAN CLASS="code">foldM f a xs</SPAN> folds a monadic function <SPAN CLASS="code">f</SPAN> over the list <SPAN CLASS="code">xs</SPAN>.   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="foldM_">foldM_</a> :: <a class="tref" href="#Monad">Monad</a> α =&gt; (β-&gt;γ-&gt;α β) -&gt; β -&gt; [γ] -&gt; α <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<SPAN CLASS="code">foldM_</SPAN> is the same as <a class="fref" href="#foldM">foldM</a>, but discards the result   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="forM">forM</a> :: <a class="tref" href="#Monad">Monad</a> β =&gt; [γ] -&gt; (γ-&gt;β α) -&gt; β [α]</SPAN></dt>
<dd class="func">
<p>
<SPAN CLASS="code">forM xs f</SPAN> = <SPAN CLASS="code">mapM_ f xs</SPAN>    </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="forM_">forM_</a> :: <a class="tref" href="#Monad">Monad</a> β =&gt; [γ] -&gt; (γ-&gt;β α) -&gt; β <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="forever">forever</a> :: <a class="tref" href="#Monad">Monad</a> γ =&gt; γ α -&gt; γ β</SPAN></dt>
<dd class="func">
<p>
nowarn: deep recursion possible</p>
<p>
repeat action forever   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="guard">guard</a> :: <a class="tref" href="#MonadZero">MonadZero</a> α =&gt; <b><a class="tref" href="./PreludeBase.html#Bool">Bool</a></b> -&gt; <a class="tref" href="#MonadZero">MonadZero</a> α =&gt; α <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<SPAN CLASS="code">guard b</SPAN> is <SPAN CLASS="code">return ()</SPAN> if <SPAN CLASS="code">b</SPAN> is <b><SPAN CLASS="code">true</SPAN></b>, and <a class="fref" href="#MonadZero.mzero">MonadZero.mzero</a> otherwise.   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="liftA">liftA</a> :: <a class="tref" href="#Applicative">Applicative</a> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="liftA2">liftA2</a> :: <a class="tref" href="#Applicative">Applicative</a> f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="liftA3">liftA3</a> :: <a class="tref" href="#Applicative">Applicative</a> f =&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; f a -&gt; f b -&gt; f c -&gt; f d</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="liftA4">liftA4</a> :: <a class="tref" href="#Applicative">Applicative</a> f =&gt; (a -&gt; b -&gt; c -&gt; d -&gt; e) -&gt; f a -&gt; f b -&gt; f c -&gt; f d -&gt; f e</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="liftA5">liftA5</a> :: <a class="tref" href="#Applicative">Applicative</a> f =&gt; (a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; g) -&gt; f a -&gt; f b -&gt; f c -&gt; f d -&gt; f e -&gt; f g</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="liftM">liftM</a> :: <a class="tref" href="#Monad">Monad</a> m =&gt; (a -&gt; b) -&gt; m a -&gt; m b</SPAN></dt>
<dd class="func">
<p>
Promote a function to a monad.   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="liftM2">liftM2</a> :: <a class="tref" href="#Monad">Monad</a> γ =&gt; (α-&gt;δ-&gt;β) -&gt; γ α -&gt; γ δ -&gt; γ β</SPAN></dt>
<dd class="func">
<p>
Promote a function to a monad, scanning the monadic arguments from left to right.  For example,</p>
<PRE>
    liftM2 (+) [0,1] [0,2] = [0,2,1,3]</PRE>
<PRE>
    liftM2 (+) (Just 1) Nothing = Nothing   </PRE>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="liftM3">liftM3</a> :: <a class="tref" href="#Monad">Monad</a> β =&gt; (δ-&gt;α-&gt;ε-&gt;γ) -&gt; β δ -&gt; β α -&gt; β ε -&gt; β γ</SPAN></dt>
<dd class="func">
<p>
Promote a function to a monad, scanning the monadic arguments from left to right (cf. <a class="fref" href="#liftM2">liftM2</a>).   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="liftM4">liftM4</a> :: <a class="tref" href="#Monad">Monad</a> β =&gt; (δ-&gt;α-&gt;ε-&gt;ζ-&gt;γ) -&gt; β δ -&gt; β α -&gt; β ε -&gt; β ζ -&gt; β γ</SPAN></dt>
<dd class="func">
<p>
Promote a function to a monad, scanning the monadic arguments from left to right (cf. <a class="fref" href="#liftM2">liftM2</a>).   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="liftM5">liftM5</a> :: <a class="tref" href="#Monad">Monad</a> β =&gt; (δ-&gt;α-&gt;ζ-&gt;ε-&gt;η-&gt;γ) -&gt; β δ -&gt; β α -&gt; β ζ -&gt; β ε -&gt; β η -&gt; β γ</SPAN></dt>
<dd class="func">
<p>
Promote a function to a monad, scanning the monadic arguments from left to right (cf. <a class="fref" href="#liftM2">liftM2</a>).   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="mapAndUnzipM">mapAndUnzipM</a> :: <a class="tref" href="#Monad">Monad</a> β =&gt; (α-&gt;β (γ, δ)) -&gt; [α] -&gt; β ([γ], [δ])</SPAN></dt>
<dd class="func">
<p>
The <a class="fref" href="#mapAndUnzipM">mapAndUnzipM</a> function maps its first argument over a list, returning the result as a pair of lists. This function is mainly used with complicated data structures or a state-transforming monad.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="mapM">mapM</a> :: <a class="tref" href="#Monad">Monad</a> β =&gt; (γ-&gt;β α) -&gt; [γ] -&gt; β [α]</SPAN></dt>
<dd class="func">
<p>
<SPAN CLASS="code">mapM f</SPAN> is equivalent to <SPAN CLASS="code">sequence • map f</SPAN>   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="mapM_">mapM_</a> :: <a class="tref" href="#Monad">Monad</a> β =&gt; (γ-&gt;β α) -&gt; [γ] -&gt; β <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<SPAN CLASS="code">mapM_ f</SPAN> is equivalent to <SPAN CLASS="code">sequence_ • map f</SPAN>   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="mapReader">mapReader</a> :: (<b>a -&gt; b</b>) -&gt; (r -&gt; a) -&gt; r -&gt; b</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="msum">msum</a> :: <a class="tref" href="#MonadPlus">MonadPlus</a> α =&gt; <b>[α β]</b> -&gt; α β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#msum">msum</a> generalizes the list-based <a class="fref" href="./PreludeList.html#concat">concat</a> function.   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="replicateM">replicateM</a> :: <a class="tref" href="#Monad">Monad</a> m =&gt; <a class="tref" href="./PreludeBase.html#Int">Int</a> -&gt; m a -&gt; m [a]</SPAN></dt>
<dd class="func">
<p>
<SPAN CLASS="code">replicateM n act</SPAN> performs the action <SPAN CLASS="code">n</SPAN> times, gathering the results.   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="replicateM_">replicateM_</a> :: <a class="tref" href="#Monad">Monad</a> m =&gt; <a class="tref" href="./PreludeBase.html#Int">Int</a> -&gt; m a -&gt; m <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
Like <a class="fref" href="#replicateM">replicateM</a>, but discards the result.   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="runReader">runReader</a> :: (<b>r -&gt; a</b>) -&gt; r -&gt; a</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="sequence">sequence</a> :: (<a class="tref" href="./PreludeList.html#ListSource">ListSource</a> γ, <a class="tref" href="#Monad">Monad</a> β) =&gt; γ (β α) -&gt; β [α]</SPAN></dt>
<dd class="func">
<p>
Turn a list of monadic values <SPAN CLASS="code">[m a]</SPAN> into a monadic value with a list <SPAN CLASS="code">m [a]</SPAN></p>
<PRE>
 sequence [Just 1, Just 3, Just 2] = Just [1,2,3]</PRE>
<p>
This version of <a class="fref" href="#sequence">sequence</a> runs in constant stack space, but needs heap space proportional to the size of the input list.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="sequence_">sequence_</a> :: (<a class="tref" href="./PreludeList.html#ListSource">ListSource</a> γ, <a class="tref" href="#Monad">Monad</a> β) =&gt; γ (β α) -&gt; β <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
foldr (<a class="fref" href="#Monad._gt_gt">Monad.&gt;&gt;</a>) over a list of monadic values for side effects      </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="unless">unless</a> :: <a class="tref" href="#Monad">Monad</a> α =&gt; <b><a class="tref" href="./PreludeBase.html#Bool">Bool</a></b> -&gt; α <a class="tref" href="./PreludeBase.html#Unit">()</a> -&gt; α <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
opposite of <a class="fref" href="#when">when</a>      </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="_void">void</a> :: <a class="tref" href="#Functor">Functor</a> α =&gt; α β -&gt; α <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
discard or ignore result of evaluation, such as the return value of an <a class="tref" href="./PreludeBase.html#IO">IO</a> action.   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="when">when</a> :: <a class="tref" href="#Monad">Monad</a> α =&gt; <b><a class="tref" href="./PreludeBase.html#Bool">Bool</a></b> -&gt; α <a class="tref" href="./PreludeBase.html#Unit">()</a> -&gt; α <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<SPAN CLASS="code">when condition monadic</SPAN> returns /action/ of type <SPAN CLASS="code">Monad m =&gt; m ()</SPAN> if /condition/ is true, otherwise <a class="fref" href="#Monad._return">Monad.return</a> <a class="tref" href="./PreludeBase.html#Unit">()</a>.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="withReader">withReader</a> :: (e -&gt; r) -&gt; (<b>r -&gt; a</b>) -&gt; e -&gt; a</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="zipWithM">zipWithM</a> :: <a class="tref" href="#Monad">Monad</a> β =&gt; (α-&gt;δ-&gt;β γ) -&gt; [α] -&gt; [δ] -&gt; β [γ]</SPAN></dt>
<dd class="func">
<p>
The <a class="fref" href="#zipWithM">zipWithM</a> function generalizes <a class="fref" href="./PreludeList.html#zipWith">zipWith</a> to arbitrary monads.   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="zipWithM_">zipWithM_</a> :: <a class="tref" href="#Monad">Monad</a> β =&gt; (α-&gt;δ-&gt;β γ) -&gt; [α] -&gt; [δ] -&gt; β <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#zipWithM_">zipWithM_</a> is the extension of <a class="fref" href="#zipWithM">zipWithM</a> which ignores the final result.   </p>
</dd>
</dl>
<h2>
<a name="case">Functions and Values by Type</a></h2>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="./PreludeBase.html#String">String</a> -&gt; (<a class="tref" href="./PreludeBase.html#String">String</a> | α)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadFail_Either.fail">MonadFail_Either.fail</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="./PreludeBase.html#String">String</a> -&gt; [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadFail__lbrack_rbrack.fail">MonadFail_[].fail</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">[[α]] -&gt; [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad__lbrack_rbrack.join">Monad_[].join</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">[α] -&gt; [α] -&gt; [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadPlus__lbrack_rbrack.mplus">MonadPlus_[].mplus</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">α -&gt; [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad__lbrack_rbrack._return">Monad_[].return</a>, <a class="fref" href="#Monad__lbrack_rbrack.pure">Monad_[].pure</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> α =&gt; <a class="tref" href="./PreludeBase.html#Bool">Bool</a> -&gt; α <a class="tref" href="./PreludeBase.html#Unit">()</a> -&gt; α <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#unless">unless</a>, <a class="fref" href="#when">when</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#MonadZero">MonadZero</a> α =&gt; <a class="tref" href="./PreludeBase.html#Bool">Bool</a> -&gt; <a class="tref" href="#MonadZero">MonadZero</a> α =&gt; α <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#guard">guard</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">[α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadPlus__lbrack_rbrack.mzero">MonadPlus_[].mzero</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(r -&gt; a) -&gt; r -&gt; a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#runReader">runReader</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(α -&gt; β) -&gt; [α] -&gt; [β]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Functor__lbrack_rbrack.fmap">Functor_[].fmap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(α-&gt;α-&gt;β) -&gt; α -&gt; β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad__minus_gt.join">Monad_-&gt;.join</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(α | (α | β)) -&gt; (α | β)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_Either.join">Monad_Either.join</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="./PreludeBase.html#ST">ST</a> α (<a class="tref" href="./PreludeBase.html#ST">ST</a> α β) -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> α β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_ST.join">Monad_ST.join</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">[α-&gt;β] -&gt; [α] -&gt; [β]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad__lbrack_rbrack._lt_star_gt">Monad_[].&lt;*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">[α] -&gt; (α -&gt; [β]) -&gt; [β]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad__lbrack_rbrack._gt_gt_eq">Monad_[].&gt;&gt;=</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">[α] -&gt; [β] -&gt; [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad__lbrack_rbrack._lt_star">Monad_[].&lt;*</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">[α] -&gt; [β] -&gt; [β]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad__lbrack_rbrack._gt_gt">Monad_[].&gt;&gt;</a>, <a class="fref" href="#Monad__lbrack_rbrack._star_gt">Monad_[].*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">α -&gt; β -&gt; α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Applicative__minus_gt.pure">Applicative_-&gt;.pure</a>, <a class="fref" href="#Monad__minus_gt._return">Monad_-&gt;.return</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">α -&gt; (β | α)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_Either.pure">Monad_Either.pure</a>, <a class="fref" href="#Monad_Either._return">Monad_Either.return</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">α -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> β α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_ST.pure">Monad_ST.pure</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Alt">Alt</a> f =&gt; f a -&gt; f a -&gt; f a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Alt._lt_bar_gt">Alt.&lt;|&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Applicative">Applicative</a> p =&gt; a -&gt; p a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Applicative.pure">Applicative.pure</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Functor">Functor</a> α =&gt; α β -&gt; α <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#_void">void</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> m =&gt; m (m a) -&gt; m a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad.join">Monad.join</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> m =&gt; <a class="tref" href="./PreludeBase.html#Int">Int</a> -&gt; m a -&gt; m [a]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#replicateM">replicateM</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> m =&gt; <a class="tref" href="./PreludeBase.html#Int">Int</a> -&gt; m a -&gt; m <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#replicateM_">replicateM_</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> m =&gt; a -&gt; m a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad._return">Monad.return</a>, <a class="fref" href="#Monad.pure">Monad.pure</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#MonadAlt">MonadAlt</a> f =&gt; f a -&gt; f a -&gt; f a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadAlt._lt_plus_gt">MonadAlt.&lt;+&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#MonadFail">MonadFail</a> m =&gt; <a class="tref" href="./PreludeBase.html#String">String</a> -&gt; m a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadFail.fail">MonadFail.fail</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#MonadOr">MonadOr</a> mo =&gt; mo a -&gt; mo a -&gt; mo a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadOr.orElse">MonadOr.orElse</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#MonadPlus">MonadPlus</a> mp =&gt; mp a -&gt; mp a -&gt; mp a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadPlus.mplus">MonadPlus.mplus</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#MonadPlus">MonadPlus</a> α =&gt; [α β] -&gt; α β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#msum">msum</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#MonadZero">MonadZero</a> mz =&gt; mz a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#MonadZero.mzero">MonadZero.mzero</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Plus">Plus</a> f =&gt; f a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Plus.pzero">Plus.pzero</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(a -&gt; b) -&gt; (r -&gt; a) -&gt; r -&gt; b</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#mapReader">mapReader</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(e -&gt; r) -&gt; (r -&gt; a) -&gt; e -&gt; a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#withReader">withReader</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(γ -&gt; α) -&gt; (β, γ) -&gt; (β, α)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Functor_l_c_r.fmap">Functor_(,).fmap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(γ -&gt; α) -&gt; (β-&gt;γ) -&gt; β -&gt; α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Applicative__minus_gt.fmap">Applicative_-&gt;.fmap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(γ -&gt; α) -&gt; (β | γ) -&gt; (β | α)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_Either.fmap">Monad_Either.fmap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(γ -&gt; α) -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> β γ -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> β α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_ST.fmap">Monad_ST.fmap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(β-&gt;γ-&gt;α) -&gt; (β-&gt;γ) -&gt; β -&gt; α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Applicative__minus_gt._lt_star_gt">Applicative_-&gt;.&lt;*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(β-&gt;γ) -&gt; (γ -&gt; β-&gt;α) -&gt; β -&gt; α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad__minus_gt._gt_gt_eq">Monad_-&gt;.&gt;&gt;=</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(β-&gt;γ) -&gt; (β-&gt;α) -&gt; β -&gt; α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Applicative__minus_gt._star_gt">Applicative_-&gt;.*&gt;</a>, <a class="fref" href="#Monad__minus_gt._gt_gt">Monad_-&gt;.&gt;&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(β-&gt;γ) -&gt; (β-&gt;α) -&gt; β -&gt; γ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Applicative__minus_gt._lt_star">Applicative_-&gt;.&lt;*</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(β | γ-&gt;α) -&gt; (β | γ) -&gt; (β | α)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_Either._lt_star_gt">Monad_Either.&lt;*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(β | γ) -&gt; (γ -&gt; (β | α)) -&gt; (β | α)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_Either._gt_gt_eq">Monad_Either.&gt;&gt;=</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(β | γ) -&gt; (β | α) -&gt; (β | α)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_Either._gt_gt">Monad_Either.&gt;&gt;</a>, <a class="fref" href="#Monad_Either._star_gt">Monad_Either.*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(β | γ) -&gt; (β | α) -&gt; (β | γ)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_Either._lt_star">Monad_Either.&lt;*</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="./PreludeBase.html#ST">ST</a> β (γ-&gt;α) -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> β γ -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> β α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_ST._lt_star_gt">Monad_ST.&lt;*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="./PreludeBase.html#ST">ST</a> β γ -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> β α -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> β α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_ST._gt_gt">Monad_ST.&gt;&gt;</a>, <a class="fref" href="#Monad_ST._star_gt">Monad_ST.*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="./PreludeBase.html#ST">ST</a> β γ -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> β α -&gt; <a class="tref" href="./PreludeBase.html#ST">ST</a> β γ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad_ST._lt_star">Monad_ST.&lt;*</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(<a class="tref" href="./PreludeList.html#ListSource">ListSource</a> γ, <a class="tref" href="#Monad">Monad</a> β) =&gt; (α-&gt;β <a class="tref" href="./PreludeBase.html#Bool">Bool</a>) -&gt; γ α -&gt; β [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#filterM">filterM</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(<a class="tref" href="./PreludeList.html#ListSource">ListSource</a> γ, <a class="tref" href="#Monad">Monad</a> β) =&gt; γ (β α) -&gt; β [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#sequence">sequence</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(<a class="tref" href="./PreludeList.html#ListSource">ListSource</a> γ, <a class="tref" href="#Monad">Monad</a> β) =&gt; γ (β α) -&gt; β <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#sequence_">sequence_</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Applicative">Applicative</a> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#liftA">liftA</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Applicative">Applicative</a> p =&gt; p a -&gt; p b -&gt; p a</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Applicative._lt_star">Applicative.&lt;*</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Applicative">Applicative</a> p =&gt; p a -&gt; p b -&gt; p b</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Applicative._star_gt">Applicative.*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Apply">Apply</a> f =&gt; f (a-&gt;b) -&gt; f a -&gt; f b</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Apply._lt_star_gt">Apply.&lt;*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Apply">Apply</a> p =&gt; p (a-&gt;b) -&gt; p a -&gt; p b</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#apply">apply</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Bind">Bind</a> f =&gt; f a -&gt; (a -&gt; f b) -&gt; f b</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Bind._gt_gt_eq">Bind.&gt;&gt;=</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Bind">Bind</a> α =&gt; (γ-&gt;α β) -&gt; α γ -&gt; α β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#_eq_lt_lt">=&lt;&lt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Functor">Functor</a> f =&gt; (a -&gt; b) -&gt; f a -&gt; f b</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#_lt$_gt">&lt;$&gt;</a>, <a class="fref" href="#Functor.fmap">Functor.fmap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> m =&gt; (a -&gt; b) -&gt; m a -&gt; m b</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#liftM">liftM</a>, <a class="fref" href="#Monad.fmap">Monad.fmap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> m =&gt; m (a-&gt;b) -&gt; m a -&gt; m b</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad._lt_star_gt">Monad.&lt;*&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> m =&gt; m a -&gt; m b -&gt; m b</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Monad._gt_gt">Monad.&gt;&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> α =&gt; (β-&gt;γ-&gt;α β) -&gt; β -&gt; [γ] -&gt; α <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#foldM_">foldM_</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> α =&gt; (β-&gt;γ-&gt;α β) -&gt; β -&gt; [γ] -&gt; α β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#foldM">foldM</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> α =&gt; α (γ-&gt;β) -&gt; α γ -&gt; α β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#ap">ap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> β =&gt; (γ-&gt;β α) -&gt; [γ] -&gt; β [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#mapM">mapM</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> β =&gt; (γ-&gt;β α) -&gt; [γ] -&gt; β <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#mapM_">mapM_</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> β =&gt; [γ] -&gt; (γ-&gt;β α) -&gt; β [α]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#forM">forM</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> β =&gt; [γ] -&gt; (γ-&gt;β α) -&gt; β <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#forM_">forM_</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> γ =&gt; γ α -&gt; γ β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#forever">forever</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code">(δ -&gt; α) -&gt; (γ, β, δ) -&gt; (γ, β, α)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Functor_l_cc_r.fmap">Functor_(,,).fmap</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Applicative">Applicative</a> f =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#liftA2">liftA2</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Bind">Bind</a> β =&gt; (α-&gt;β δ) -&gt; (δ-&gt;β γ) -&gt; α -&gt; β γ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#_gt_eq_gt">&gt;=&gt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Bind">Bind</a> β =&gt; (δ-&gt;β α) -&gt; (γ-&gt;β δ) -&gt; γ -&gt; β α</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#_lt_eq_lt">&lt;=&lt;</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> β =&gt; (α-&gt;δ-&gt;β γ) -&gt; [α] -&gt; [δ] -&gt; β [γ]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#zipWithM">zipWithM</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> β =&gt; (α-&gt;δ-&gt;β γ) -&gt; [α] -&gt; [δ] -&gt; β <a class="tref" href="./PreludeBase.html#Unit">()</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#zipWithM_">zipWithM_</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> β =&gt; (α-&gt;β (γ, δ)) -&gt; [α] -&gt; β ([γ], [δ])</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#mapAndUnzipM">mapAndUnzipM</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> γ =&gt; (α-&gt;δ-&gt;β) -&gt; γ α -&gt; γ δ -&gt; γ β</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#liftM2">liftM2</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Applicative">Applicative</a> f =&gt; (a -&gt; b -&gt; c -&gt; d) -&gt; f a -&gt; f b -&gt; f c -&gt; f d</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#liftA3">liftA3</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> β =&gt; (δ-&gt;α-&gt;ε-&gt;γ) -&gt; β δ -&gt; β α -&gt; β ε -&gt; β γ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#liftM3">liftM3</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Applicative">Applicative</a> f =&gt; (a -&gt; b -&gt; c -&gt; d -&gt; e) -&gt; f a -&gt; f b -&gt; f c -&gt; f d -&gt; f e</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#liftA4">liftA4</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> β =&gt; (δ-&gt;α-&gt;ε-&gt;ζ-&gt;γ) -&gt; β δ -&gt; β α -&gt; β ε -&gt; β ζ -&gt; β γ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#liftM4">liftM4</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Applicative">Applicative</a> f =&gt; (a -&gt; b -&gt; c -&gt; d -&gt; e -&gt; g) -&gt; f a -&gt; f b -&gt; f c -&gt; f d -&gt; f e -&gt; f g</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#liftA5">liftA5</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Monad">Monad</a> β =&gt; (δ-&gt;α-&gt;ζ-&gt;ε-&gt;η-&gt;γ) -&gt; β δ -&gt; β α -&gt; β ζ -&gt; β ε -&gt; β η -&gt; β γ</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#liftM5">liftM5</a></p>
</dd>
</dl>
<p>
<a HREF="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" height="31" width="88"></a></p>
</BODY>
</HTML>
