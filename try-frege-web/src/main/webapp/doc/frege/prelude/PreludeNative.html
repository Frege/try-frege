<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<HTML>
<META http-equiv="Content-Type" content="text/html;charset=utf-8">
<TITLE>frege.prelude.PreludeNative - frege documentation</TITLE>
<style TYPE="text/css">
body { font-family: helvetica, arial, sans-serif }
pre { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(0%,0%,60%) }
h3  { font-weight: lighter }
dt.func { background: rgb(95%, 95%, 80%); margin-top: 10px }
dt.clas { background: rgb(80%, 95%, 95%); margin-top: 10px }
dt.inst { background: rgb(95%, 90%, 95%); margin-top: 10px }
dt.data { background: rgb(95%, 95%, 95%); margin-top: 10px }
span.code { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(0%,0%,60%) }
span.unknown { font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: red }
a.fref { text-decoration: none; font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(30%, 30%, 0%) }
a.tref { text-decoration: none; font-family: "lucida console", "courier new", monospaced; font-size: 100%; color: rgb(40%, 0%,  40%) }
</style>
<BODY>
<h1>
<a name="package">Package <SPAN CLASS="code">frege.prelude.PreludeNative</SPAN></a></h1>
<p>
Compiled: Mon Nov 18 01:41:21 CET 2013 from source file: <SPAN CLASS="code">frege/prelude/PreludeNative.fr</SPAN></p>
<h3>
Package Documentation</h3>
<p>
Native types we need in the prelude</p>
<h3>
Table of Content</h3>
<ul>
<li>
<div>
<a HREF="#data">Data Types</a></div>
<div>
<a class="tref" href="#Matcher">Matcher</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a>&nbsp;&nbsp;&nbsp; <a class="tref" href="#Regex">Regex</a></div>
</li>
<li>
<div>
<a HREF="#let">Functions and Values (alphabetically)</a></div>
<div>
<a class="fref" href="#_excl_tilde">!~</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#_div_tilde">/~</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#_eq_tilde">=~</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#_qm_tilde">?~</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#regcomp">regcomp</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#regforce">regforce</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#_tilde">~</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#_tilde_tilde">~~</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#_tilde_tilde_tilde">~~~</a></div>
</li>
<li>
<div>
<a HREF="#case">Functions and Values (by type)</a></div>
<div>
<a class="fref" href="#_excl_tilde">!~</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#_div_tilde">/~</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#_eq_tilde">=~</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#_qm_tilde">?~</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#regcomp">regcomp</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#regforce">regforce</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#_tilde">~</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#_tilde_tilde">~~</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#_tilde_tilde_tilde">~~~</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Matcher.replaceAll">Matcher.replaceAll</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Matcher.find">Matcher.find</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Matcher.clone">Matcher.clone</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Matcher.end">Matcher.end</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Matcher.match">Matcher.match</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Matcher.group">Matcher.group</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Matcher.matches">Matcher.matches</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Matcher.useAnchoringBounds">Matcher.useAnchoringBounds</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Matcher.start">Matcher.start</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Matcher.replaceFirst">Matcher.replaceFirst</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Matcher.toString">Matcher.toString</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Matcher.usePattern">Matcher.usePattern</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Matcher.usePatternAndFind">Matcher.usePatternAndFind</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Regex.pattern">Regex.pattern</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Regex.matcher">Regex.matcher</a>&nbsp;&nbsp;&nbsp; <a class="fref" href="#Regex.splitted">Regex.splitted</a></div>
</li>
</ul>
<h3>
Imports</h3>
<ul>
<li>
<div>
import <a HREF="./PreludeBase.html">frege.prelude.PreludeBase</a> as PreludeBase</div>
</li>
</ul>
<h2>
<a name="data">Data Types</a></h2>
<dl class="data">
<dt class="data">
<SPAN CLASS="code"><b>data </b><a name="Matcher"> </a> <a class="tref" href="#Matcher">Matcher</a> = <b>pure </b><b>native </b>java.util.regex.Matcher</SPAN></dt>
<dd class="data">
<p>
<a class="tref" href="#Matcher">Matcher</a> values are based on Java's <SPAN CLASS="code">java.util.regex.Matcher</SPAN> objects. Code generation relies on the existence of this type and its operations.</p>
<p>
The native <a class="tref" href="#Matcher">Matcher</a> functions that correspond to java methods of the <SPAN CLASS="code">java.util.regex.Matcher</SPAN> class that modify the state of the object they are invoked on (<a class="fref" href="#Matcher.find">Matcher.find</a>, <a class="fref" href="#Matcher.matches">Matcher.matches</a>, <a class="fref" href="#Matcher.replaceFirst">Matcher.replaceFirst</a>, <a class="fref" href="#Matcher.replaceAll">Matcher.replaceAll</a>, <a class="fref" href="#Matcher.usePattern">Matcher.usePattern</a>, <a class="fref" href="#Matcher.useAnchoringBounds">Matcher.useAnchoringBounds</a>) are implemented so that they make a copy of the <a class="tref" href="#Matcher">Matcher</a> and invoke the impure java method on the copy.</p>
<p>
Frege <a class="tref" href="#Matcher">Matcher</a>s can thus be regarded as read-only values and the functions defined here as pure. If you need to pass a <a class="tref" href="#Matcher">Matcher</a> to other native functions, be sure that the function is pure. If it is not because it would modify the matcher, and you do not need the match result, always pass a clone of the Matcher (see <a class="fref" href="#Matcher.clone">Matcher.clone</a>)</p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="Matcher.clone">clone</a> :: <b><a class="tref" href="#Matcher">Matcher</a></b> -&gt; <a class="tref" href="#Matcher">Matcher</a><br><b>pure </b><b>native </b>frege.runtime.Regex.clone</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Matcher.end">end</a> :: <b><a class="tref" href="#Matcher">Matcher</a></b> -&gt; <b><a class="tref" href="./PreludeBase.html#Int">Int</a></b> -&gt; <a class="tref" href="./PreludeBase.html#Int">Int</a><br><b>pure </b><b>native </b>end</SPAN></dt>
<dd class="func">
<p>
Returns the offset after the last character of the subsequence captured by the given group during the previous match operation where group 0 denotes the entire pattern.</p>
<p>
If the specified capturing group failed to match, the return value will be -1.</p>
<p>
The follwoing property holds:</p>
<PRE>
 (m.group n == Nothing) ==&gt; (m.end n &lt; 0)</PRE>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Matcher.find">find</a> :: <b><a class="tref" href="#Matcher">Matcher</a></b> -&gt; <a class="tref" href="./PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="#Matcher">Matcher</a><br><b>pure </b><b>native </b>frege.runtime.Regex.find</SPAN></dt>
<dd class="func">
<p>
Tries a match and if it succeeds, returns <SPAN CLASS="code">Just m</SPAN>, where <SPAN CLASS="code">m</SPAN> is a new <a class="tref" href="#Matcher">Matcher</a> that contains the result. If there is no match, <SPAN CLASS="code">Nothing</SPAN> is returned.</p>
<p>
The following java fragment appends all matched substrings of a string:</p>
<PRE>
 String s = "cats and dogs are not concatenated.";
 Pattern p = Pattern.compile("cat|dog");
 String result = "";
 Matcher m = p.matcher(s);
 while (m.find()) result += m.group(0);  // "catdogcat"</PRE>
<p>
The follwoing frege fragment computes the same result:</p>
<PRE>
 result = loop m "" where
      s = "cats and dogs are not concatenated."
      p = #cat|dog#
      m = p.matcher s
      loop :: Matcher -&gt; String -&gt; String
      loop m1 r | Just m2 &lt;- m1.find = loop m2 (r++m2.match)
                | otherwise = r</PRE>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Matcher.group">group</a> :: <b><a class="tref" href="#Matcher">Matcher</a></b> -&gt; <b><a class="tref" href="./PreludeBase.html#Int">Int</a></b> -&gt; <a class="tref" href="./PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="./PreludeBase.html#String">String</a><br><b>pure </b><b>native </b>group</SPAN></dt>
<dd class="func">
<p>
Retrieves the input subsequence captured by the given group during the previous match operation.</p>
<p>
Capturing groups are indexed from left to right, starting at one. Group zero denotes the entire pattern, so the expression <SPAN CLASS="code">(m.group 0)</SPAN> retrieves that portion of the input string that was matched by the pattern.</p>
<p>
If the match was successful but the group specified failed to match any part of the input sequence, then <a class="fref" href="./PreludeBase.html#Maybe.Nothing">Maybe.Nothing</a> is returned. Note that some groups, for example <SPAN CLASS="code">(a?)</SPAN>, match the empty string. This functon will return <SPAN CLASS="code">Just ""</SPAN> when such a group successfully matches the empty string in the input.</p>
<p>
The folloing property holds for a <a class="tref" href="#Matcher">Matcher</a> /m/ with input sequence /s/ and group index /g/:</p>
<PRE>
 isJust (m.group g) ==&gt; (m.group g) == Just (s.substr (m.start g) (m.end g))</PRE>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Matcher.match">match</a> :: <b><a class="tref" href="#Matcher">Matcher</a></b> -&gt; <a class="tref" href="./PreludeBase.html#String">String</a><br><b>pure </b><b>native </b>group</SPAN></dt>
<dd class="func">
<p>
<SPAN CLASS="code">Matcher.match m</SPAN> returns the input subsequence matched by the previous match. The result is <a class="fref" href="./PreludeBase.html#undefined">undefined</a> if the last match was not successful.</p>
<p>
For a <a class="tref" href="#Matcher">Matcher</a> <SPAN CLASS="code">m</SPAN> with input sequence <SPAN CLASS="code">s</SPAN>, the following holds:</p>
<PRE>
 isJust (m.group 0) ==&gt; unJust (m.group 0) == m.match</PRE>
<p>
Note that some patterns, for example <SPAN CLASS="code">a?</SPAN>, match the empty string. This method will return the empty string when the pattern successfully matches the empty string in the input.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Matcher.matches">matches</a> :: <b><a class="tref" href="#Matcher">Matcher</a></b> -&gt; <a class="tref" href="./PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="#Matcher">Matcher</a><br><b>pure </b><b>native </b>frege.runtime.Regex.matches</SPAN></dt>
<dd class="func">
<p>
 Tries to match the entire string and returns <SPAN CLASS="code">Just m</SPAN> on success and otherwise <SPAN CLASS="code">Nothing</SPAN>.   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Matcher.replaceAll">replaceAll</a> :: <b><a class="tref" href="#Matcher">Matcher</a></b> -&gt; <b><a class="tref" href="./PreludeBase.html#String">String</a></b> -&gt; <a class="tref" href="./PreludeBase.html#String">String</a><br><b>pure </b><b>native </b>frege.runtime.Regex.replaceAll</SPAN></dt>
<dd class="func">
<p>
 Like <a class="fref" href="#Matcher.replaceFirst">Matcher.replaceFirst</a>, but replaces all matches.   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Matcher.replaceFirst">replaceFirst</a> :: <b><a class="tref" href="#Matcher">Matcher</a></b> -&gt; <b><a class="tref" href="./PreludeBase.html#String">String</a></b> -&gt; <a class="tref" href="./PreludeBase.html#String">String</a><br><b>pure </b><b>native </b>frege.runtime.Regex.replaceFirst</SPAN></dt>
<dd class="func">
<p>
Replaces the first subsequence of the input sequence that matches the pattern with the given replacement string.</p>
<p>
This method scans the input sequence from the start looking for a match of the pattern. Characters that are not part of the match are appended directly to the result string; the match is replaced in the result by the replacement string. The replacement string may contain references to captured subsequences.</p>
<p>
Note that backslashes (\\) and dollar signs ($) in the replacement string may cause the results to be different than if it were being treated as a literal replacement string. Dollar signs may be treated as references to captured subsequences as described above, and backslashes are used to escape literal characters in the replacement string.</p>
<p>
Given the regular expression <SPAN CLASS="code">#dog#</SPAN>, the input <SPAN CLASS="code">"zzzdogzzzdogzzz"</SPAN>, and the replacement string <SPAN CLASS="code">"cat"</SPAN>, an invocation of this function on a matcher for that expression would yield the string <SPAN CLASS="code">"zzzcatzzzdogzzz"</SPAN>.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Matcher.start">start</a> :: <b><a class="tref" href="#Matcher">Matcher</a></b> -&gt; <b><a class="tref" href="./PreludeBase.html#Int">Int</a></b> -&gt; <a class="tref" href="./PreludeBase.html#Int">Int</a><br><b>pure </b><b>native </b>start</SPAN></dt>
<dd class="func">
<p>
Returns the start index of the subsequence captured by the given group during the previous match operation where group 0 denotes the entire pattern.</p>
<p>
If the specified capturing group failed to match, the return value will be -1.</p>
<p>
The follwoing property holds:</p>
<PRE>
 (m.group n == Nothing) ==&gt; (m.start n &lt; 0)</PRE>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Matcher.toString">toString</a> :: <b><a class="tref" href="#Matcher">Matcher</a></b> -&gt; <a class="tref" href="./PreludeBase.html#String">String</a><br><b>pure </b><b>native </b>toString</SPAN></dt>
<dd class="func">
<p>
Returns the string representation of this matcher. The string representation of a <a class="tref" href="#Matcher">Matcher</a> contains information that may be useful for debugging. The exact format is unspecified.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Matcher.useAnchoringBounds">useAnchoringBounds</a> :: <b><a class="tref" href="#Matcher">Matcher</a></b> -&gt; <b><a class="tref" href="./PreludeBase.html#Bool">Bool</a></b> -&gt; <a class="tref" href="#Matcher">Matcher</a><br><b>pure </b><b>native </b>frege.runtime.Regex.useAnchoringBounds</SPAN></dt>
<dd class="func">
<p>
 Requires or forbids the matcher to acknowledge anchors.   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Matcher.usePattern">usePattern</a> :: <b><a class="tref" href="#Matcher">Matcher</a></b> -&gt; <b><a class="tref" href="#Regex">Regex</a></b> -&gt; <a class="tref" href="#Matcher">Matcher</a><br><b>pure </b><b>native </b>frege.runtime.Regex.usePattern</SPAN></dt>
<dd class="func">
<p>
Makes a new <a class="tref" href="#Matcher">Matcher</a> and causes it to use a different <a class="tref" href="#Regex">Regex</a> for future matches.</p>
<p>
The original matchers position in the input and its last append position is copied, but information about the last match, if any, is not.</p>
<p>
This is most useful with patterns that start with the <SPAN CLASS="code">\\G</SPAN> anchor.</p>
<p>
Note that, due to a java bug, if the last find operation matched the empty string, the next find will fail. For a workaround see <a class="fref" href="#Matcher.usePatternAndFind">Matcher.usePatternAndFind</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Matcher.usePatternAndFind">usePatternAndFind</a> :: <b><a class="tref" href="#Matcher">Matcher</a></b> -&gt; <b><a class="tref" href="#Regex">Regex</a></b> -&gt; <a class="tref" href="./PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="#Matcher">Matcher</a><br><b>pure </b><b>native </b>frege.runtime.Regex.usePatternAndFind</SPAN></dt>
<dd class="func">
<p>
Makes a new <a class="tref" href="#Matcher">Matcher</a> with a different <a class="tref" href="#Regex">Regex</a> and tries to find a match. If the last find on the original Matcher returned an empty result, it calls <SPAN CLASS="code">mnew.find(morig.end(0))</SPAN> to work around a bug in the java API. Therefore, this function must only be used on a matcher whose last match attempt was successful.</p>
</dd>
</dl>
</dd>
<dt class="data">
<SPAN CLASS="code"><b>data </b><a name="PatternSyntaxException"> </a> <a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> = <b>native </b>java.util.regex.PatternSyntaxException</SPAN></dt>
<dd class="data">
</dd>
<dt class="data">
<SPAN CLASS="code"><b>data </b><a name="Regex"> </a> <a class="tref" href="#Regex">Regex</a> = <b>pure </b><b>native </b>java.util.regex.Pattern</SPAN></dt>
<dd class="data">
<p>
<a class="tref" href="#Regex">Regex</a> values are based on Java's <SPAN CLASS="code">java.util.regex.Pattern</SPAN> objects. All regular expression literals are values of this type.</p>
<h3>
Member Functions</h3>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="Regex.matcher">matcher</a> :: <b><a class="tref" href="#Regex">Regex</a></b> -&gt; <b><a class="tref" href="./PreludeBase.html#String">String</a></b> -&gt; <a class="tref" href="#Matcher">Matcher</a><br><b>pure </b><b>native </b>matcher</SPAN></dt>
<dd class="func">
<p>
 create a <a class="tref" href="#Matcher">Matcher</a> from a regular expression and a <a class="tref" href="./PreludeBase.html#String">String</a>   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Regex.pattern">pattern</a> :: <b><a class="tref" href="#Regex">Regex</a></b> -&gt; <a class="tref" href="./PreludeBase.html#String">String</a><br><b>pure </b><b>native </b>pattern</SPAN></dt>
<dd class="func">
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="Regex.splitted">splitted</a> :: <b><a class="tref" href="#Regex">Regex</a></b> -&gt; <b><a class="tref" href="./PreludeBase.html#String">String</a></b> -&gt; [<a class="tref" href="./PreludeBase.html#String">String</a>]<br><b>pure </b><b>native </b>split</SPAN></dt>
<dd class="func">
</dd>
</dl>
</dd>
</dl>
<h2>
<a name="let">Functions and Values</a></h2>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a name="_excl_tilde">!~</a> :: <b><a class="tref" href="./PreludeBase.html#String">String</a></b> -&gt; <b><a class="tref" href="#Regex">Regex</a></b> -&gt; <a class="tref" href="./PreludeBase.html#Bool">Bool</a></SPAN></dt>
<dd class="func">
<PRE>
 s !~ p == !(s ~ p)</PRE>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="_div_tilde">/~</a> :: <b><a class="tref" href="#Matcher">Matcher</a></b> -&gt; <b><a class="tref" href="#Regex">Regex</a></b> -&gt; <a class="tref" href="./PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="./PreludeBase.html#String">String</a></SPAN></dt>
<dd class="func">
<PRE>
 m /~ p</PRE>
<p>
is like</p>
<PRE>
 m ?~ p</PRE>
<p>
but instead of the matcher it returns the matched string, if any.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="_eq_tilde">=~</a> :: <b><a class="tref" href="./PreludeBase.html#String">String</a></b> -&gt; <b><a class="tref" href="#Regex">Regex</a></b> -&gt; <a class="tref" href="./PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="#Matcher">Matcher</a></SPAN></dt>
<dd class="func">
<PRE>
 string =~ regex</PRE>
<p>
tries to match <i>string</i> against <i>regex</i> and returns <SPAN CLASS="code">Just matcher</SPAN> if it succeeds, <SPAN CLASS="code">Nothing</SPAN> otherwise.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="_qm_tilde">?~</a> :: <b><a class="tref" href="#Matcher">Matcher</a></b> -&gt; <b><a class="tref" href="#Regex">Regex</a></b> -&gt; <a class="tref" href="./PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="#Matcher">Matcher</a></SPAN></dt>
<dd class="func">
<p>
<SPAN CLASS="code">m ?~ p</SPAN> binds pattern <i>p</i> to the matcher <i>m</i> and tries a match. There must have been a successful match on <i>m</i> before.</p>
<p>
Returns <a class="fref" href="./PreludeBase.html#Maybe.Nothing">Maybe.Nothing</a> if match fails, else (<a class="fref" href="./PreludeBase.html#Maybe.Just">Maybe.Just</a> <SPAN CLASS="code">m</SPAN>).</p>
<p>
This function is most usefull in conjunction with patterns that use the G-anchor when one wants to extract multiple differnt adjacent items from a string.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="regcomp">regcomp</a> :: <b><a class="tref" href="./PreludeBase.html#String">String</a></b> -&gt; (<a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> | <a class="tref" href="#Regex">Regex</a>)<br><b>pure </b><b>native </b>java.util.regex.Pattern.compile</SPAN></dt>
<dd class="func">
<p>
 compile a <a class="tref" href="./PreludeBase.html#String">String</a> to a <a class="tref" href="#Regex">Regex</a>   </p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="regforce">regforce</a> :: <b><a class="tref" href="./PreludeBase.html#String">String</a></b> -&gt; <a class="tref" href="#Regex">Regex</a><br><b>pure </b><b>native </b>java.util.regex.Pattern.compile</SPAN></dt>
<dd class="func">
<p>
compile a <a class="tref" href="./PreludeBase.html#String">String</a> to a <a class="tref" href="#Regex">Regex</a></p>
<p>
Use this only if you're sure that pattern compilation will not throw an exception, or if you don't care.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="_tilde">~</a> :: <b><a class="tref" href="./PreludeBase.html#String">String</a></b> -&gt; <b><a class="tref" href="#Regex">Regex</a></b> -&gt; <a class="tref" href="./PreludeBase.html#Bool">Bool</a></SPAN></dt>
<dd class="func">
<PRE>
string ~ regex</PRE>
<p>
<SPAN CLASS="code">true</SPAN> if <i>string</i> matches <i>regex</i>, <SPAN CLASS="code">false</SPAN> otherwise</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="_tilde_tilde">~~</a> :: <b><a class="tref" href="./PreludeBase.html#String">String</a></b> -&gt; <b><a class="tref" href="#Regex">Regex</a></b> -&gt; <a class="tref" href="./PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="./PreludeBase.html#String">String</a></SPAN></dt>
<dd class="func">
<PRE>
 ("string" ~~ #r??#) == Just "rin"</PRE>
<p>
Tries a match and returns <SPAN CLASS="code">Just x</SPAN> where <i>x</i> is the matched substring or <SPAN CLASS="code">Nothing</SPAN> if there was no match.</p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a name="_tilde_tilde_tilde">~~~</a> :: <b><a class="tref" href="./PreludeBase.html#String">String</a></b> -&gt; <b><a class="tref" href="#Regex">Regex</a></b> -&gt; <a class="tref" href="./PreludeBase.html#Int">Int</a> -&gt; <a class="tref" href="./PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="./PreludeBase.html#String">String</a></SPAN></dt>
<dd class="func">
<PRE>
 string ~~~ regex</PRE>
<p>
Matches <i>string</i> with <i>regex</i> and returns a function that can be used to extract the matched part of the string and the captured substrings.</p>
<PRE>
   let f = "frege" ~~~ #(..).(..)#
   in [ f i | i &lt;- 0..3 ]</PRE>
<p>
yields</p>
<PRE>
[Just "frege", Just "fr", Just "ge", Nothing]</PRE>
</dd>
</dl>
<h2>
<a name="case">Functions and Values by Type</a></h2>
<dl class="func">
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="./PreludeBase.html#String">String</a> -&gt; <a class="tref" href="#Regex">Regex</a> -&gt; <a class="tref" href="./PreludeBase.html#Int">Int</a> -&gt; <a class="tref" href="./PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="./PreludeBase.html#String">String</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#_tilde_tilde_tilde">~~~</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="./PreludeBase.html#String">String</a> -&gt; <a class="tref" href="#Regex">Regex</a> -&gt; <a class="tref" href="./PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="./PreludeBase.html#String">String</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#_tilde_tilde">~~</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="./PreludeBase.html#String">String</a> -&gt; <a class="tref" href="#Regex">Regex</a> -&gt; <a class="tref" href="./PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="#Matcher">Matcher</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#_eq_tilde">=~</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="./PreludeBase.html#String">String</a> -&gt; <a class="tref" href="#Regex">Regex</a> -&gt; <a class="tref" href="./PreludeBase.html#Bool">Bool</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#_excl_tilde">!~</a>, <a class="fref" href="#_tilde">~</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="./PreludeBase.html#String">String</a> -&gt; (<a class="tref" href="#PatternSyntaxException">PatternSyntaxException</a> | <a class="tref" href="#Regex">Regex</a>)</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#regcomp">regcomp</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="./PreludeBase.html#String">String</a> -&gt; <a class="tref" href="#Regex">Regex</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#regforce">regforce</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Matcher">Matcher</a> -&gt; <a class="tref" href="./PreludeBase.html#String">String</a> -&gt; <a class="tref" href="./PreludeBase.html#String">String</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Matcher.replaceAll">Matcher.replaceAll</a>, <a class="fref" href="#Matcher.replaceFirst">Matcher.replaceFirst</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Matcher">Matcher</a> -&gt; <a class="tref" href="./PreludeBase.html#Bool">Bool</a> -&gt; <a class="tref" href="#Matcher">Matcher</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Matcher.useAnchoringBounds">Matcher.useAnchoringBounds</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Matcher">Matcher</a> -&gt; <a class="tref" href="./PreludeBase.html#Int">Int</a> -&gt; <a class="tref" href="./PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="./PreludeBase.html#String">String</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Matcher.group">Matcher.group</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Matcher">Matcher</a> -&gt; <a class="tref" href="./PreludeBase.html#Int">Int</a> -&gt; <a class="tref" href="./PreludeBase.html#Int">Int</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Matcher.end">Matcher.end</a>, <a class="fref" href="#Matcher.start">Matcher.start</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Matcher">Matcher</a> -&gt; <a class="tref" href="#Regex">Regex</a> -&gt; <a class="tref" href="./PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="./PreludeBase.html#String">String</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#_div_tilde">/~</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Matcher">Matcher</a> -&gt; <a class="tref" href="#Regex">Regex</a> -&gt; <a class="tref" href="./PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="#Matcher">Matcher</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#_qm_tilde">?~</a>, <a class="fref" href="#Matcher.usePatternAndFind">Matcher.usePatternAndFind</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Matcher">Matcher</a> -&gt; <a class="tref" href="#Regex">Regex</a> -&gt; <a class="tref" href="#Matcher">Matcher</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Matcher.usePattern">Matcher.usePattern</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Matcher">Matcher</a> -&gt; <a class="tref" href="./PreludeBase.html#Maybe">Maybe</a> <a class="tref" href="#Matcher">Matcher</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Matcher.find">Matcher.find</a>, <a class="fref" href="#Matcher.matches">Matcher.matches</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Matcher">Matcher</a> -&gt; <a class="tref" href="./PreludeBase.html#String">String</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Matcher.match">Matcher.match</a>, <a class="fref" href="#Matcher.toString">Matcher.toString</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Matcher">Matcher</a> -&gt; <a class="tref" href="#Matcher">Matcher</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Matcher.clone">Matcher.clone</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Regex">Regex</a> -&gt; <a class="tref" href="./PreludeBase.html#String">String</a> -&gt; [<a class="tref" href="./PreludeBase.html#String">String</a>]</SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Regex.splitted">Regex.splitted</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Regex">Regex</a> -&gt; <a class="tref" href="./PreludeBase.html#String">String</a> -&gt; <a class="tref" href="#Matcher">Matcher</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Regex.matcher">Regex.matcher</a></p>
</dd>
<dt class="func">
<SPAN CLASS="code"><a class="tref" href="#Regex">Regex</a> -&gt; <a class="tref" href="./PreludeBase.html#String">String</a></SPAN></dt>
<dd class="func">
<p>
<a class="fref" href="#Regex.pattern">Regex.pattern</a></p>
</dd>
</dl>
<p>
<a HREF="http://validator.w3.org/check?uri=referer"><img src="http://www.w3.org/Icons/valid-html401" alt="Valid HTML 4.01 Strict" height="31" width="88"></a></p>
</BODY>
</HTML>
