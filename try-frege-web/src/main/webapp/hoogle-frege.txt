

-- |  Public interface for the various prelude modules   
module frege.Prelude
-- |  The Java @!@ operator on booleans   
(!) :: Bool -> Bool

-- |  A head strict variant of (:)   
-- 
--  This will be used in list comprehensions   
(!:) :: a -> [a] -> [a]

-- |  Check for inequality. The default implementation obeys the laws   
-- 
--  > !(a != a)   
-- 
--  > (a != b) == !(a == b)   
-- 
--  > (a == b) != (a != b)   
-- 
--  These laws shall also be obeyed in all implementations.   
(!=) :: Eq eq => eq -> eq -> Bool

-- |  This checks for object identity or inequality of primitive values
--     using Java's @!=@ operator.
--     It evaluates its arguments, so undefined values cannot be compared.      
(!==) :: a -> a -> Bool

-- |     > s !~ p == !(s ~ p)
--      
(!~) :: String -> Regex -> Bool

-- |     @a $ b@ is the same as @a b@, but because of '$''s low precedence
--     one can write @f $ x+y@ instead of @f (x+y)@. Also, because '$' is right
--     associative, @f $ g $ h y@ is @f (g (h y))@
--      
($) :: (b->a) -> b -> a

-- |  Same as `$` but argument is strict   
($!) :: (b->a) -> b -> a

-- |  The Java @&&@ operator on booleans. Note that since this is a
--     native function, the second argument appears strict to the compiler
--     when in fact it is lazy at the Java level.
--     This can lead to inconsistent results in some cases. For example, the following
--     program correctly prints @false@ in the first line of the output, but then aborts:
--     > main _ = do
--     >    stdout << (false && undefined) << "\n"
--     >    stdout << conj false undefined << "\n"
--     >  where
--     >    conj a b = a && b
-- 
--     Note that the very same behaviour is seen in the following java program
-- 
--     > public class And {
--     >    static boolean undef() {
--     >        if (true) throw new Error("undefined");
--     >        return false;
--     >    }
--     >    static boolean conj(boolean a, boolean b) { return a&&b; }
--     >    public static void main(String[] args) {
--     >        System.out.println(false && undef());
--     >        System.out.println(conj(false, undef()));
--     >    }
--     > }
-- 
--     One could thus say that '&&' behaves exactly like the Java operator including
--     the fact that it cannot be replaced by a function without changing the semantics
--     of a program.
-- 
--     For an alternative see 'und'
--          
(&&) :: Bool -> Bool -> Bool

-- | Unit type
data (())

-- | 2-tuple
data ((,))

-- | 3-tuple
data ((,,))

-- | 4-tuple
data ((,,,))

-- | 5-tuple
data ((,,,,))

-- | 6-tuple
data ((,,,,,))

-- | 7-tuple
data ((,,,,,,))

-- | 8-tuple
data ((,,,,,,,))

-- | 9-tuple
data ((,,,,,,,,))

-- | 10-tuple
data ((,,,,,,,,,))

-- | 11-tuple
data ((,,,,,,,,,,))

-- | 12-tuple
data ((,,,,,,,,,,,))

-- | 13-tuple
data ((,,,,,,,,,,,,))

-- | 14-tuple
data ((,,,,,,,,,,,,,))

-- | 15-tuple
data ((,,,,,,,,,,,,,,))

-- | 16-tuple
data ((,,,,,,,,,,,,,,,))

-- | 17-tuple
data ((,,,,,,,,,,,,,,,,))

-- | 18-tuple
data ((,,,,,,,,,,,,,,,,,))

-- | 19-tuple
data ((,,,,,,,,,,,,,,,,,,))

-- | 20-tuple
data ((,,,,,,,,,,,,,,,,,,,))

-- | 21-tuple
data ((,,,,,,,,,,,,,,,,,,,,))

-- | 22-tuple
data ((,,,,,,,,,,,,,,,,,,,,,))

-- | 23-tuple
data ((,,,,,,,,,,,,,,,,,,,,,,))

-- | 24-tuple
data ((,,,,,,,,,,,,,,,,,,,,,,,))

-- | 25-tuple
data ((,,,,,,,,,,,,,,,,,,,,,,,,))

-- | 26-tuple
data ((,,,,,,,,,,,,,,,,,,,,,,,,,))


instance (Bounded a,Bounded b) => Bounded (a,b)


instance (Bounded a,Bounded b,Bounded c) => Bounded (a,b,c)


instance (Eq a,Eq b) => Eq (a | b)


instance (Eq a,Eq b) => Eq (a,b)


instance (Eq a,Eq b,Eq c) => Eq (a,b,c)


instance (Ord a,Ord b) => Ord (a | b)


instance (Ord a,Ord b) => Ord (a,b)


instance (Ord a,Ord b,Ord c) => Ord (a,b,c)

-- |  Computes the product of two numbers   
(*) :: Num n => n -> n -> n

-- |  Sequence actions, discarding the value of the first argument.   
(*>) :: Applicative p => p a -> p b -> p b

-- |  Computes the sum of two numbers   
(+) :: Num n => n -> n -> n

-- |  concatenate two lists, strings or whatever   
-- 
--   > empty ++ x == x && x ++ empty == x   
(++) :: ListSemigroup α => α β -> α β -> α β

-- |  Computes the difference of two numbers   
(-) :: Num n => n -> n -> n

-- | function
data (->)

-- |  the division operator   
(/) :: Real r => r -> r -> r

-- |  Check for inequality. The default implementation obeys the laws   
-- 
--  > !(a != a)   
-- 
--  > (a != b) == !(a == b)   
-- 
--  > (a == b) != (a != b)   
-- 
--  These laws shall also be obeyed in all implementations.   
(/=) :: Eq eq => eq -> eq -> Bool

-- |  Relational @<@ operator. Obeys the following laws:
--         > if a < b && b < c then a < c
--         > a < b == b > a
--              
(<) :: Ord ord => ord -> ord -> Bool

-- |  An infix synonym for 'fmap'. Left associative with precedence 4.   
(<$>) :: Functor f => (a -> b) -> f a -> f b

-- |  Sequence actions, discarding the value of the second argument.   
(<*) :: Applicative p => p a -> p b -> p a


(<*>) :: Apply f => f (a->b) -> f a -> f b


(<+>) :: MonadAlt f => f a -> f a -> f a

-- |  Relational @<=@ operator. Obeys the following laws:
--         > if a <= b && b <= c then a <= c
--         > a <= b == b >= a
--         > a <= b == !(a > b)
--              
(<=) :: Ord ord => ord -> ord -> Bool

-- |  Right-to-left Kleisli composition of monads. ('>=>'), with the arguments flipped   
(<=<) :: Bind d => (c->d b) -> (a->d c) -> a -> d b

-- |  This operator must be defined in all instances. It compares its operands and
--         returns 'Lt' if the first is lower than the second, 'Gt' if the first is
--         greater than the second and 'Ordering.Eq' otherwise.
-- 
--         The following shall be invariantly true:
--         > case a <=> b of { Eq -> a == b; _ -> a != b }
-- 
--              
(<=>) :: Ord ord => ord -> ord -> Ordering


(<|>) :: Alt f => f a -> f a -> f a

-- |  '=<<' is the same as '>>=' with the arguments flipped       
(=<<) :: Bind b => (a->b c) -> b a -> b c

-- |  Check for equality. This function is required in all instances.   
-- 
--  The basic law of philosophy   
-- 
--  > a == a   
-- 
--  shall be obeyed by all implementations.   
(==) :: Eq eq => eq -> eq -> Bool

-- |  This checks for object identity or equality of primitive values
--     using Java's @==@ operator.
--     It evaluates its arguments, so undefined values cannot be compared.      
(===) :: a -> a -> Bool

-- |  * > string =~ regex
--  * tries to match _string_ against _regex_ and returns
--  * @Just matcher@ if it succeeds, @Nothing@ otherwise.
--       
(=~) :: String -> Regex -> Maybe MatchResult

-- |     > string =~~ regex
--     tries to match _string_ against _regex_ and returns
--     a list of all captured substrings, see 'MatchResult.groups'.
--     
--     Example:
--     
--     > case "today is 2014-02-18" =~~ ´(\d\d\d\d)-(0[1-9]|1[012])-(\d\d)´ of
--     >    [Just date, Just year, Just month, Just day] -> ...
--     >    baddate -> ....
--       
(=~~) :: String -> Regex -> [Maybe String]

-- |  Relational @>@ operator. Obeys the following laws:
--         > if a > b && b > c then a > c
--         > a > b == b < a
--              
(>) :: Ord ord => ord -> ord -> Bool

-- |  Relational @>=@ operator. Obeys the following laws:
--         > if a >= b && b >= c then a >= c
--         > a >= b == b <= a
--         > a >= b == !(a < b)
--              
(>=) :: Ord ord => ord -> ord -> Bool

-- |  left to right Kleisli composition of monads   
(>=>) :: Bind d => (a->d b) -> (b->d c) -> a -> d c

-- |         Sequentially compose two actions, discarding any value produced by the first, 
--         this works like sequencing operators (such as the semicolon) in imperative languages.
--              
(>>) :: Monad m => m a -> m b -> m b

-- |  Sequentially compose two actions, passing any value produced by the first as an argument to the second.   
(>>=) :: Bind f => f a -> (a -> f b) -> f b

-- |  In patterns, the \@-operator is used to bind a name to a complex pattern   
-- 
--  > f (x@a:as) = e   
-- 
--  is the same as   
-- 
--  > f arg = case arg of { x -> case x of { a:as -> e }}   
(@) :: b -> a -> ()


class Alt


data Appendable

-- |     A functor with application, providing operations to
-- 
--     - embed pure expressions ('pure'), and
--     - sequence computations and combine their results ('<*>').
-- 
--     A minimal complete definition must include implementations of these
--     functions satisfying the following laws:
-- 
--     [_identity_]
--         @pure id <*> v = v@
-- 
--     [_composition_]
--         @pure (•) <*> u <*> v <*> w = u <*> (v <*> w)@
-- 
--     [_homomorphism_]
--         @pure f <*> pure x = pure (f x)@
-- 
--     [_interchange_]
--         @u <*> pure y = pure ($ y) <*> u@
--   
--     The other methods have the following default definitions, which may
--     be overridden with equivalent specialized implementations:
-- 
--     >  u *> v = pure (const id)  <*> u <*> v
--     >  u <* v = pure const <*> u <*> v
-- 
--     As a consequence of these laws, the 'Functor' instance for @f@ will satisfy
--     > fmap f x = pure f <*> x
-- 
-- 
--     If @f@ is also a 'Monad', it should satisfy 
--     > (<*>) = ap 
--     (which implies that 'pure' and '<*>' satisfy the
--     applicative functor laws).
--     
--     Minimal complete definition: 'pure' and '<*>'.
--          
class Applicative


instance Applicative_->


instance Applicative_Maybe


class Apply

-- |     Type class for basic 'JArray' operations. The *element type*
--     must be an instance of this class to support arrays of that type.
--     
--     'ArrayElem' is not derivable, derive sub-class 'ArrayElement' instead.
--     
--     The operations are mostly overloaded on return type and provide the 
--     appropriate @java.lang.Class@ object when needed. 
--     
--     This supports one dimensional arrays, though more dimensions would
--     be possible with some extra effort.
--     
--     Note that 'JArray' cannot be an instance of 'ArrayElem' itself,
--     because it has no fixed @java.lang.Class@ instance.
--      
class ArrayElem

-- |  'ArrayElement' is the class one derives for array elements.   
-- 
--  In addition to the base class 'ArrayElem' it also supports mutable array elements.   
class ArrayElement


instance ArrayElement_(,)


instance ArrayElement_(,,)


instance ArrayElement_->


instance ArrayElement_Integer


instance ArrayElement_JEnum


instance ArrayElement_Object


instance ArrayElement_String


instance ArrayElement_[]

-- |  short hand for 'Mutable' @s@ ('JArray' @a@)   
type ArrayOf = Mutable s (JArray a)


class Bind

-- |     'Bool' values are based on Java's primitive @boolean@ values.
--     Note that @true@ and @false@ are literals, not constructors.
--       
data Bool


data Boolean

-- |  * A class for data types that have a lower and an upper bound.
--  *
--  * Instances of 'Bounded' can be derived automatically for enumeration types.
--       
class Bounded


instance Bounded_Bool


instance Bounded_Byte


instance Bounded_Char


instance Bounded_Int


instance Bounded_Long


instance Bounded_Short


data BufferedReader

-- |  'Byte' is the Frege type for the primitive JVM @byte@   
-- 
--  However, it is given _unsigend_ semantics in Frege.   
-- 
--  Use 'Byte' only in 'JArray's or tightly packed records!    
-- 
--  Otherwise you'll waste time while not saving space.   
data Byte

-- |  warning: probably catches more exceptions than you want to handle, use (Exception1|Exception2|Result)
--     This is the principal return type for java methods that are expected to
--     throw exceptions.
--     
--     It is strongly recommended to use more specific exception types.
--       
type CatchAll = Either Throwable

-- |  'Char' values are based on Java's primitive @char@ values.   
-- 
--  This type has many native functions based on the methods in @java.lang.Character@.    
-- 
--  Most @is...@ functions work on 'Char'  and 'Int' (codepoint).   
-- 
--  Likewise, most @to...Case@ functions work on codepoints.   
data Char


data CharSequence


data Character

-- |  * We need to do some reflection from frege code.
--  * For example, when we catch a 'Throwable' thrown from Java code.
--  * we might want to know what it is.
--       
data Class


data ClassLoader

-- |  Forward declaration of 'frege.java.Lang#ClassNotFoundException'   
data ClassNotFoundException

-- |  * For a data type declared like
--  * > data D = native Javatype
--  * where @Javatype@ implements the @java.lang.Cloneable@ interface,
--  * one can get implementations for 'Freezable.freeze'
--  * and 'Freezable.thaw' by just stating
--  * > instance Cloneable D
--  * The 'freeze' and 'thaw' operations are implemented in terms of 'clone'.
--  *
--  * Note: Cloning does *not* produce safe copies if the cloned object
--  * contains references to mutable objects. In such cases, sort of a deep cloning
--  * would be required.
--       
class Cloneable

-- |  frege equivalent of @java.io.Closeable@   
data Closeable


data Comparable

-- |  'Double' values are Java's primitive @double@ values.   
-- 
-- 
--     According to the Java Language Specification §4.2.3, @double@ values are
--     64-bit-precision binary floating point values. The values and the operations
--     on it behave as specified in the IEEE Standard for Binary Floating-Point Arithmetic.
--          
data Double


data EOFException


EQ :: Ordering


data Either

-- |  * Class 'Enum' defines operations on sequentially ordered types.
--  *
--  * A type that is an instance of 'Enum' is also an instance
--  * of 'Ord' (and, in turn, of 'Eq').
--  *
--  * Instances of 'Enum' may be derived for any enumeration type
--  * (types whose constructors have no fields).
--  * If there is no 'hashCode' provided, it will be the same as 'ord'.
--  *
--  * Enumeration types have special syntactic support with the range list:
--  > [a .. b]
--  > [a ..]
--  > [a,b .. c]
--  > [a,b ..]
--       
class Enum


instance Enum Ordering


instance Enum_Bool


instance Enum_Byte


instance Enum_Char


instance Enum_Int

-- |  * 'Integer' is an instance of 'Enum'
--       
instance Enum_Integer


instance Enum_Long


instance Enum_Short

-- |   The type class 'Eq' provides operators '==', '!=' and 'hashCode'.
--   
--   All types whose values can be compared for equality should be instances of
--   this class. For algebraic data types instances can be automatically derived
--   if all components are themselves instances of 'Eq'.
--        
class Eq


instance Eq Ordering


instance Eq_()


instance Eq_Bool


instance Eq_Byte


instance Eq_Char


instance Eq_Double


instance Eq_Float


instance Eq_Int


instance Eq_JArray


instance Eq_Long


instance Eq_Maybe


instance Eq_Short


instance Eq_String


instance Eq_[]


data Error


data Exception


data ExceptionInInitializerError

-- |     Function 'catch' requires that the argument of a handler function
--     is an instance of 'Exceptional'. 
--     
--     This is derivable for @pure@ @native@ data types.
--          
class Exceptional


instance Exceptional_ClassNotFoundException


instance Exceptional_EOFException


instance Exceptional_Error


instance Exceptional_Exception


instance Exceptional_ExceptionInInitializerError


instance Exceptional_FileNotFoundException


instance Exceptional_GuardFailed


instance Exceptional_IOException


instance Exceptional_IllegalAccessException


instance Exceptional_IllegalArgumentException


instance Exceptional_IllegalStateException


instance Exceptional_IllegalThreadStateException


instance Exceptional_IndexOutOfBoundsException


instance Exceptional_InstantiationException


instance Exceptional_InterruptedException


instance Exceptional_NoMatch


instance Exceptional_NoSuchFieldException


instance Exceptional_NoSuchMethodError


instance Exceptional_NullPointerException


instance Exceptional_PatternSyntaxException


instance Exceptional_SecurityException


instance Exceptional_StringIndexOutOfBoundsException


instance Exceptional_Throwable


instance Exceptional_Undefined


instance Exceptional_UnsupportedEncodingException


data File


data FileInputStream


data FileNotFoundException

-- |  frege equivalent of @java.io.FileOutputStream@   
data FileOutputStream

-- |  'Float' values are based on Java's primitive @float@ values.   
-- 
-- 
--     According to the Java Language Specification §4.2.3, @float@ values are
--     32-bit-precision binary floating point values. The values and the operations
--     on it behave as specified in the IEEE Standard for Binary Floating-Point Arithmetic.
--      
data Float

-- |  frege equivalent of @java.io.Flushable@   
data Flushable

-- |  * Type class for mutable values that support making read-only copies.
--  * To be implemented with care.
--       
class Freezable

-- |     The 'Functor' class is used for types that can be mapped over. 
--     Instances of 'Functor' should satisfy the following laws:
--     > fmap id == id
--     > fmap (f . g) == fmap f . fmap g
--          
class Functor


instance Functor_(,)


instance Functor_(,,)


instance Functor_Maybe


instance Functor_[]


GT :: Ordering

-- |  A subclass of 'Undefined', used by the runtime to signal failed guards   
data GuardFailed

-- |     For compatibility with Haskell, the 'HaskellBool' type defines
--     constructors 'True' and 'False'.
-- 
--     When the identifiers @True@ or @False@ are used in patterns or expressions, 
--     qualified or unqualified, and name resolution detects that they
--     resolve to 'PreludeBase.HaskellBool.True' or 'PreludeBase.HaskellBool.False'
--     they will be replaced by literals @true@ or @false@.
-- 
--     This is, of course, a hack, but I see no other way to bridge the gap between
--     redefinable constructor ids and literals. For example, we couldn't simply
--     define @True@ as another literal keyword, because some Haskell code 
--     might use @Prelude.True@ or could have code like.
--     
--     > import Prelude hiding(True, False)
--     > data TriBool = False | Perhaps | True 
--      
data HaskellBool

-- |  @IO a@ is an abbreviation for 'ST' 'RealWorld' @a@   
type IO = ST RealWorld


data IOException

-- |  They type of 'IO' actions that return a mutable value of type _d_   
-- 
--  This is an abbreviation for @ST RealWorld (Mutable RealWorld d)@    
type IOMutable = ST RealWorld (Mutable RealWorld d)

-- |  Haskell compatibility   
type IORef = Mutable RealWorld (Ref a)


data IllegalAccessException


data IllegalArgumentException


data IllegalStateException


data IllegalThreadStateException


data IndexOutOfBoundsException


data InputStream


data InputStreamReader


data InstantiationException

-- |     'Int' values are based on Java's primitive @int@ values.
-- 
--     The existence of this type is assumed in numerous places in the compiler.
-- 
--     Like with all @native@ Java types, be they primitive or reference types,
--     Frege holds the raw @int@ in boxed form. However, in certain cases the
--     compiler will optimize the boxing away:
--     - Strict variables or function arguments work with the unboxed value directly.
--     - Functions with a @native@ return type generally return the unboxed value.
--     Polymorphic data structures or functions always work with boxed values.
--     Thus, for example, the function
--     > sum a b c = a + b + c
--     can compute the sum of 3 'Int's, 'Long's, 'Double's or any other values
--     of a type that is an instance of type class 'Num', but it may be somewhat
--     slower than functions specialized for a given type.
-- 
--     According to the Java Language Specification, @int@ values are
--     32 bit wide signed two's complement integers (§4.2). Java operations on @int@ do
--     not indicate overflow or underflow in any way (§4.2.2). Instead, just the low 32 bits of
--     every result are retained.
--       
data Int

-- |  * 'Integer' is
--  * a type for integer numbers of unlimited size,
--  * It has instances for 'Eq', 'Ord', 'frege.prelude.PreludeText#Show' and 'Integral'.
-- 
--  * This is derived from @java.math.BigInteger@.
--       
data Integer

-- |  Class 'Integral' provides division and remainder operations for integral numbers.   
class Integral


instance Integral_Byte


instance Integral_Int

-- |  * 'Integer' is an instance of 'Integral'
--       
instance Integral_Integer


instance Integral_Long


instance Integral_Short


data InterruptedException


data Iterable

-- |     The type @JArray X@ corresponds to Java's @J[]@ for any type @X@
--     where @J@ is the corresponding java type of @X@,
--     but note that Java does not really have generic arrays.
--     
--     We can use arrays generically inside Frege, but native code 
--     that expects or returns arrays will not be generic.  
--     
--     The native interface will take every occurrence of
--     
--     > JArray X
--     
--     or
--     
--     > Mutable s (JArray X)
--     
--     in native declarations to denote the corresponding Java array type.
--     But when the type argument is variable, it will be just @Object@.
--     This corresponds to the usage in 
--     'http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/reflect/Array.html the array reflection API'.
-- 
--     Multi-dimensional arrays are not very well supported out of the box.
--     If one needs more than 1 dimensions, the type will get quite complex,
--     as of course arrays are mutable and so one will have multiple levels
--     of 'JArray' nested in 'Mutable' nested in 'JArray' and so forth.
--     Moreover, multi-dimensional arrays cannot be generic at all.
--     
--     Note that there are really 2 different APIs: 
--     
--     1. With the 'JArray.getElemAt', 'JArray.getAt', 'JArray.setAt', 'JArray.setElemAt',
--     'JArray.itemAt' and 'JArray.elemAt' it is possible to work on Java objects with
--     java compile time type @java.lang.Object@ *or* @X[]@ for some java type @X@
--     *or* @java.lang.Object[]@, 
--     but the run time type is always @java.lang.Object[]@. 
--     2. With the 'newArray', 'getElemAt', 'getAt', 'setAt', 
--     'setElemAt', 'itemAt' and 'elemAt' functions of the 'ArrayElem' class
--     for some type @F@ that is an instance of 'ArrayElem', 
--     we can work on Java objects with
--     Java compile time type @X[]@, 
--     where @X@ is the Java type corresponding to @F@,    
--     but the run time type is always @X[]@.    
--     
--     The former ones are usable only in polymorphic functions where the type argument 
--     for 'JArray' is a variable and we don't (want to) have 'ArrayElem' constraints. 
--     They are not good for interfacing native methods that take or return arrays of a certain type.
--     Run time type errors are possible because native methods could put anything there.
--     However, when used in Frege only, the typing is safe.
--     
--     The latter ones are truly type safe, because their Frege type corresponds to the
--     expected Java compile time type, which is also the actual run time type.  
--     
--     Here is a cheat sheet for the different array get and set methods:
--     
--     >             Array type            Argument/    Description
--     >                                   Result
--      
--     > setAt       Mutable (JArray s X)  Maybe X     set null or data element
--     > setElemAt   Mutable (JArray s X)  X           set data element
--     > getAt       Mutable (JArray s X)  Maybe X     get null or data element
--     > getElemAt   Mutable (JArray s X)  X           get data element (unsafe)
--     > itemAt      JArray s X            Maybe X     get null or data element (pure)
--     > elemAt      JArray s X            X           get data element (pure, unsafe)
--     
--     "unsafe" in this context applies only to non-primitive types
--     and means that the function will fail with a @NullPointerException@
--     if the value accessed is a Java @null@.
-- 
--      
data JArray


data JEnum

-- |     Make the @java.lang.Class@ object corresponding to the instantiated type available.
--     
--     An instance for this type class is needed for the element type 
--     of 'frege.prelude.PreludeArrays#JArray's 
--     (which are based on 
--     'http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Array.html reflective true Java arrays')
--     one needs to create.
--     
--     A subclass of this is 'Exceptional' which
--     adds no additional functionality and behaves
--     basically just as a marker interface for exceptions.
--          
--     'JavaType' instances are derivable for all data types.
--          
class JavaType


instance JavaType_JArray


LT :: Ordering

-- |     A class for containers/collections that have an empty value.
--          
class ListEmpty


instance ListEmpty_Maybe

-- |  A class for types that support the (++) operator.   
class ListMonoid


instance ListMonoid_StringJ


instance ListMonoid_[]

-- |  A class for types that support 'concat'   
class ListSemigroup

-- |     A class of things we can make a list from
--      
class ListSource


instance ListSource_Either


instance ListSource_JArray


instance ListSource_Maybe


instance ListSource_[]

-- |     A class for things we can view as a list
-- 
--     Such data types are instances of 'ListMonoid' 
--     and support 'head', 'tail', 'length' and concatenation ('++')
--     
--     This class provides no means to construct a list. 
-- 
--      
class ListView

-- |  'String' viewed as list of 'Char's.   
-- 
--  List functions on 'String's can get quite expensive when the JVM implements @substring@ via copying.   
-- 
--  Consider 'frege.data.Iterators#StringIterator' for an alternative   
instance ListView_StringJ


instance ListView_[]

-- |  * 'Long' values are based on Java's primitive @long@ values.
--  *
--  * According to the Java Language Specification, @long@ values are
--    64 bit wide signed two's complement integers (§4.2). Java operations on @long@ do
--    not indicate overflow or underflow in any way (§4.2.2). Instead, just the low 64 bits of
--    every result are retained.
--       
data Long

-- |     This interface contains query methods used to determine the results 
--     of a match against a regular expression.
-- 
--     More: 'https://docs.oracle.com/javase/7/docs/api/java/util/regex/MatchResult.html JavaDoc'
--      
data MatchResult


data Maybe

-- |     The 'Monad' class defines the basic operations over a _monad_, 
--     a concept from a branch of mathematics known as _category theory_. 
--     From the perspective of a Frege programmer, however, it is best to think
--     of a monad as an _abstract datatype_ of actions. 
-- 
--     Frege’s *@do@* expressions provide a convenient syntax for writing monadic expressions.
-- 
--     Instances of Monad should satisfy the following laws:
-- 
--     > return a >>= k == k a
--     > m >>= return == m
--     > m >>= (\x -> k x >>= h) == (m >>= k) >>= h
-- 
--     Since instances of 'Monad' are also instances of 'Functor', 
--     they additionally shall satisfy the law:
-- 
--     > fmap f xs == xs >>= return • f
--     
--     which is also the default implementation of 'fmap'.
--     
--     The instances of 'Monad' for lists, 'Maybe' and 'ST' defined in the Prelude
--     satisfy these laws.
--     
--     Minimal complete definition: '>>=' and ('pure' or 'return')
--     
--          
class Monad


class MonadAlt

-- |     The 'MonadFail' class augments 'Monad' by adding the 'fail' operation.
--     This operation is not part of the mathematical definition of a monad.
--          
class MonadFail


instance MonadFail_Either


instance MonadFail_Maybe


instance MonadFail_ST


instance MonadFail_[]


class MonadOr

-- |     A 'Monad' that also supports choice and failure
--     and observes the following laws:
--     > mzero `mplus`  v = v
--     > v `mplus` mzero  = v
--     > (a `mplus` b) `mplus` c = a `mplus` (b `mplus` c)
--     > (a `mplus` b) >>= f = (a >>= f) `mplus` (b >>= f)
--          
class MonadPlus


instance MonadPlus_Maybe


instance MonadPlus_[]

-- |     A 'Monad' with a left identity.
--          
class MonadZero


instance Monad_->


instance Monad_Either


instance Monad_Maybe


instance Monad_ST


instance Monad_[]

-- |     'Mutable' is a wrapper for native data types. 
--     A value of type @Mutable s x@ is really an @x@, but it is tied to the 'ST' thread s,
--     from which it cannot escape.
--     
--     The compiler will enforce the following rules:
--     
--     1. When type checking @x.m@ and @(x::Mutable s T)@, @m@ will be searched in the namespace @T@
--     2. An impure native method must only take and return @Mutable s T@, unless @T@ is
--        itself *@pure@* (of course, all algebraic data types are pure)
--     3. A pure type @T@ must not appear as @Mutable s T@ in native functions.
--     4. Pure native functions may not return @Mutable s t@ for any @t@.
--     5. Pure native functions must not normally get arguments of type @Mutable s T@. (see below)
--     6. In a type of the form @ST x (Mutable y d)@, it will be enforced that _x_ is the same
--        type as _y_. Furthermore, all phantom types of all 'Mutable' types must be the same
--        in a type signature.
--     
--     To understand the motivation for rule 5, observe that the 'Mutable.Mutable' 
--     data constructor cannot be applied in Frege code, hence the only possibility 
--     to obtain a value of type @Mutable s t@  is through a native function. 
--     But by rule 4 above, this could only happen in the 'ST' or 'IO' monad, 
--     from whence those values cannot escape. The 'ST' monad is a context where
--     the sequence of actions matters. If we allowed passing mutable data to pure
--     functions, their results would depend on whether 'ST' actions modified the 
--     value before the result is actually evaluated.
--     
--     Although in a strict sense, no pure function should get mutable data, rule 5 is only
--     enforced for native pure functions, as normal frege functions couldn't do anything
--     with the native value, except passing them on to native functions eventually.
--     
--     There will be means to get a read-only copy ('freeze') of a mutable value through
--     class 'Freezable'.
--     
--     There is also the possibility that, although a value is mutable, 
--     there are certain properties that cannot change (such as the length of an array). 
--     It will be possible to bypass rule 5 in such cases.
--     
--     To summarize:
--     
--     - Mutable data live in the 'ST' or 'IO' monad, from which they cannot escape.
--     - They can be passed only to other 'ST' actions that operate in the same state thread,
--       as indicated by the phantom type, that is either a type variable or 'RealWorld'.
--     - Read only copies of mutable values and mutable copies of read-only values can be obtained.        
--     - Rule 5 can be bypassed in exceptional cases.
--     
--          
data Mutable

-- |  They type for mostly mutable values that are tied to the 'IO' monad.   
-- 
-- 
--     For java types that are *mutable only* so that they always would occur 
--     wrapped into 'MutableIO', the convention is to
--     declare them as
--     
--     > data Thing = mutable native org.mut.impure.Thing
--     
--     and just write @Thing@ everywhere.
--     The type checker will check the rules for native functions  
--     _as if_ @Thing@ was 'MutableIO' @Thing@.
--     
--     However, normal type unification does not take the mutable status into account, so
--     @Mutable a m@ will never unify with @Thing@. 
--          
type MutableIO = Mutable RealWorld

-- |  A subclass of 'Undefined', used by the runtime to signal failed pattern matches   
data NoMatch


data NoSuchFieldException


data NoSuchMethodError


data NullPointerException

-- |  The 'Num' class provides the operators ('+'), ('-') and ('*') as well as
--     some functions that are common for all numeric types.
--          
class Num


instance Num_Byte


instance Num_Int


instance Num_Long


instance Num_Short

-- |  @java.lang.NumberFormatException@ needed for string conversion operations   
-- 
--  declared *@protected@* to avoid name conflicts with 'frege.java.Lang#NumberFormatException'    
data NumberFormatException

-- |     The Java Object type
--          
data Object

-- |   The 'Ord' class provides relational operators as well as the functions 'max' and 'min'.
--   The default implementation defines them all in terms of the _compare_ operator '<=>'.
-- 
--   Making some type an instance of 'Ord' makes it automatically an instance of 'Eq' if it
--   is not one already and if it has an implementation for 'hashCode'. 
--   The operators '==' and '!=' will be defined in terms of '<=>'.
-- 
--   Instances of 'Ord' can be derived automatically for algebraic data types when
--   all elements of the type are themselves instances of 'Ord' and when the type is
--   an instance of 'Eq'.
--       
class Ord


instance Ord ()


instance Ord Ordering


instance Ord_Bool

-- |  The 'Ord' instance for 'Byte's assumes that bytes are unsigned.   
-- 
--  Hence   
-- 
--  > byte (-1) > byte 1   
instance Ord_Byte


instance Ord_Char


instance Ord_Double


instance Ord_Float


instance Ord_Int

-- |  * 'Integer' is an instance of 'Ord'
--       
instance Ord_Integer


instance Ord_Long


instance Ord_Maybe

-- |  The 'Ord' instance for 'Byte's assumes that bytes are unsigned.   
-- 
--  Hence   
-- 
--  > byte (-1) > byte 1   
instance Ord_Short


instance Ord_String


instance Ord_[]

-- |  'Ordering' encodes the results of comparisons, see also  '<=>'   
data Ordering

-- |  frege equivalent of @java.io.OutputStream@   
data OutputStream


data OutputStreamWriter


class Plus

-- |     Type class for array elements of primitive type.
--     
--     Not thought for public use, as all instances are pre-defined.
--     
--     The default implementation of 'PrimitiveArrayElement.setAt'
--     does not support passing 'Nothing', because there can be no
--     @null@ in primitive arrays.
--      
class PrimitiveArrayElement


instance PrimitiveArrayElement_Bool


instance PrimitiveArrayElement_Byte


instance PrimitiveArrayElement_Char


instance PrimitiveArrayElement_Double


instance PrimitiveArrayElement_Float


instance PrimitiveArrayElement_Int


instance PrimitiveArrayElement_Long


instance PrimitiveArrayElement_Short


data PrintStream


data PrintWriter

-- |  Haskell compatibility   
type ReadS = StringJ Char -> [(a,StringJ Char)]


data Readable


data Reader

-- |  * The 'Real' class provides the division operator ('/').
--       
class Real

-- |  * This abstract data type identifies the global state (disk, network, you name it).
--  * Values of type 'ST' 'RealWorld' @a@ are likely to perform input/output, manipulate
--  * global data and so on.
--       
data RealWorld


instance Real_Double


instance Real_Float

-- |  A mutable reference, suitable for use in the 'ST' monad.   
data Ref

-- |     'Regex' values are based on Java's @java.util.regex.Pattern@ objects,
--     which are compiled representations of regular expressions.
--     
--     We call them 'Regex' and not @Pattern@ in Frege, because the 
--     word "pattern" and the phrase "pattern matching" have a quite
--     different meaning in deconstruction of algebraic data types. 
--     
--     There are 2 ways to obtain a compiled regular expression:
--     1. Use a 'Regex' literal, see the language reference section 2.7.3.
--        All regular expression literals are values of type 'Regex'. 
--        It is not possible to run a program which contains a syntactically
--        invalid 'Regex' literal - 
--        the compiler will flag it already at compile time.
--        Hence, with 'Regex' literals one is immune against 'PatternSyntaxException's.
--     2. Compile a String with 'regcomp' or 'regforce' at run-time.
--        Illegal regular expression will cause 'PatternSyntaxException'
--        to be thrown, which, when not handled appropriately, may crash
--        the program.
--     
--     'Regex' values are immutable.  
--       
data Regex


instance Replace_String

-- |  A @java.lang.Runnable@, can be created from 'IO' or 'ST' actions   
data Runnable

-- |  * @(ST s a)@ is an abstract data type and is
--  * a computation that encapsulates side effects in state thread @s@
--  * and returns a value of type @a@.
-- 
--  * The type @s@ can be understood as a compiler generated unique index for state threads.
--  * Every state thread is independent of each other and keeps track of mutable variables
--  * created in it. For detailed information, read the paper _Lazy Functional State Threads_.
-- 
--  * Every mutable native data type shall be wrapped in a 'frege.prelude.PreludeIO#Mutable' 
--  * with phantom type parameter @s@.
--  * that tells to what state thread the value belongs. 
--  * For example, the @new@ method of
--  * the java class @java.util.Date@ could be accessed like this:
-- 
--  > data Date s = native java.util.Date where
--  >     native new :: Long -> ST s (Mutable s Date)
-- 
--  * Inside ST actions, Date values can be created and manipulated with
--  * impure native methods at will. However, such a value can never escape
--  * its ST thread.
-- 
--  * Because @ST s@ is an instance of 'frege.prelude.PreludeMonad#Monad', ST actions can be combined, which
--  * ensures sequenced execution. For example, we could add another method
--  * to the Date type that converts the date to a string:
--  * >     native toString :: Mutable s Date -> ST s String
--  * and a computation which yields the current time in string form:
--  * > epoch = do
--  * >    date <- Date.new 0L
--  * >    return date.toString
--  * This looks almost like java already! @epoch@ has type @ST s String@ and we can run
--  * the computation with @epoch.run@ (see 'ST.run' below), 
--  * which gives us a nice, pure, immutable,
--  * functional, correct 'String' value.
-- 
--  * The 'IO' type is just an alias for 'ST' 'RealWorld', and can be thought of as
--  * indexing a unique global state thread.
--  * Values of type 'IO' @a@ are also called  _IO actions_.
-- 
--  * Any ST value can also be used in the IO thread.
-- 
--  * This guarantees that
--  * - any computation with side effect is sequenced through the ST-Monad
--  * - any function whose return type is not @IO something@ does not have side effects,
--  *   as long as no impure native function or value is deliberately declared to be pure.
--       
data ST

-- |  They type of 'ST' actions that return a mutable value of type _d_   
-- 
--  This is an abbreviation for @ST s (Mutable s d)@    
type STMutable = ST s (Mutable s d)


data SecurityException

-- |  * For a data type declared like
--  * > data D = native Javatype
--  * where @Javatype@ implements the @java.io.Serializable@ interface,
--  * one can get implementations for 'freeze'
--  * and 'thaw' by just stating
--  * > instance Serializable D
--  * The 'freeze' and 'thaw' operations are implemented in terms of 'copySerializable',
--  * which serializes its argument to a byte array and creates a new copy by
--  * deserializing it from the byte array.
--       
class Serializable


instance Serializable_File


instance Serializable_StringBuffer

-- |  'Short' is the Frege type for the primitive JVM @short@   
-- 
--  However, it is given _unsigend_ semantics in Frege.   
-- 
--  Use 'Short' only in 'JArray's or tightly packed records!    
-- 
--  Otherwise you'll waste time while not saving space.   
data Short

-- |  * Class 'Show' provides operations to convert values to 'String's.
-- 
--  * This class can be derived for all algebraic data types whose constituents
--  * are themselves instances of 'Show'.
--       
class Show

-- |  Haskell compatibility   
type ShowS = StringJ Char -> StringJ Char


instance Show_()


instance Show_(,)


instance Show_(,,)


instance Show_Bool


instance Show_Byte


instance Show_Char


instance Show_Double


instance Show_Either


instance Show_File


instance Show_Float


instance Show_Int


instance Show_Integer


instance Show_Long


instance Show_Maybe


instance Show_Ordering


instance Show_Regex


instance Show_Short


instance Show_String


instance Show_Throwable


instance Show_[]

-- |     'String' values are based on Java\'s @java.lang.String@ objects.
--     'String' is an alias for 'StringJ' 'Char'
--          
type String = StringJ Char


data StringBuffer

-- |  Resembles @java.lang.StringBuilder@   
data StringBuilder


data StringIndexOutOfBoundsException

-- |     Frege type for a @java.io.StringWriter@
--     
--     Not intended for direct use but rather as something
--     a 'PrintWriter' can be made of. (Though, because
--     of the 'Appendable' inheritance, one could 
--     still 'Appendable.append' directly.)
--     
--     To be used like:
--     
--     > action :: PrintWriter -> IO ()
--     > action =  ...
--     > actionOnStringWriter :: IO String  
--     > actionOnStringWriter = do
--     >       sw <- StringWriter.new
--     >       pr <- sw.printer
--     >       action pr
--     >       pr.close
--     >       sw.toString  
--          
data StringWriter


data System

-- |  An OS thread   
data Thread

-- |  Frege wrapper for java Throwables.   
data Throwable

-- |  An unchecked subclass of @java.lang.RuntimeException@ for the Frege Runtime   
-- 
--  An instance of 'Undefined' will be thrown if 'undefined' or ('error' msg) is evaluated.     
data Undefined


data UnsupportedEncodingException


data Writer

-- | list type
data ([])

-- |  @ x ^ n @  raise _x_ to the _n_-th power   
-- 
--  The exponent must be positive.    
(^) :: (Integral integ,Num a) => a -> integ -> a

-- |  * @a ^^ b@ is true if either _a_ or _b_ is true, but not both.
--  * > a ^^ b = if a then not b else b
--       
(^^) :: Bool -> Bool -> Bool

-- |  Computes the absolute value   
abs :: Num n => n -> n

-- |     @all p xs@ tells if all elements of _xs_ have property _p_.
--     This is equivalent to 
--     > fold (&&) true (map p xs) 
--     except that
--     'all' stops at the first element that hasn't property _p_.
-- 
--     Note that, according to the identity above, @all p []@ is always @true@.
--          
all :: (a->Bool) -> [a] -> Bool

-- |     'and' returns the conjunction of a Boolean list. 
--     For the result to be *true*, the list must be finite; *false*,
--     however, results from a *false* value at a finite index of a finite or infinite list.
--          
and :: [Bool] -> Bool

-- |     @any p xs@ tells if any element of _xs_ has property _p_.
--     This is equivalent to 
--     > fold (||) false (map p xs)
--     except that
--     'any' stops at the first element that has property _p_.
-- 
--     Note that, according to the identity above,  @any p []@ is always @false@.
--          
any :: (a->Bool) -> [a] -> Bool

-- |     In many situations, the 'liftM' operations can be replaced by uses of
--     'ap', which promotes function application. 
-- 
--     >       return f `ap` x1 `ap` ... `ap` xn
-- 
--     is equivalent to 
-- 
--     >       liftMn f x1 x2 ... xn
--      
ap :: Monad α => α (γ->β) -> α γ -> α β

-- |  Appends the 'String' given as second argument to the file whose name is given as the first argument.   
-- 
--  After completion, the file will be closed.   
appendFile :: String -> String -> IO ()

-- |     Convenience function to open a file in append mode for 
--     writing through an UTF-8 encoding
--     'PrintWriter'.
--     
--     May throw 'FileNotFoundException'
--          
appendWriter :: String -> IO PrintWriter


apply :: Apply p => p (a->b) -> p a -> p b

-- |     Memoize a number of results from a function that maps
--     'Int' to the array element.
--     
--     Uses 'JArray.cache' and makes it immutable
--          
arrayCache :: ArrayElem a => (Int->JArray a->a) -> Int -> JArray a

-- |     Left fold an immutable array
--      
arrayFold :: (α -> β -> α) -> α -> JArray β -> α

-- |  Create an immutable array from a finite index/value list.   
-- 
--  Uses 'JArray.fromIndexList' and freezes the resulting array.       
arrayFromIndexList :: ArrayElem α => [(Int,α)] -> JArray α

-- |  Create an immutable array from a finite list whose elements are 'ArrayElem`   
-- 
--  Uses 'JArray.fromList' and freezes the resulting array.   
arrayFromList :: ArrayElem α => [α] -> JArray α

-- |  Create an immutable array from a finite list whose elements are 'Maybe' values.   
-- 
--  Uses 'JArray.fromMaybeList' and freezes the resulting array.   
-- 
--  Note that    
-- 
--  > arrayFromList . toList   
-- 
--  does not guarantee reconstruction of the original array, because @null@s get lost, whereas   
-- 
--  > arrayFromMaybeList . toMaybeList   
-- 
--  does.   
arrayFromMaybeList :: ArrayElem a => [Maybe a] -> JArray a

-- |     Map a function over the elements of an immutable array,
--     and collect the results in another immutable array.
-- 
--     Uses 'JArray.map' and makes result read-only. 
--      
arrayMap :: (ArrayElem α,ArrayElem β) => (α -> β) -> JArray α -> JArray β

-- |  @asTypeOf a b@ is _a_  with the type of _b_.   
-- 
--  This is a type restricted version of 'const'.   
asTypeOf :: a -> a -> a

-- |  * @comparing f@ applies a projection function on both sides of '<=>'.
--  * Example usage:
--  * > sortBy (comparing snd) [(1, "z"), (2, "b")] == [(2, "b"), (1, "z")]
--       
ascending :: Ord a => (b->a) -> b -> b -> Ordering


atoi :: String -> Int

-- | This is used by code generation when a conditional expression
-- appears in a lazy context, i.e.
-- > (42, if foo then bar else baz)
-- @bool a b c@ evaluates to @a@ if @c@ is @true@, otherwise to @b@.
--      
bool :: a -> a -> Bool -> a

-- |     'break', applied to a predicate /p/ and a list /xs/, 
--     returns a tuple where the first element is the longest prefix
--     (possibly empty) of /xs/ elements that do *not* satisfy /p/ 
--     and the second element is the remainder of the list.
-- 
--     @break p@ is equivalent to @span (not • p)@.
--      
break :: (a->Bool) -> [a] -> ([a],[a])

-- |  convert an 'Int' to a 'Byte' by chopping off the leading 24 bits.   
byte :: Int -> Byte

-- |  The 'catMaybes' function takes a list of 'Maybe's and returns a list of all the 'Just' values.   
catMaybes :: ListSource b => b (Maybe a) -> [a]

-- |     The construct
--     
--     > action `catch` handler
--     
--     is a 'ST' action with the same type as _action_.
--     
--     If _action_ yields a result, this will be the result of the overall action.
--     However, if, during execution of _action_ the JVM raises an exception _e_ with 
--     java type @E@, and @E@ is a subtype of java type @H@, and @H@ is the 
--     java type associated with the argument of _handler_, the return value will be:
--     
--     > handler e
--     
--     Otherwise, if the type of _e_ does not allow to pass it to _handler_ it will
--     be propagated upwards and @a `catch` b@ will not return to its caller.
--     
--     Because 'catch' is left associative, it is possible to catch different exceptions,
--     like in:
--     
--     > action `catch` handler1 `catch` handler2
--     
--     Care must be taken to check for the *most specific* exception first. In the example above,
--     if the exception handled by _handler1_ is *less specific* than the one handled by _handler2_,
--     then _handler2_ will never get a chance to execute. 
--     
--     Another way to put this is to say that if @E1@ and @E2@ are distinct exception types
--     handled in a chain of 'catch'es, and @E1@ is (from the point of view of Java!) a
--     subtype of @E2@, then the handler for @E1@ must appear further left than the handler for
--     @E2@. If it is a super type of @E2@, however, its handler must appear further right.
--     And finally, if the types do not stand in a sub-type relationship, the order of the 
--     handlers is immaterial.
--     
--     *Note* If _action_ is of the form:
--     
--     > doSomething arg
--     
--     then, depending on the strictness of _doSomething_ the argument _arg_ may be evaluated
--     *before* the action is returned. Exceptions (i.e. undefined values) 
--     that occur in the construction of the action do *not* count as 
--     exceptions thrown during execution of it, and hence cannot be catched.
--     
--     Example:
--     
--     > println (head []) `catch`  ....
--     
--     will not catch the exception that will be thrown when println evaluates  
--     
--     For a remedy, see 'try'.         
--          
catch :: JavaType c => ST b a -> (c->ST b a) -> ST b a

-- |     The 'catchAll' function runs a 'ST' action and returns 
--     either the result or the exception thrown.
--      
catchAll :: ST α β -> ST α (Exception | β)

-- |  strip trailing spaces, tabs, newline and carriage return characters from a string   
chomp :: String -> String


chr :: Int -> Char

-- |  @chunked n xs@ makes a list of chunks of _xs_ with size _n_   
-- 
--  _n_ must be positive, otherwise an infinite list of @[]@ is returned.   
-- 
--  The following should hold:   
-- 
--  > n > 0 ==> concat (chunked n xs) == xs   
chunked :: Int -> [a] -> [[a]]

-- |      *  @clone v@ must be a native method that works like @java.lang.Object#clone@.
--           
clone :: Cloneable f => f -> f


compare :: Ord ord => ord -> ord -> Ordering

-- |  * @comparing f@ applies a projection function on both sides of '<=>'.
--  * Example usage:
--  * > sortBy (comparing snd) [(1, "z"), (2, "b")] == [(2, "b"), (1, "z")]
--       
comparing :: Ord a => (b->a) -> b -> b -> Ordering

-- |     'concat' concatenates the subitems of the argument which is a list of list
--     or a list of strings.
--     
--     It is ok if the argument is an infinite list or any of the sublists is infinite.
--     In either case, the result will also be infinite.
--          
concat :: (ListEmpty b,ListSemigroup b) => [b a] -> b a

-- |     Map a function over a list and concatenate the list or string results.
--          
concatMap :: (ListEmpty a,ListSemigroup a) => (c->a b) -> [c] -> a b

-- |  @const a@ is a function that returns _a_ regardless of its argument.   
const :: b -> a -> b

-- |  * Determines the constructor of a value.
--  * This is used like
--  * >constructor arg
--  * where @arg@ is any frege value.
--  *
--  * Returns 0 for function types, product types and native types or
--  * the _constructor number_ for constructed types. The _constructor number_
--  * is a small integer associated with every constructed value. It indicates
--  * the data constructor a value was constructed with.
--  *
--  * The compiler assigns constructor numbers starting from 0 to the constructors
--  * defined in a @data@ definition in the order of their appearance.
--  *
--  * Examples
--  * >constructor [] == 0
--  * >constructor (a:as) == 1
--  * >constructor "string"  == 0    // native value
--  *
--  * This function is strict in its argument, i.e.
--  * >constructor undefined == undefined
--  *
--  * *Implementation specific:* This function is used in derived instances
--  * of 'Eq' and 'Ord'.
--       
constructor :: a -> Int

-- |      *  @copySerializable v@ is supposed to be a native function that is
--      *  implemented by @frege.runtime.Runtime.copySerializable@ at the instantiated type.
--           
copySerializable :: Serializable f => f -> f

-- |  make a 'String' from a single 'Char'   
ctos :: Char -> String

-- |  @curry f@ passes the next two arguments as 2-tuple to _f_   
curry :: ((c,b)->a) -> c -> b -> a

-- |     @cycle xs@ builds a value that is an infinite repetition of _xs_, which must not be empty.
--          
cycle :: [α] -> [α]

-- |  * @descending f@ applies a projection function on both sides of '<=>', but flips arguments.
--  * Example usage:
--  * > sortBy (descending fst) [(1, "z"), (2, "b")] == [(2, "b"), (1, "z")]
--       
descending :: Ord a => (b->a) -> b -> b -> Ordering

-- |      'display' computes an alternate string representation of a value and is
--      used in the 'Char' and 'String' instances of 'Show' to produce an unquoted string.
-- 
--      The default implementation is to do the same as 'show'.
--           
display :: Show show => show -> String

-- |  integer division   
div :: Integral integ => integ -> integ -> integ


divMod :: Integral integ => integ -> integ -> (integ,integ)

-- |  drop a number of initial elements   
drop :: ListView α => Int -> α β -> α β

-- |     @dropWhile p xs@ drops leading elements from _xs_ that satisfy the predicate _p_.
-- 
--     The following holds for all lists _xs_
--     > takeWhile p xs ++ dropWhile p xs == xs
--          
dropWhile :: (a->Bool) -> [a] -> [a]

-- |  apply first function to value in 'Left' or second function to value in 'Right'   
either :: (a->c) -> (b->c) -> (a | b) -> c

-- |     @e `elem` xs@ is true if and only if at least one of the elements of _xs_ equals _e_.
--          
elem :: Eq a => a -> [a] -> Bool

-- |  Get non-null element at index from immutable array, see 'JArray.elemAt'   
elemAt :: ArrayElem a => JArray a -> Int -> a

-- |  the empty container   
empty :: ListEmpty α => α β

-- |  used in translating @[n..]   
enumFrom :: Enum e => e -> [e]

-- |  used in translating @[n,n'..]   
enumFromThen :: Enum e => e -> e -> [e]

-- |  used in translating @[n,n'..m]   
enumFromThenTo :: Enum e => e -> e -> e -> [e]

-- |  used in translating @[n..m]   
enumFromTo :: Enum e => e -> e -> [e]

-- |  Construct an undefined value with an informative message.   
-- 
--  When evaluated, an 'Undefined' exception will be thrown.   
error :: String -> u


even :: Integral integ => integ -> Bool

-- |  Fail with a message.    
fail :: MonadFail m => String -> m a

-- |     @filter p xs@ returns the list of elements _x_ from _xs_ where (_p x_) holds.
-- 
--     'filter' will not stop to evaluate its argument list until the first/next
--     element with the property asked for is found. For example
-- 
--     > filter (==true) (repeat false)
-- 
--     will loop forever, whereas
-- 
--     > filter even [1..] 
-- 
--     will faithfully deliver the list of positive integers that are divisible by 2,
--     one by one.
--          
filter :: (a->Bool) -> [a] -> [a]

-- |  'filterM' generalizes the list-based 'filter' function.   
filterM :: Monad a => (b->a Bool) -> [b] -> a [b]

-- |  nowarn: argument of type (ST s a)   
-- 
-- 
--     The construct
--     
--     > action `finally` always
--     
--     returns the same value as _action_, when executed.
--     
--     However, no matter if _action_ produces a value or diverges 
--     (for example, by throwing an exception), in any case will _always_ be executed,
--     and its return value dismissed.
--     
--     Note that 'finally' only returns to its caller if _action_ would have done so.
--     
--     'finally' has the same fixity as 'catch', hence it is possible to have
--     
--     > action `catch` handler1 `catch` handler2 `finally` always
--     
--          
finally :: IO a -> IO b -> IO a

-- |     > findAt string regex offset
--     
--     Like '=~', but matches only the substring of _string_ that starts at _offset_
--     against _regex_.
--     
--     If _offset_ is  negative or not smaller than the length of _string_, the 
--     result is _Nothing_
--      
findAt :: String -> Regex -> Int -> Maybe MatchResult

-- |  Exchange first and second argument of a function, i.e.   
-- 
--  > flip f a b = f b a   
flip :: (a->b->c) -> b -> a -> c

-- |  Map a function over a 'Functor'   
fmap :: Functor f => (a -> b) -> f a -> f b

-- |     'fold', applied to a binary operator, a starting value (typically the
--     left identity of the operator), and a list, reduces the list using
--     the binary operator, from left to right:
--     > fold f z [x1, x2, ..., xn] = (((z `f` x1) `f` x2) `f` ...) `f` xn
--     'fold' runs in constant stack space, but consumes the entire list before
--     returning a result, so it must not be applied to infinite lists.
-- 
--     This function is known as @foldl'@ in Haskell where there is a bias in favour
--     of using 'foldr'.
-- 
--     In the environment of the JVM stack space is precious, hence one should prefer 'fold'
--     when one has the choice.
-- 
--     'fold' is strict in the accumulator, hence in
--     every recursion the intermediate result is evaluated, thus preventing build up of
--     possibly huge thunks that result in stack overflows on evaluation.
--          
fold :: (b->a->b) -> b -> [a] -> b

-- |  @foldM f a xs@ folds a monadic function _f_ over the list _xs_.   
foldM :: Monad a => (b->c->a b) -> b -> [c] -> a b

-- |  @foldM_@ is the same as 'foldM', but discards the result   
foldM_ :: Monad b => (c->a->b c) -> c -> [a] -> b ()

-- |   warning: It is strongly advised to use 'fold' instead - beware of stack overflow!
-- 
--     'foldl', applied to a binary operator, a starting value (typically the
--     left identity of the operator), and a list, reduces the list using
--     the binary operator, from left to right:
-- 
--     > fold f z [x1, x2, ..., xn] = (((z `f` x1) `f` x2) `f` ...) `f` xn
-- 
--     Because the operator is applied lazily, 'foldl' typically builds up
--     large thunks which, when finally evaluated, may overflow the stack space.
--     Therefore, the use of 'fold' instead of 'foldl' is strongly suggested.
-- 
--     This function exists merely for compatibility with Haskell.
-- 
--      
foldl :: (b->a->b) -> b -> [a] -> b

-- |     'fold', applied to a binary operator, a starting value (typically the
--     left identity of the operator), and a list, reduces the list using
--     the binary operator, from left to right:
--     > fold f z [x1, x2, ..., xn] = (((z `f` x1) `f` x2) `f` ...) `f` xn
--     'fold' runs in constant stack space, but consumes the entire list before
--     returning a result, so it must not be applied to infinite lists.
-- 
--     This function is known as @foldl'@ in Haskell where there is a bias in favour
--     of using 'foldr'.
-- 
--     In the environment of the JVM stack space is precious, hence one should prefer 'fold'
--     when one has the choice.
-- 
--     'fold' is strict in the accumulator, hence in
--     every recursion the intermediate result is evaluated, thus preventing build up of
--     possibly huge thunks that result in stack overflows on evaluation.
--          
foldl' :: (b->a->b) -> b -> [a] -> b

-- |     'foldl1' is a variant of 'fold' that has no starting value argument
--     and thus must be applied to nonempty lists only.
--          
foldl1 :: (a->a->a) -> [a] -> a

-- |     'foldl1' is a variant of 'fold' that has no starting value argument
--     and thus must be applied to nonempty lists only.
--          
foldl1' :: (a->a->a) -> [a] -> a

-- |     Fold over a list from right to left.
--     > foldr f a (x1:x2:x3:[])
--     is the same as
--     > x1 `f` (x2 `f` (x3 `f` a))
--     Note that, if _f_ is strict in the second argument,
--     @foldr f@ will need stack space proportional
--     to the length of the list.
--     But if _f_ is lazy in it's second argument, 'foldr' works on infinite lists.
-- 
--     If _f_ is commutative, the list finite and laziness not an issue,
--     'fold' may be the better choice since it runs with constant stack space.
--     Otherwise, if _f_ is not commutative, 'foldrs' will trade time and heap space for
--     stack space by 'fold'ing the 'flip'ped _f_ over the 'reverse'd list.
--          
foldr :: (a->b->b) -> b -> [a] -> b

-- |  'foldr1' is a variant of 'foldr' that has no starting argument, and thus must be applied to a non-empty list    
foldr1 :: (a->a->a) -> [a] -> a

-- |     This function may be used in place of
--     > foldr f z xs
--     if _f_ is strict in its right operand and _xs_ is a finite list,
--     in cases where 'foldr' exceeds the stack size, which is usually quite limited in
--     the JVM.
-- 
--     'foldrs' will need extra CPU cycles and maybe (temporary) heap space for
--     'reverse'-ing its list argument, before 'fold'ing the 'flip'ped _f_ over it.
-- 
--     If _f_ is commutative, you may simply use 'fold' instead.
-- 
--     The following property holds for all finite lists _xs_:
--     > foldr f z xs == foldrs f z xs
--          
foldrs :: (b->a->a) -> a -> [b] -> a

-- |  @for listSource f@ is a Java-friendly alias for @forM_@ that works on any list source   
for :: (Monad m,ListSource listSource) => listSource e -> (e -> m a) -> m ()

-- |  @forM xs f@ = @mapM_ f xs@    
forM :: Monad b => [a] -> (a->b c) -> b [c]


forM_ :: Monad a => [b] -> (b->a c) -> a ()

-- |  nowarn: deep recursion possible   
-- 
--  repeat action forever   
forever :: Monad a => a c -> a b

-- |      * "Freeze" a mutable native value. The result is supposed to be immutable
--      * or at least not reachable from other parts of the code, especially from java code.
--      *
--      * The most prominent way to freeze a value is by 'clone'-ing it, if that is supported.
--      * But note that sometimes a deep copy would be needed, and that @clone@ does not do that.
--           
freeze :: Freezable f => f -> f

-- |      * @T.from i@ maps the 'Int' value @i@ to a value of @T@, such that
--      >   ord (T.from i) == i
--      * unless there is no value @e@ of @T@ so that @ord e == i@. In the
--      * latter case, the result is 'undefined'.
--           
from :: Enum e => Int -> e

-- |  convert a 'Double' to any 'Real' value   
fromDouble :: Real r => Double -> r

-- |  @ord e@ returns the ordinal number associated with the value @e@. For
--      * enumeration types, 'ord' is the same as 'constructor', for 'Int', it is the
--      * identity function.
--      * Some types, like 'Long', cannot map all their values to 'Int', in such cases
--      * the result of applying 'ord' may be meaningless.
--           
fromEnum :: Enum e => e -> Int

-- |  converts an 'Int' value to the instantiated type   
fromInt :: Num n => Int -> n

-- |  converts an 'Integer' value to the instantiated type   
fromInteger :: Num n => Integer -> n

-- |  every 'Num' can be made from an 'Integral'   
fromIntegral :: (Integral integ,Num b) => integ -> b

-- |  @fromMaybe d (Just a)@ returns @a@ and @fromMaybe d Nothing@ returns @d@   
fromMaybe :: a -> Maybe a -> a

-- |  return the first element of a 2-tuple   
fst :: (a,b) -> a

-- |         'gcd' @x y@ is the non-negative factor of both @x@ and @y@ of which
--         every common factor of @x@ and @y@ is also a factor; for example
--         'gcd' @4 2 = 2@, @'gcd' (-4) 6 = 2@, @'gcd' 0 4@ = @4@. @'gcd' 0 0@ = @0@.
--         (That is, the common divisor that is \"greatest\" in the divisibility
--         preordering.)
--     
--         Note: Since for signed fixed-width integer types, 'abs' 'minBound' < @0@,
--         the result may be negative if one of the arguments is 'minBound' (and
--         necessarily is if the other is @0@ or 'minBound') for such types.
--              
gcd :: Integral integ => integ -> integ -> integ

-- |  worker function for 'Integral.gcd', needs not pollute the namespace   
gcdHelper :: Integral integ => integ -> integ -> integ

-- |  Create an immutable generic array from a finite index/value list.   
-- 
--  Uses 'JArray.genericFromIndexList' and freezes the resulting array.   
genericArrayFromIndexList :: JavaType α => [(Int,α)] -> JArray α

-- |  Get item at index from mutable array, see 'JArray.getAt'   
getAt :: ArrayElem a => ArrayOf s a -> Int -> ST s (Maybe a)

-- |  read a character from the standard input reader   
getChar :: IO Char

-- |  The 'getContents' operation returns all user input as a single string   
getContents :: IO String

-- |  The 'getContentsOf' operation returns all input from the supplied 'Reader' as a single string.   
-- 
--  After completion, the 'Reader' is closed.   
getContentsOf :: Reader -> IO String

-- |  Get non null item at index from mutable array, see 'JArray.getElemAt'   
getElemAt :: ArrayElem a => ArrayOf s a -> Int -> ST s a

-- |  read a line from the standard input reader, end of line characters are removed.   
getLine :: IO String

-- |   @guard b@ is @return ()@ if @b@ is *@true@*, and 'mzero' otherwise.   
guard :: MonadZero a => Bool -> a ()

-- |  Compute a hash code.    
-- 
--  The following rules shall hold in all instances:   
-- 
--  > a == b ==> hashCode a == hashCode b   
-- 
--  > hashCode a != hashCode b ==> a != b   
-- 
--  In addition, unequal values should produce unequal hash codes more likely than not.   
-- 
-- 
--         The hash code in derived instances for algebraic data types is computed as follows:
--         > hashCode v = case v of
--         >    Con_1 f_1 ... f_k -> fold mkhash 1 [1, hashCode f_1, ..., hashCode f_k ]
--         >    ...
--         >    Con_n f_1 ... f_k -> fold mkhash 1 [n, hashCode f_1, ..., hashCode f_k ]
--         >   where mkhash a b = (31 * a) + b
--         Here, the @Con_i@ with @i>0@ are the constructors, and in each clause
--         the @f_j@ with @j >= 0@ are bound to the fields of the constructor under
--         consideration.
--          
hashCode :: Eq eq => eq -> Int

-- |  The first element of a list-view, or 'undefined' if 'empty'   
head :: ListView α => α β -> β

-- |  the identity morphism   
id :: Category.Category f => f a a

-- |  Returns all but the last element from a list.   
-- 
--  The following property holds for all non-empty finite lists /xs/:   
-- 
--  > init xs ++ [last xs] == xs   
init :: [a] -> [a]

-- |     The 'interact' function takes a function of type 'String' -> 'String' as its argument. 
--     The entire input from the standard input device is passed to this function as its argument, 
--     and the resulting string is output on the standard output device.
--      
interact :: (String->String) -> IO ()

-- |  Floating point number types may have special values for _infinity_
--         and _negative infinity_. @isFinite n@ yields @true@ if @n@ is an infinite
--         value and @false@ in all other cases.
-- 
--         The default implementation always returns @false@ so that implementors of
--         instances for types without special values for infinity need not care.
-- 
--         See also 'isNumber'.
--          
isInfinite :: Num n => n -> Bool

-- |  @true@ if and only if the argument is a 'Just' value   
isJust :: Maybe a -> Bool

-- |  Floating point number types may have a special values for
--         _not a number_ (NaN). For example, @0d / 0d@ is NaN.
--         @isNaN n@ yields @true@ if @n@ is the special value that indicates that
--         @n@ is not a number and @false@ in all other cases.
-- 
--         The default implementation always returns @false@ so that implementors of
--         instances for types without such a special values need not care.
-- 
--         See also 'isNumber'.
--          
isNaN :: Num n => n -> Bool

-- |  @true@ if and only if the argument is 'Nothing'   
-- 
--  This function is preferable over @v == Nothing@ because no 'Eq' constraint is needed.   
isNothing :: Maybe a -> Bool

-- |  Returns @true@ if @n@ is neither infinite (see 'isInfinite') nor NaN (see 'isNaN').
-- 
--         Note that certain properties for functions on numbers are true only under the assumption
--         that the argument values are numbers.
-- 
--         The default implementation is
--         > isNumber n = !(isInfinite n) && !(isNaN n)
--         so that the function should always compute
--         the right answer as long as 'isInfinite' and 'isNaN' do.
--          
isNumber :: Num n => n -> Bool

-- |  Get item at index from immutable array, see 'JArray.itemAt'   
itemAt :: ArrayElem a => JArray a -> Int -> Maybe a

-- |     @iterate f a@ builds the infinite list @[a, f a, f (f a), ...]@
--          
iterate :: (a->a) -> a -> [a]

-- |  The @java.lang.Class@ object of the instantiated type   
javaClass :: JavaType e => Class e

-- |         The 'join' function is the conventional monad *join* operator. 
--         It is used to remove one level of monadic structure, projecting its bound argument into the outer level.
--              
join :: Monad m => m (m a) -> m a

-- |   @joined sep xs@ concatenates all strings in /xs/,
--   and inserts /sep/ between any two elements of /xs/.
-- 
--   If /xs/ is empty, the result is an empty string. If /sep/ is an empty string,
--   then the result is just the concatenation of the strings in /xs/.
-- 
--   Example:
--   > joined ", " ["aaa", "bbb", "ccc"] == "aaa, bbb, ccc"
--       
joined :: String -> [String] -> String

-- |  Returns the last element of a list by taking the 'head' of the 'reverse'd list.   
-- 
--  See also 'init'   
last :: [a] -> a

-- | warning: will soon be replaced with bool
-- This is used by code generation when a conditional expression
-- appears in a lazy context, i.e.
-- > (42, if foo then bar else baz)
-- @lazyif a b c@ evaluates to @b@ if @a@ is @true@, otherwise to @c@.
--      
lazyif :: Bool -> a -> a -> a

-- |  'lcm' @x y@ is the smallest positive integer that both @x@ and @y@ divide.   
lcm :: Integral integ => integ -> integ -> integ

-- |  computes the length of the container in a type dependent way   
length :: ListView α => α β -> Int


liftA :: Applicative f => (a -> b) -> f a -> f b


liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c


liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d


liftA4 :: Applicative f => (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e


liftA5 :: Applicative f => (a -> b -> c -> d -> e -> g) -> f a -> f b -> f c -> f d -> f e -> f g

-- |  Promote a function to a monad.   
liftM :: Monad m => (a -> b) -> m a -> m b

-- |  Promote a function to a monad, scanning the monadic arguments from left to right.  For example,   
-- 
--  >    liftM2 (+) [0,1] [0,2] = [0,2,1,3]   
-- 
--  >    liftM2 (+) (Just 1) Nothing = Nothing   
liftM2 :: Monad b => (d->c->a) -> b d -> b c -> b a

-- |  Promote a function to a monad, scanning the monadic arguments from left to right (cf. 'liftM2').   
liftM3 :: Monad d => (c->a->b->e) -> d c -> d a -> d b -> d e

-- |  Promote a function to a monad, scanning the monadic arguments from left to right (cf. 'liftM2').   
liftM4 :: Monad a => (e->f->c->d->b) -> a e -> a f -> a c -> a d -> a b

-- |  Promote a function to a monad, scanning the monadic arguments from left to right (cf. 'liftM2').   
liftM5 :: Monad g => (a->b->d->e->c->f) -> g a -> g b -> g d -> g e -> g c -> g f

-- |  The line separator suitable for the platform the program is running on.   
lineSeparator :: String

-- |  splits a 'String' on end-of-line  and returns a list of 'String's   
-- 
--  The last line may or may not be terminated by newline.   
-- 
--  End-of-line is signaled by a number of carriage returns followed by a new line.   
-- 
--  This should work for UNIX and Windows.   
lines :: String -> [String]

-- |  give the first element of a list or 'Nothing'   
listToMaybe :: ListSource a => a b -> Maybe b

-- |     @map f xs@ applies _f_ to each element of _xs_ and builds a new list from the results.
-- 
--     Usage of 'map' is safe on infinite lists, it delivers the result list one by
--     one as it is demanded.
--          
map :: (b->a) -> [b] -> [a]

-- |     The 'mapAndUnzipM' function maps its first argument over a list, returning
--     the result as a pair of lists. This function is mainly used with complicated
--     data structures or a state-transforming monad.
--          
mapAndUnzipM :: Monad a => (b->a (d,c)) -> [b] -> a ([d],[c])

-- |  @mapM f@ is equivalent to @sequence • map f@   
mapM :: Monad b => (c->b a) -> [c] -> b [a]

-- |  @mapM_ f@ is equivalent to @sequence_ • map f@   
mapM_ :: Monad b => (c->b a) -> [c] -> b ()

-- |     The 'mapMaybe' function is a version of 'map' which can throw out elements. 
--     In particular, the functional argument returns something of type 'Maybe' _b_. 
--     If this is 'Nothing', no element is added on to the result list. 
--     If it just 'Just' _b_, then _b_ is included in the result list.
--          
mapMaybe :: (b->Maybe a) -> [b] -> [a]


mapReader :: (a -> b) -> (r -> a) -> r -> b

-- |  > max a b = if a > b then a else b   
max :: Ord ord => ord -> ord -> ord

-- |  the upper bound   
maxBound :: Bounded b => b

-- |  The maximal value of a non empty list, same as ('foldl1' 'max')    
maximum :: Ord a => [a] -> a

-- |     The 'maybe' function takes a default value, a function, and a 'Maybe' value. 
--     If the 'Maybe' value is 'Nothing', the function returns the default value. 
--     Otherwise, it applies the function to the value inside the 'Just' and returns the result.
--          
maybe :: a -> (b->a) -> Maybe b -> a

-- |  convert a 'Maybe' to a single element list or an empty list   
maybeToList :: Maybe a -> [a]

-- |  > min a b = if a < b then a else b   
min :: Ord ord => ord -> ord -> ord

-- |  the lower bound   
minBound :: Bounded b => b

-- |  The minimal value of a non empty list, same as ('foldl1' 'min')    
minimum :: Ord a => [a] -> a

-- |  This modulo operator works so that   
-- 
--  > forAll arbitrary (\a -> forAll arbitrary (\b -> (a `div` b) * b + (a `mod` b) = a))   
-- 
--  In addition, it is the case that   
-- 
--  > forAll arbitrary (\a -> forAll arbitrary (\b -> @(a `quot` b) == (a `div` b) || (a `quot` b) == (a `div` b)-1))   
mod :: Integral integ => integ -> integ -> integ

-- |  Modify item at index in mutable array with result of function application.   
modifyAt :: ArrayElem a => (a -> a) -> ArrayOf s a -> Int -> ST s ()

-- |  Modify non null item at index in mutable array with result of function application.   
modifyElemAt :: ArrayElem a => (a -> a) -> ArrayOf s a -> Int -> ST s ()

-- |  modify the referenced value with a function   
modifyIORef :: Mutable b (Ref a) -> (a->a) -> ST b ()

-- |  an associative operation   
mplus :: MonadPlus mp => mp a -> mp a -> mp a

-- |  'msum' generalizes the list-based 'concat' function.   
msum :: MonadPlus a => [a b] -> a b

-- |  Obtain a read only native value (temporarily) typed as 'Mutable'   
-- 
--  
--     For example, this could be needed when running a native 'ST' method
--     that uses the value as read-only, but we can't declare it, like:
-- 
--     > private native copyOf java.util.Arrays.copyOf 
--     >               :: ArrayOf s HashMap -> Int -> ST s (ArrayOf s HashMap)
--      
mutable :: b -> Mutable a b

-- |  This value should satisfy _left zero_:    
-- 
--  > mzero >>= f = mzero   
mzero :: MonadZero mz => mz a

-- |  Negates a number n such that if n is a number   
-- 
--  > n + negate n == 0   
negate :: Num n => n -> n

-- |  Create a one dimensional array with elements of the instantiated type.   
newArray :: ArrayElem a => Int -> STMutable s (JArray a)

-- |  Create an array of mutable items.    
-- 
--  Such an array may never be immutable itself.    
newArrayM :: ArrayElement a => Int -> STMutable s (JArray (Mutable s a))

-- |  create a reference that is initially set to the argument value    
newIORef :: a -> STMutable s (Ref a)

-- |     @not b@ is true if _b_ is false, otherwise true. Uses java's '!' operator.
--       
not :: Bool -> Bool

-- |  opposite of 'elem'   
notElem :: Eq a => a -> [a] -> Bool

-- |  *true* if and only if the container is 'empty'   
null :: ListEmpty α => α β -> Bool


odd :: Integral integ => integ -> Bool

-- |  Like '||', but second argument is lazy.
--     The @`oder`@ operator has the same precedence and arity as '||'.
--     The definition is
--     > a `oder`  b = if a then true  else b
--     This should really be named _or_, but Haskell 2010 uses this already for lists.
--     Hence we use the german word _oder_.
--          
oder :: Bool -> Bool -> Bool

-- |  > g `on` f    
-- 
--  Apply a projection function @f@ on both operands of @g@   
-- 
--  > comparing f = (<=>) `on` f   
on :: (a->a->c) -> (b->a) -> b -> b -> c

-- |  the number 1 in the instantiated type   
one :: Num n => n

-- |     Convenience function to open a file and wrap it with an UTF-8 decoding
--     buffered 'Reader'.
--     
--     May throw 'FileNotFoundException'
--          
openReader :: String -> IO BufferedReader

-- |     Convenience function to open a file for writing through an UTF-8 encoding
--     'PrintWriter'.
--          
openWriter :: String -> IO PrintWriter

-- |     'or' returns the disjunction of a Boolean list. 
--     For the result to be *false*, the list must be finite; *true*,
--     however, results from a *true* value at a finite index of a finite or infinite list.
--          
or :: [Bool] -> Bool


orElse :: MonadOr mo => mo a -> mo a -> mo a

-- |  @ord e@ returns the ordinal number associated with the value @e@. For
--      * enumeration types, 'ord' is the same as 'constructor', for 'Int', it is the
--      * identity function.
--      * Some types, like 'Long', cannot map all their values to 'Int', in such cases
--      * the result of applying 'ord' may be meaningless.
--           
ord :: Enum e => e -> Int

-- | This is a constant with the value @true@.
-- It is most often used as the last alternative in pattern guards:
-- 
-- > foo n | n >= 0    = ...
-- >       | otherwise = ...
--      
otherwise :: Bool

-- |     convert a list of characters to a string
--     > packed ['a', 'b', 'c' ] == "abc"
--          
packed :: [Char] -> String

-- |  helper for 'Integral.^'   
powf :: (Integral integ,Num a) => a -> integ -> a

-- |  helper for 'Integral.^'   
powg :: (Integral integ,Num a) => a -> integ -> a -> a

-- |  @pred e@ is the predecessor of @e@ or 'undefined' if there is no predecessor.   
pred :: Enum e => e -> e

-- |  Print a value to the standard output writer.   
-- 
--  This will come out UTF8 encoded.   
print :: Show a => a -> IO ()

-- |  warning: use @stdout.print@ instead   
-- 
--  print a 'String' to the standard output stream   
printStr :: String -> IO ()

-- |  warning: use @stdout.println@ instead   
-- 
--  print a 'String' to the standard output stream and append a new line.   
printStrLn :: String -> IO ()

-- |  Print a value to the standard output stream and append a platform typical new line character.   
-- 
--  This will come out UTF8 encoded.   
println :: Show a => a -> IO ()

-- |  The product of the numbers in a list, same as ('fold' ('*') 'one')   
product :: Num a => [a] -> a

-- |  Lift a value   
pure :: Applicative p => a -> p a

-- |  write a character to 'stdout'   
putChar :: Char -> IO ()

-- |  write a 'String' to standard output (Haskell compatibility)   
putStr :: String -> IO ()

-- |  write a 'String' and a new line to standard output (Haskell compatibility)   
putStrLn :: String -> IO ()


pzero :: Plus f => f a


quot :: Integral integ => integ -> integ -> integ

-- |  Haskell compatibility   
quotRem :: Integral integ => integ -> integ -> (integ,integ)

-- |  The readFile function reads a file and returns the contents of the file as a string.   
-- 
--  If the file doesn't exist, a 'FileNotFoundException' will be thrown.   
readFile :: String -> IO String

-- |  get the value the reference is pointing to   
readIORef :: Mutable s (Ref a) -> ST s a

-- |  Apply a pure function to a mutable value that pretends to be read-only.   
-- 
--  The function must not rely on anything that could change in the mutable data!   
readonly :: (m -> b) -> Mutable s m -> ST s b

-- |  compile a 'String' to a 'Regex'   
-- 
--  Returns 'either' a  'PatternSyntaxException' in 'Left' or a 'Regex' in 'Right'.   
-- 
--  
--         The overloaded form has an additional 'Int' argument which is a set of flags.
--         Such a set can be constructed by adding up the individual flag values, for example:
-- 
--         >  Regex.compile "foo|bar" (Regex.canon_eq + Regex.case_insensitive)
-- 
--          
regcomp :: ω

-- |     compile a 'String' to a 'Regex'
--     
--     This will throw 'PatternSyntaxException' when the regular expression is illegal. 
-- 
--     Use this only if you're sure that pattern compilation will not throw
--     an exception, or if you don't care.
--      
regforce :: ω

-- |  The remainder á la Java operator @%@ - @a `rem` b@ has same sign as @a@   
-- 
--  > forAll arbitrary (\a -> forAll arbitrary (\b -> (a `quot` b) * b + (a `rem` b) = a   
-- 
--  This behaviour is the same as in Haskell   
rem :: Integral integ => integ -> integ -> integ

-- |     @repeat a@ builds an infinite list where all elements are _a_.
--          
repeat :: a -> [a]


replicate :: Int -> a -> [a]

-- |  @replicateM n act@ performs the action @n@ times, gathering the results.   
replicateM :: Monad m => Int -> m a -> m [a]

-- |  Like 'replicateM', but discards the result.   
replicateM_ :: Monad m => Int -> m a -> m ()

-- |         Inject a value into the 'Monad'. This is the same as 'pure'.
--              
return :: Monad m => a -> m a

-- |     reverses a list
--          
reverse :: [a] -> [a]


runReader :: (r -> a) -> r -> a

-- |     'scanl' is similar to 'fold' but returns a list of successive
--     reduced values from the left:
--     > scanl f z [x1, x2, ...] = [z, z `f` x1, (z `f` x1) `f` x2, ... ]
--     The following property holds for all finite lists _xs_:
--     > last (scanl f z xs) == fold f z xs
--     In contrast to 'fold', 'scanl' can operate on infinite lists.
--           
scanl :: (a->b->a) -> a -> [b] -> [a]

-- |     'scanl1' is similar to 'scanl', but takes the 'head' of the list as
--     starting element and is thus only applicable to non-empty lists.
--     > scanl1 f [x1, x2, ...] = [x1, x1 `f` x2, (x1 `f` x2) `f` ...]
--          
scanl1 :: (a->a->a) -> [a] -> [a]

-- |  'scanr' is the right-to-left dual of 'scanl'.   
-- 
--  Note that   
-- 
--  > head (scanr f z xs) == foldr f z xs.   
scanr :: (α -> β -> β) -> β -> [α] -> [β]

-- |  'scanr1' is a variant of 'scanr' that has no starting value argument.   
scanr1 :: (a->a->a) -> [a] -> [a]

-- |  @a `seq` b@ evaluates _a_ before it returns _b_   
-- 
--  This is a right associative operator with precedence 15.   
seq :: a -> b -> b

-- |     Turn a list of monadic values @[m a]@ into a monadic value with a list @m [a]@
--     > sequence [Just 1, Just 3, Just 2] = Just [1,2,3]
--     This version of 'sequence' runs in constant stack space,
--     but needs heap space proportional to the size of the input list.
--          
sequence :: Monad b => [b a] -> b [a]

-- |  fold ('>>') over a list of monadic values for side effects      
sequence_ :: Monad a => [a b] -> a ()

-- |  Set item or null at index in mutable array, see 'JArray.setAt'   
setAt :: ArrayElem a => ArrayOf s a -> Int -> Maybe a -> ST s ()

-- |  Set item at index in mutable array. see 'JArray.setElemAt'   
setElemAt :: ArrayElem a => ArrayOf s a -> Int -> a -> ST s ()

-- |  convert an 'Int' to a 'Short' by chopping off the leading 16 bits.   
short :: Int -> Short

-- |  Version of 'filterM' that works on small lists with length < 1000 only.   
-- 
--  Beware of stack overflow, and use 'filterM', when in doubt.   
shortFilterM :: Monad a => (b->a Bool) -> [b] -> a [b]

-- |  'shortFoldM' is suitable only for lists with a length way below 1000.   
-- 
--  Beware of stack overflow and use 'foldM' instead.   
shortFoldM :: Monad b => (c->a->b c) -> c -> [a] -> b c

-- |     A version of 'sequence' that uses the stack and may overflow
--     with longer lists. 
--     
--     A length of about 500 should be ok in most cases.
--          
shortSequence :: Monad a => [a b] -> a [b]

-- |  Computes the string representation of a value.   
-- 
--  Every instance must implement 'show'.   
show :: Show show => show -> String

-- |  Haskell compatibility   
showChar :: Char -> String -> String

-- |         'showChars' addresses the problem of 'show'ing infinite values.
--         Because 'show' has type 'String' and 'String' is atomic, this would
--         try to create a string with infinite length, and hence is doomed to fail.
--         
--         The default definition is
--         
--         > showChars = String.toList . show
--         
--         This is ok for all finite values. But instances for recursive types
--         should implement it in a way that produces a lazy list of characters.
--         
--         Here is an example for the list instance:
--         
--         > showChars [] = ['[', ']']
--         > showChars xs = '[' : ( tail [ c | x <- xs, c <- ',' : showChars x ] ++ [']'] )
--         
--          
showChars :: Show show => show -> [Char]

-- |  Haskell compatibility   
showList :: Show show => [show] -> String -> String

-- |  Haskell compatibility   
showParen :: Bool -> (String -> String) -> String -> String

-- |  Haskell compatibility   
showString :: String -> String -> String

-- |  Haskell compatibility   
shows :: Show a => a -> String -> String

-- |  Haskell compatibility   
showsPrec :: Show show => Int -> show -> String -> String

-- |      * 'showsub' is used for 'show'ing elements of a value of an algebraic data type
--      * in derived instances of 'Show'.
--      *
--      * The generated code in derived instances for types that are not
--      * enumerations is
--      * > showsub x = "(" ++ show x ++ ")"
--      * so that values are enclosed in parentheses.
--      * Certain types like records, lists, tuples and many primitive types do not need
--      * extra parentheses, and thus 'showsub' is the same as 'show', which is also the
--      * default implementation.
--      *
--      * In short,
--      * - in derived instances, 'showsub' will do the right thing.
--      * - in all other instances, 'showsub' will do the same as 'show' if not
--      *   implemented differently.
--      *
--      * Example:
--      * > derive Show ( Maybe b)
--      * implements the following:
--      * > show Nothing = "Nothing"
--      * > show (Just x) = "Just " ++ x.showsub
--      * > showsub x = "(" ++ show x ++ ")"
--      * so that
--      * > show (Just (Just 42)) == "Just (Just 42)"
--      *
--           
showsub :: Show show => show -> String

-- |  @sign n@ is -1 if n<0, 1 if n>0 and 0 otherwise   
sign :: Num n => n -> Int

-- |  return the second element of a 2-tuple   
snd :: (b,a) -> a

-- |     @span p xs@ returns a tuple whose first element is the longest prefix of _xs_
--     elements that satisfy _p_ and whose second element is the remainder of the list.
-- 
--     > span p xs == (takeWhile p xs, dropWhile p xs)
--          
span :: (a->Bool) -> [a] -> ([a],[a])

-- |     @splitAt n xs@ returns a tuple where first element is _xs_ prefix of length _n_ 
--     and the second element is the
--     remainder of the list.
--      
splitAt :: ListView a => Int -> a b -> (a b,a b)

-- |  nowarn: Don't warn because of constantness   
-- 
--  The standard error 'PrintWriter'   
stderr :: PrintWriter

-- |  nowarn: Don't warn because of constantness   
-- 
--  The standard input 'BufferedReader'   
stdin :: BufferedReader

-- |  nowarn: Don't warn because of constantness   
-- 
--  The standard output 'PrintWriter'   
stdout :: PrintWriter

-- |     @strhead s n@ returns the initial portion of s with at most n characters.
--     if s.'length' is lower than n, only so much characters are returned.
--          
strhead :: StringJ a -> Int -> StringJ a

-- |  Constructs a strict 10-tuple. See remarks for 'strictTuple2'.   
strictTuple10 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> (a,b,c,d,e,f,g,h,i,j)

-- |  Constructs a strict 11-tuple. See remarks for 'strictTuple2'.   
strictTuple11 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> (a,b,c,d,e,f,g,h,i,j,k)

-- |  Constructs a strict 12-tuple. See remarks for 'strictTuple2'.   
strictTuple12 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> (a,b,c,d,e,f,g,h,i,j,k,l)

-- |  Constructs a strict 13-tuple. See remarks for 'strictTuple2'.   
strictTuple13 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> (a,b,c,d,e,f,g,h,i,j,k,l,m)

-- |  Constructs a strict 14-tuple. See remarks for 'strictTuple2'.   
strictTuple14 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n)

-- |  Constructs a strict 15-tuple. See remarks for 'strictTuple2'.   
strictTuple15 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)

-- |  Constructs a strict 16-tuple. See remarks for 'strictTuple2'.   
strictTuple16 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)

-- |  Constructs a strict 17-tuple. See remarks for 'strictTuple2'.   
strictTuple17 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)

-- |  Constructs a strict 18-tuple. See remarks for 'strictTuple2'.   
strictTuple18 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r)

-- |  Constructs a strict 19-tuple. See remarks for 'strictTuple2'.   
strictTuple19 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s)

-- |  * Constructs a strict tuple.
-- 
--  * The difference to '(,)' is that both argument values
--  * will be evaluated before the tuple is constructed. Thus:
--  * >fst (42; undefined) == undefined
--  * >fst (42, undefined) == 42
--  * *Implementation specific:* The compiler will rewrite @(a;b)@ as
--  * @(PreludeBase.strictTuple2 a b)@.
--       
strictTuple2 :: a -> b -> (a,b)

-- |  Constructs a strict 20-tuple. See remarks for 'strictTuple2'.   
strictTuple20 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t)

-- |  Constructs a strict 21-tuple. See remarks for 'strictTuple2'.   
strictTuple21 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u)

-- |  Constructs a strict 22-tuple. See remarks for 'strictTuple2'.   
strictTuple22 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v)

-- |  Constructs a strict 23-tuple. See remarks for 'strictTuple2'.   
strictTuple23 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w)

-- |  Constructs a strict 24-tuple. See remarks for 'strictTuple2'.   
strictTuple24 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x)

-- |  Constructs a strict 25-tuple. See remarks for 'strictTuple2'.   
strictTuple25 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y)

-- |  Constructs a strict 26-tuple. See remarks for 'strictTuple2'.   
strictTuple26 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z)

-- |  Constructs a strict 3-tuple. See remarks for 'strictTuple2'.   
strictTuple3 :: a -> b -> c -> (a,b,c)

-- |  Constructs a strict 4-tuple. See remarks for 'strictTuple2'.   
strictTuple4 :: a -> b -> c -> d -> (a,b,c,d)

-- |  Constructs a strict 5-tuple. See remarks for 'strictTuple2'.   
strictTuple5 :: a -> b -> c -> d -> e -> (a,b,c,d,e)

-- |  Constructs a strict 6-tuple. See remarks for 'strictTuple2'.   
strictTuple6 :: a -> b -> c -> d -> e -> f -> (a,b,c,d,e,f)

-- |  Constructs a strict 7-tuple. See remarks for 'strictTuple2'.   
strictTuple7 :: a -> b -> c -> d -> e -> f -> g -> (a,b,c,d,e,f,g)

-- |  Constructs a strict 8-tuple. See remarks for 'strictTuple2'.   
strictTuple8 :: a -> b -> c -> d -> e -> f -> g -> h -> (a,b,c,d,e,f,g,h)

-- |  Constructs a strict 9-tuple. See remarks for 'strictTuple2'.   
strictTuple9 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> (a,b,c,d,e,f,g,h,i)

-- |     @strtail s n@ returns a new string that is a substring of string _s_.
--     The substring begins with the character at the specified index
--     and extends to the end of _s_.
-- 
--     This uses the native method @substring@ of class @java.lang.String@. It
--     will throw an @IndexOutOfBoundsException@ if _n_ is negative or larger than
--     the length of _s_.
--      
strtail :: StringJ a -> Int -> StringJ a

-- |         Like 'String.replaceFirst', but replaces *all* substrings that match the pattern.
--          
substituteAll :: String -> Regex -> String -> String

-- |         Replaces the first subsequence of the input sequence that matches
--         the pattern with the given replacement string.
--  
--         This method scans the input sequence from the start
--         looking for a match of the pattern.
--         Characters that are not part of the match are appended directly
--         to the result string; the match is replaced in the result by the
--         replacement string. The replacement string may contain references
--         to captured subsequences.
--  
--         Note that backslashes (\\) and dollar signs ($) in the replacement
--         string may cause the results to be different than if it were
--         being treated as a literal replacement string.
--         Dollar signs may be treated as references to captured subsequences
--         as described above, and backslashes are used to escape
--         literal characters in the replacement string.
--  
--         For example
--         
--         > "zzzdogzzzdogzzz".replaceFirst  ´dog´ "cat" == "zzzcatzzzdogzzz"
--          
substituteFirst :: String -> Regex -> String -> String

-- |      @substr s start end@ returns the sub string of @s@ that starts
--      with the character at position @start@
--      and extends to the character at position @end-1@.
-- 
--     This uses the native method @substring@ of class @java.lang.String@. It
--     will throw an @IndexOutOfBoundsException@ if @start@ is negative or larger than
--     @end@ or if @end@ is greater than the length of @s@.
--       
substr :: StringJ a -> Int -> Int -> StringJ a

-- |  use @(subtract a)@ instead of @\\b -> b-a@ in sections   
subtract :: Num n => n -> n -> n

-- |  @succ e@ is the successor of @e@ or 'undefined' if there is no such successor.   
succ :: Enum e => e -> e

-- |  The sum of the numbers in a list, same as ('fold' ('+') 'zero')   
sum :: Num a => [a] -> a

-- |  The tail of a list-view, or 'undefined' if 'empty'   
tail :: ListView α => α β -> α β

-- |  take a number of initial elements   
take :: ListView α => Int -> α β -> α β

-- |     @takeWhile p xs@ takes leading elements from /xs/ while they satisfy the predicate /p/.
-- 
--     Example:
--     > takeWhile (<7) [1,2,3,9,4] == [1,2,3]
--          
takeWhile :: (a->Bool) -> [a] -> [a]

-- |      * The inverse of 'freeze' creates a value (an object) which can be passed
--      * to impure functions without compromising the frozen object passed as argument.
-- 
--      * One possibility to thaw an object is by cloning it.
-- 
--      * If 'thaw' is not implemented correctly, bad things may happen.
-- 
--           
thaw :: Freezable f => f -> f

-- |  Constructs an undefined value from a java exception and throws it.   
throw :: Throwable -> a

-- |  Deliberately throw an exception in the 'IO' monad.   
throwIO :: Throwable -> IO a

-- |  Deliberately throw an exception in the 'ST' monad.   
throwST :: Throwable -> ST s a

-- |      * @T.from i@ maps the 'Int' value @i@ to a value of @T@, such that
--      >   ord (T.from i) == i
--      * unless there is no value @e@ of @T@ so that @ord e == i@. In the
--      * latter case, the result is 'undefined'.
--           
toEnum :: Enum e => Int -> e

-- |  every integral number can be converted to a big 'Integer'   
toInteger :: Integral integ => integ -> Integer

-- |  converts the value to a list   
toList :: ListSource α => α β -> [β]

-- |  Unload an immutable array to a list.   
-- 
--  The non-null elements become 'Just' values, the @null@s translate to 'Nothing'   
toMaybeList :: JArray α -> [Maybe α]

-- |  unsafe trace, returns always *false* and can thus be used like
--     
--     > fun x y
--     >    | trace   ("x is " ++ show x) = undefined
--     >    | traceLn ("y is " ++ show y) = undefined
--     >    | otherwise = ......
--     
--     Note that this imposes strictness on the traced data.
--          
trace :: String -> Bool

-- |  same as 'trace' but appends a line break    
traceLn :: String -> Bool

-- |  warning: use @stderr.print@ instead           
-- 
--  print a 'String' to the standard error stream   
traceStr :: String -> IO ()

-- |  warning: use @stderr.println@ instead   
-- 
--  print a 'String' to the standard error stream and append a new line.   
traceStrLn :: String -> IO ()

-- |     Make sure that exceptions thrown during construction of an action can be catched.
--     See 'catch' for an explanation.
--     
--     Example:
--     
--     > try println (head []) `catch` (\u::Undefined -> println u.catched)
--     
--     should print:
--     
--     > frege.runtime.Undefined: Prelude.head []
--     
--     'try' does work for unary functions only. 
--     To be safe with functions taking more actions, use:
--     
--     > return a >>= (\a -> return b >>= (\b -> f a b))
--          
try :: Monad c => (b->c a) -> b -> c a

-- |  @unJust Nothing@ is 'undefined' whereas @unJust (Just a)@ is @a@   
unJust :: Maybe a -> a

-- |  split the input stream in head and tail   
uncons :: ListView α => α β -> Maybe (β,α β)

-- |  Passes the elements of a 2-tuple as arguments to a function.   
uncurry :: (b->c->a) -> (b,c) -> a

-- |  Like '&&', but second argument is lazy.
--     The @`und`@ operator has the same precedence and arity as '&&'.
--     The definition is
--     > a `und` b = if a then b     else false
--     This should really be named _and_, but Haskell 2010 uses this already for lists.
--     Hence we use the german word _und_.
--          
und :: Bool -> Bool -> Bool

-- |  This is the standard undefined value.   
undefined :: u

-- |  opposite of 'when'      
unless :: Monad a => Bool -> a () -> a ()

-- |  'unlines' is an inverse operation to 'lines'.   
-- 
--   It joins lines, after appending a terminating newline to each.   
unlines :: [String] -> String

-- |  Eagerly converts a 'String' to a list.   
unpacked :: String -> [Char]

-- |  'unwords' is an inverse operation to 'words'.   
-- 
--  It joins words with separating spaces.   
unwords :: [String] -> String

-- |     'unzip' turns a list of tuples into a tuple of lists.
--     It is the opposite of 'zip' and the following holds for genuine lists
--     > (curry zip @ unzip) xs == xs
--     But note that
--     > (unzip @ curry zip) (as, bs) == (as,bs)
--     will only hold if @length as == length bs@
--          
unzip :: [(b,a)] -> ([b],[a])

-- |  'unzip3' unzips a list of triples and returns a triple of lists.   
unzip3 :: [(c,b,a)] -> ([c],[b],[a])

-- |  * @using f@ applies a projection function _f_ on both sides of '=='.
--  * Example usage:
--  * > uniqBy (using fst) [(1, 1), (2, 2), (2, 3), (3,4), (2,5)]
--       
using :: Eq a => (b->a) -> b -> b -> Bool

-- |  discard or ignore result of evaluation, such as the return value of an 'IO' action.   
void :: Functor a => a b -> a ()

-- |     @when condition monadic@ returns /action/ of type @Monad m => m ()@
--     if /condition/ is true, otherwise 'return' '()'.
--      
when :: Monad a => Bool -> a () -> a ()


withReader :: (e -> r) -> (r -> a) -> e -> a

-- |  splits a 'String' on non empty sequences of spaces  and returns a list of 'String's   
words :: String -> [String]

-- |  Writes the 'String' given as second argument to the file whose name is given as the first argument.   
-- 
--  After completion, the file will be closed.   
writeFile :: String -> String -> IO ()

-- |  assign another value to the reference    
writeIORef :: Mutable s (Ref a) -> a -> ST s ()

-- |  the number 0 in the instantiated type   
zero :: Num n => n

-- |     @zip as bs@ builds a list of tuples of corresponding elements of /as/ and /bs/.
--     Trailing elements of the longer list are ignored.
--     > zip (1,2,3) "ab" = [(1, "a"), (2, "b")]
--          
zip :: [b] -> [a] -> [(b,a)]

-- |  'zip3' zips 3 lists in the same way as 'zip' does it.   
zip3 :: [c] -> [b] -> [a] -> [(c,b,a)]

-- |     @zipWith f xs ys@ zips two lists with function _f_ instead of the standard '(,)' that
--     is used by 'zip'
--          
zipWith :: (b->c->a) -> [b] -> [c] -> [a]

-- |  'zipWith3' _f_ zips 3 lists with function _f_ instead of the standard '(,,)' that is used by 'zip3'   
zipWith3 :: (a->b->d->c) -> [a] -> [b] -> [d] -> [c]

-- |  The 'zipWithM' function generalizes 'zipWith' to arbitrary monads.   
zipWithM :: Monad c => (a->b->c d) -> [a] -> [b] -> c [d]

-- |  'zipWithM_' is the extension of 'zipWithM' which ignores the final result.   
zipWithM_ :: Monad d => (b->a->d c) -> [b] -> [a] -> d ()

-- |     The Java @||@ operator on booleans.
--     
--     Note that since this is a
--     native function, the second argument appears strict to the compiler
--     when in fact it is lazy at the Java level.
--     
--     This can lead to inconsistent results in cases where the wrong strictness of
--     the second argument propagates to arguments of the function that contains 
--     an application of '||'. (The documentation for '&&' has an example.)
--     
--     See 'oder' for an alternative
--          
(||) :: Bool -> Bool -> Bool

-- |  * >string ~ regex
--  * @true@ if _string_ matches _regex_, @false@ otherwise
--       
(~) :: String -> Regex -> Bool

-- |     > ("string" ~~ ´r..´) == Just "rin"
--     Tries a match and returns @Just x@ where
--     _x_ is the matched substring or @Nothing@ if there was no match.
--      
(~~) :: String -> Regex -> Maybe String

-- |     > "cats and dogs are not concatenated." ~~* ´cat|dog´
--     Matches the string with the regex and returns a list of all matches.
--     The example gives:
--     > ["cat", "dog", "cat"]
--      
(~~*) :: String -> Regex -> [String]

-- |  * > string ~~~ regex
--  * Matches _string_ with _regex_ and returns a function
--  * that can be used to extract the matched part of the string and the
--  * captured substrings.
--  * >   let f = "frege" ~~~ ´(..).(..)´
--  * >   in [ f i | i <- 0..3 ]
--  * yields
--  * >[Just "frege", Just "fr", Just "ge", Nothing]
--      
(~~~) :: String -> Regex -> Int -> Maybe String

-- |  morphism composition   
(•) :: Semigroupoid.Semigroupoid f => f b c -> f a b -> f a c



-- | 
module frege.Version

version :: String



-- |  type class for 'Arrow's   
module frege.control.Arrow
-- |     Basic arrow definitions, based on
--     Generalising Monads to Arrows, by John Hughes,
--     Science of Computer Programming, pp67-111, May 2000.
--      
class Arrow


instance Arrow.Arrow ->

-- |  Lift a function to an arrow.   
arr :: Arrow.Arrow a => (b -> c) -> a b c



-- |  Introduction of the type class for 'http://en.wikipedia.org/wiki/Category_(mathematics) categories'.   
module frege.control.Category
-- |     A category is a  'Semigroupoid' with the following additional properties:
--     
--     - For every object @A@, there exists a mophism @id(A): A -> A@ called the
--     _identity morphism for A_, such that for every morphism @f: A -> B@ we have
--     > id(B) • f = f = f • id(A)   
--      
class Category

-- |     The category of Frege functions
--      
instance Category.Category ->

-- |  the identity morphism   
id :: Category.Category f => f a a



-- |  type class 'CombineIn', which provides the '&&&' operator   
module frege.control.CombineIn
-- |       Send the input to both argument semigroupoids and combine
--       their output.
--        
(&&&) :: CombineIn.CombineIn f => f a b -> f a c -> f a (b,c)


class CombineIn


instance CombineIn.CombineIn ->



-- |     Support for concurrency.
--     
--     Concurrency in Frege comes in 2 flavors. 
--     The first is through 'Thread's, which are,
--     unlike in Haskell, _OS threads_.
--   
--     The second possibility is to use a thread pool and an executor service 
--     one can submit tasks to. But note that blocking asynchronous tasks,
--     unlike Haskell green threads, will block an OS thread on blocking actions.  
--      
module frege.control.Concurrent
-- |  A thread safe, shared variable, that is either full or empty.   
-- 
--  Technically, this is just a 'BlockingQueue' restricted to length 1.       
data MVar

-- |  Run a 'IO' action asynchronously and return the result in a 'MVar'   
async :: IO a -> IO (Concurrent.MVar (Exception | a))

-- |  Run the 'IO' action asynchronously in an 'ExecutorService'   
-- 
--  This is not suitable for not-ending processes!   
-- 
--  The executor service may manage a fixed small number of concurrent threads only.   
forkIO :: IO () -> IO ()

-- |  Create and start a new OS 'Thread' that runs an 'IO' action.    
forkOS :: IO () -> IO Thread

-- |  create an empty 'MVar'   
newEmptyMVar :: IO (Concurrent.MVar a)

-- |  create a 'MVar' filled with a value   
newMVar :: a -> IO (Concurrent.MVar a)

-- |  put a value in a 'MVar', blocks if full   
putMVar :: Concurrent.MVar a -> a -> IO ()

-- |  Shutdwon the 'ExecutorService'   
shutdown :: IO ()

-- |  take a value from a 'MVar', blocks if empty            
takeMVar :: Concurrent.MVar a -> IO a

-- |  put a value in a 'MVar', returns false if already full.   
tryPutMVar :: Concurrent.MVar a -> a -> IO Bool

-- |  get the value from a 'MVar', return 'Nothing' when empty   
tryTakeMVar :: Concurrent.MVar a -> IO (Maybe a)



-- |     This module provides an overloaded function, 'deepseq', for fully
--     evaluating data structures (that is, evaluating to \"Normal Form\").
-- 
--     'deepseq' differs from 'seq' as it traverses data structures deeply,
--     for example, 'seq' will evaluate only to the first constructor in
--     the list:
-- 
--     > > [1,2,undefined] `seq` 3
--     > 3
-- 
--     While 'deepseq' will force evaluation of all the list elements:
-- 
--     > > [1,2,undefined] `deepseq` 3
--     > frege.runtime.Undefined: undefined
-- 
--     Another common use is to ensure any exceptions hidden within lazy
--     fields of a data structure do not leak outside the scope of the
--     exception handler, or to force evaluation of a data structure in one
--     thread, before passing to another thread (preventing work moving to
--     the wrong threads).
--      
module frege.control.DeepSeq
-- |  the deep analogue of '$!'.  In the expression @f $!! x@, @x@ is   
-- 
--  fully evaluated before the function @f@ is applied to it.   
-- 
--    
($!!) :: DeepSeq.NFData α => (α -> β) -> α -> β

-- | -------------------------------------------------------------------------   
instance (DeepSeq.NFData a,DeepSeq.NFData b) => DeepSeq.NFData (a,b)


instance (DeepSeq.NFData a,DeepSeq.NFData b,DeepSeq.NFData c) => DeepSeq.NFData (a,b,c)


instance (DeepSeq.NFData a,DeepSeq.NFData b,DeepSeq.NFData c,DeepSeq.NFData d) => DeepSeq.NFData (a,b,c,d)


instance (DeepSeq.NFData a1,DeepSeq.NFData a2,DeepSeq.NFData a3,DeepSeq.NFData a4,DeepSeq.NFData a5) => DeepSeq.NFData (a1,a2,a3,a4,a5)


instance (DeepSeq.NFData a1,DeepSeq.NFData a2,DeepSeq.NFData a3,DeepSeq.NFData a4,DeepSeq.NFData a5,DeepSeq.NFData a6) => DeepSeq.NFData (a1,a2,a3,a4,a5,a6)


instance (DeepSeq.NFData a1,DeepSeq.NFData a2,DeepSeq.NFData a3,DeepSeq.NFData a4,DeepSeq.NFData a5,DeepSeq.NFData a6,DeepSeq.NFData a7) => DeepSeq.NFData (a1,a2,a3,a4,a5,a6,a7)


instance (DeepSeq.NFData a1,DeepSeq.NFData a2,DeepSeq.NFData a3,DeepSeq.NFData a4,DeepSeq.NFData a5,DeepSeq.NFData a6,DeepSeq.NFData a7,DeepSeq.NFData a8) => DeepSeq.NFData (a1,a2,a3,a4,a5,a6,a7,a8)


instance (DeepSeq.NFData a1,DeepSeq.NFData a2,DeepSeq.NFData a3,DeepSeq.NFData a4,DeepSeq.NFData a5,DeepSeq.NFData a6,DeepSeq.NFData a7,DeepSeq.NFData a8,DeepSeq.NFData a9) => DeepSeq.NFData (a1,a2,a3,a4,a5,a6,a7,a8,a9)


instance (DeepSeq.NFData α,DeepSeq.NFData β) => DeepSeq.NFData (α | β)


instance DeepSeq.NFData ()

-- |  This instance is for convenience and consistency with 'seq'.   
-- 
--  This assumes that WHNF is equivalent to NF for functions.   
-- 
--    
instance DeepSeq.NFData (a->b)


instance DeepSeq.NFData Bool


instance DeepSeq.NFData Char


instance DeepSeq.NFData Double


instance DeepSeq.NFData Float


instance DeepSeq.NFData Int


instance DeepSeq.NFData Integer


instance DeepSeq.NFData Long


instance DeepSeq.NFData String


instance DeepSeq.NFData α => DeepSeq.NFData (Maybe α)


instance DeepSeq.NFData α => DeepSeq.NFData (Tree.Tree α)


instance DeepSeq.NFData α => DeepSeq.NFData [α]

-- |  A class of types that can be fully evaluated.   
class NFData

-- |     Fully evaluates @a@ and returns @b@.
-- 
--     'deepseq': fully evaluates the first argument, before returning the
--     second.
-- 
--     The name 'deepseq' is used to illustrate the relationship to 'seq':
--     where 'seq' is shallow in the sense that it only evaluates the top
--     level of its argument, 'deepseq' traverses the entire data structure
--     evaluating it completely.
-- 
--     'deepseq' can be useful for forcing pending exceptions,
--     eradicating space leaks, or forcing lazy I/O to happen.  It is
--     also useful in conjunction with parallel Strategies (see the
--     @parallel@ package).
--      
deepseq :: DeepSeq.NFData α => α -> β -> β

-- |     a variant of 'deepseq' that is useful in some circumstances:
-- 
--     > force x = x `deepseq` x
-- 
--     @force x@ fully evaluates @x@, and then returns it.  Note that
--     @force x@ only performs evaluation when the value of @force x@
--     itself is demanded, so essentially it turns shallow evaluation into
--     deep evaluation.
--      
force :: DeepSeq.NFData α => α -> α

-- |  'rnf' should reduce its argument to normal form (that is, fully   
-- 
--  evaluate all sub-components), and then return '()'.   
rnf :: DeepSeq.NFData α => α -> ()



-- |  type class 'First' with 'first' operation   
module frege.control.First

class First


instance First.First ->

-- |       Send the first component of the input through the argument
--       tensor, and copy the rest unchanged to the output.
--        
first :: First.First f => f a b -> f (a,c) (b,c)



-- |  type class 'Second' with 'second' operation   
module frege.control.Second

class Second


instance Second.Second ->

-- |       Send the second component of the input through the argument
--       tensor, and copy the rest unchanged to the output.
--        
second :: Second.Second f => f c d -> f (a,c) (a,d)



-- |  Introduction of the 'http://en.wikipedia.org/wiki/Semigroupoid semigroupoid'.   
module frege.control.Semigroupoid
-- |  Right-to-left composition. This is the same a ordinary composition with '•'.   
(<<<) :: Semigroupoid.Semigroupoid f => f b c -> f a b -> f a c

-- |  Left-to-right composition   
(>>>) :: Semigroupoid.Semigroupoid f => f a b -> f b c -> f a c

-- |     Formally, a semigroupoid consists of 
--     - a set of things called objects.
--     - for every two objects A and B a set Mor(A,B) of things called morphisms from A to B. 
--       If @f@ is in Mor(A,B), we write @f : A → B@.
--     - for every three objects A, B and C a binary operation 
--       @Mor(A,B) × Mor(B,C) → Mor(A,C)@ called *composition* of morphisms. 
--       The composition of @f : A → B@ and @g : B → C@ is written as @g • f@.
--     
--     such that the following axiom holds:
--     
--     [associativity] if @f : A → B@, @g : B → C@ and @h : C → D@ then @h • (g • f) = (h • g) • f@.
-- -     
class Semigroupoid

-- |  The semigroupoid of Frege values where morphisms are functions.   
instance Semigroupoid.Semigroupoid ->

-- |  morphism composition   
(•) :: Semigroupoid.Semigroupoid f => f b c -> f a b -> f a c



-- |  The 'Tensor' type class with '***' operation.   
module frege.control.Tensor
-- |       Split the input between the two argument semigroupoids and combine
--       their output.  Note that this is in general not a functor.
--        
(***) :: Tensor.Tensor f => f a b -> f c d -> f (a,c) (b,d)


class Tensor


instance Tensor.Tensor ->



-- |  Kleisli oprators, 'Arrow' and 'Monad' instances   
module frege.control.arrow.Kleisli

data Kleisli


Kleisli :: (a -> m b) -> Kleisli.Kleisli m a b


instance Monad m => Arrow.Arrow (Kleisli.Kleisli m)


instance Monad m => Monad (Kleisli.Kleisli m a)



-- |  'Reader' monad and monad transformer, based on 'Kleisli'   
module frege.control.monad.Reader

type Reader = Kleisli.Kleisli Identity.Identity a b


type ReaderT = Kleisli.Kleisli m a b


ask :: Monad m => Kleisli.Kleisli m e e



-- |  The strict 'State' 'Monad'   
module frege.control.monad.State

instance Monad (State.State s)


instance Monad m => Monad (State.StateT s m)


instance MonadAlt m => MonadAlt (State.StateT s m)


instance MonadIO.MonadIO m => MonadIO.MonadIO (State.StateT s m)


instance MonadPlus m => MonadPlus (State.StateT s m)


instance MonadTrans.MonadTrans (State.StateT s)

-- |     @State s a@ is an abstract data type that resembles a stateful computation
--     with State _s_ and result _a_,
--     i.e. functions of type @s -> (a, s)@
--     where the State is immutable.
--       
data State

-- |  > StateT s m a   
-- 
--  A stateful computation that transforms an inner 'Monad' _m_   
data StateT


evalState :: State.State a b -> a -> b


evalStateT :: Monad m => State.StateT s m v -> s -> m v


execState :: State.State b a -> b -> b


execStateT :: Monad m => State.StateT s m v -> s -> m s


promote :: Monad a => State.State b c -> State.StateT b a c

-- |  run a stateful computation   
runState :: State.State b a -> b -> (a,b)


runStateT :: Monad m => State.StateT s m v -> s -> m (v,s)



-- |  'Monad' transformer for 'Either'   
module frege.control.monad.trans.EitherT

instance (Monad m,Monoid.Monoid a) => Monoid.Monoid (EitherT.EitherT l m a)


data EitherT


EitherT :: m (l | a) -> EitherT.EitherT l m a


instance Functor f => Functor (EitherT.EitherT l f)


instance Monad m => Monad (EitherT.EitherT l m)


instance MonadAlt m => MonadAlt (EitherT.EitherT l m)


instance MonadIO.MonadIO m => MonadIO.MonadIO (EitherT.EitherT l m)


instance MonadPlus m => MonadPlus (EitherT.EitherT l m)


instance MonadTrans.MonadTrans (EitherT.EitherT l)


left :: Monad m => l -> EitherT.EitherT l m a



-- |  'Monad' transformer for 'Maybe'   
module frege.control.monad.trans.MaybeT

instance Functor m => Functor (MaybeT.MaybeT m)

-- |     The parameterizable maybe monad, obtained by composing an arbitrary
--     monad with the 'Maybe' monad.
--     
--     Computations are actions that may produce a value or fail.
--     
--     The 'return' function yields a successful computation, while (>>=)
--     sequences two subcomputations, failing on the first error.
--      
data MaybeT


MaybeT :: m (Maybe a) -> MaybeT.MaybeT m a


instance Monad m => Alt (MaybeT.MaybeT m)


instance Monad m => Monad (MaybeT.MaybeT m)


instance Monad m => MonadFail (MaybeT.MaybeT m)


instance Monad m => MonadPlus (MaybeT.MaybeT m)


instance MonadIO.MonadIO m => MonadIO.MonadIO (MaybeT.MaybeT m)


instance MonadTrans.MonadTrans MaybeT.MaybeT

-- |  Transform the computation inside a @MaybeT@.   
mapMaybeT :: (m (Maybe a) -> n (Maybe b)) -> MaybeT.MaybeT m a -> MaybeT.MaybeT n b



-- |      Monads in which 'IO' computations may be embedded.   
module frege.control.monad.trans.MonadIO
-- |     Monads in which 'IO' computations may be embedded.
--     
--     Any monad built by applying a sequence of monad transformers to the
--     'IO' monad will be an instance of this class.
--     
--     Instances should satisfy the following laws, which state that 'liftIO'
--     is a transformer of monads:
--     
--     > liftIO . return = return
--     
--     > liftIO (m >>= f) = liftIO m >>= (liftIO .  f)
-- 
--      
class MonadIO


instance MonadIO.MonadIO IO

-- |  Lift a computation from the 'IO' monad.   
liftIO :: MonadIO.MonadIO m => IO a -> m a



-- |  provide utility function 'lift' for 'Monad' transformers   
module frege.control.monad.trans.MonadTrans

class MonadTrans

-- |  Lift a computation from the argument monad to the constructed monad.   
lift :: (MonadTrans.MonadTrans t,Monad m) => m a -> t m a



-- | 
module frege.data.Array
-- |  The value at the given index in an array.   
(!!) :: Ix.Ix i => Array.Array i e -> i -> e


instance (Ix.Ix a,Show a,Show b) => Show (Array.Array a b)


instance (Ix.Ix i,Eq e) => Eq (Array.Array i e)


instance (Ix.Ix i,Ord e) => Ord (Array.Array i e)

-- |  Constructs an array identical to the first argument except that it has
--  been updated by the associations in the right argument.
--  For example, if @m@ is a 1-origin, @n@ by @n@ matrix, then
-- 
--  > m//[((i,i), 0) | i <- [1..n]]
-- 
--  is the same matrix, except with the diagonal zeroed.
-- 
--  Repeated indices in the association list are handled as for 'array'.
--      
(//) :: Ix.Ix i => Array.Array i e -> [(i,e)] -> Array.Array i e


AE :: () -> a -> Array.AElem a

-- |  Wrapper layer that allows lazy semantics for array elements what is not possible when using Frege's
--  types that correspond to Java primitive types.
--       
data AElem

-- |  The type of immutable non-strict arrays with indices in @i@ and elements in @e@.   
data Array


Array :: i -> i -> Int -> JArray (Array.AElem e) -> Array.Array i e


instance ArrayElement (Array.AElem a)


instance Eq a => Eq (Array.AElem a)


instance Ix.Ix i => Functor (Array.Array i)

-- |  Mutable, non-strict arrays in the 'ST' monad.   
data STArray


STArray :: i -> i -> Int -> ArrayOf s (Array.AElem e) -> Array.STArray s i e

-- |  @'accum' f@ takes an array and an association list and accumulates
--  pairs from the list into the array with the accumulating function @f@.
--  Thus 'accumArray' can be defined using 'accum':
-- 
--  > accumArray f z b = accum f (array b [(i, z) | i <- range b])
--      
accum :: Ix.Ix i => (e -> a -> e) -> Array.Array i e -> [(i,a)] -> Array.Array i e

-- |  The 'accumArray' function deals with repeated indices in the association
--  list using an /accumulating function/ which combines the values of
--  associations with the same index.
--  For example, given a list of values of some index type, @hist@
--  produces a histogram of the number of occurrences of each index within
--  a specified range:
-- 
--  > hist :: (Ix a, Num b) => (a,a) -> [a] -> Array a b
--  > hist bnds is = accumArray (+) 0 bnds [(i, 1) | i<-is, Ix.inRange bnds i]
-- 
--  If the accumulating function is strict, then 'accumArray' is strict in
--  the values, as well as the indices, in the association list.  Thus,
--  unlike ordinary arrays built with 'array', accumulated arrays should
--  not in general be recursive.
--      
accumArray :: Ix.Ix i => (e -> a -> e) -> e -> (i,i) -> [(i,a)] -> Array.Array i e

-- |  Map elements with function   
amap :: Ix.Ix i => (a -> b) -> Array.Array i a -> Array.Array i b


appPrec :: Int


appPrec1 :: Int

-- |  Construct an array with the specified bounds and containing values
--  for given indices within these bounds.
-- 
--  If some index is present more then once in association list then
--  value will be the last association with that index in the list.
--  If some index is absent in association list then value for that
--  index will (lazily) evaluate to the bottom.
-- 
--  Bounds argument and indices in association list are strictly
--  evaluated in order to validate indices.
--       
array :: Ix.Ix i => (i,i) -> [(i,e)] -> Array.Array i e

-- |  A left fold over the elements with no starting value.   
foldl1Elems :: Ix.Ix i => (a -> a -> a) -> Array.Array i a -> a

-- |  A left fold over the elements.   
foldlElems :: Ix.Ix i => (b -> a -> b) -> b -> Array.Array i a -> b

-- |  A strict left fold over the elements.   
foldlElems' :: Ix.Ix i => (b -> a -> b) -> b -> Array.Array i a -> b

-- |  A right fold over the elements with no starting value.   
foldr1Elems :: Ix.Ix i => (a -> a -> a) -> Array.Array i a -> a

-- |  A right fold over the elements.   
foldrElems :: Ix.Ix i => (a -> b -> b) -> b -> Array.Array i a -> b

-- |  A strict right fold over the elements.   
foldrElems' :: Ix.Ix i => (a -> b -> b) -> b -> Array.Array i a -> b

-- |  Create immutable copy of an array   
freezeSTArray :: Ix.Ix i => Array.STArray s i e -> ST s (Array.Array i e)

-- | 'ixmap' allows for transformations on array indices.
-- It may be thought of as providing function composition on the right
-- with the mapping that the original array embodies.
-- 
-- A similar transformation of array values may be achieved using 'fmap'
-- from the 'Array' instance of the 'Functor' class.
--      
ixmap :: (Ix.Ix i,Ix.Ix j) => (i,i) -> (i -> j) -> Array.Array j e -> Array.Array i e

-- |  Construct an array from a pair of bounds and a list of values in index order.   
listArray :: Ix.Ix i => (i,i) -> [e] -> Array.Array i e

-- |  Create mutable copy of an array   
thawSTArray :: Ix.Ix i => Array.Array i e -> ST s (Array.STArray s i e)



-- |  Fast sets for small integers and enumerations, implemented as bit operations on 'Long'   
--  There may be at most 64 elements, due to the bit size of 'Long'.   
module frege.data.Bits

instance (Show a,Enum a) => Show (Bits.BitSet a)

-- |  Bitwise \"and\"   
(.&.) :: Bits.Bits a => a -> a -> a

-- |  Bitwise \"xor\"   
(.^.) :: Bits.Bits a => a -> a -> a

-- |  Bitwise \"or\"   
(.|.) :: Bits.Bits a => a -> a -> a


data BitSet


BitSet :: Long -> Bits.BitSet e

-- | The 'Bits' class defines bitwise operations over integral types.
-- 
-- Bits are numbered from 0 with bit 0 being the least
--   significant bit.
-- 
-- Minimal complete definition: '.&.', '.|.', '.^.', 'complement',
-- ('shift' or ('shiftL' and 'shiftR')), ('rotate' or ('rotateL' and 'rotateR')),
-- 'bitSize' and 'isSigned'.
--      
class Bits


instance Bits.Bits Int


instance Bits.Bits Integer


instance Bits.Bits Long


instance Eq (Bits.BitSet a)


instance ListEmpty Bits.BitSet


instance Monoid.Monoid (Bits.BitSet a)


instance Ord (Bits.BitSet a)

-- |  @bit i@ is a value with the @i@th bit set   
bit :: Bits.Bits a => Int -> a

-- |         Returns the number of one-bits in the two's complement binary representation of the specified value.
-- 
--         Also known as "population count" or "Hamming Weight" of a bit string.
-- 
--         See also 'http://en.wikipedia.org/wiki/Hamming_weight Hamming Weight'.
-- 
--          
bitCount :: Bits.Bits a => a -> Int

-- |  Return the number of bits in the type of the argument.  The actual
--         value of the argument is ignored.  The function 'bitSize' is
--         undefined for types that do not have a fixed bitsize, like 'Integer'.
--              
bitSize :: Bits.Bits a => a -> Int

-- |  @x \`clearBit\` i@ is the same as @x .&. complement (bit i)@   
clearBit :: Bits.Bits a => a -> Int -> a

-- |  Reverse all the bits in the argument      
complement :: Bits.Bits a => a -> a

-- |  @x \`complementBit\` i@ is the same as @x \`.^.\` bit i@   
complementBit :: Bits.Bits a => a -> Int -> a

-- |  Return 'true' if the argument is a signed type.  The actual
--         value of the argument is ignored      
isSigned :: Bits.Bits a => a -> Bool

-- |         Returns the number of one-bits in the two's complement binary representation of the specified value.
-- 
--         Also known as "population count" or "Hamming Weight" of a bit string.
-- 
--         See also 'http://en.wikipedia.org/wiki/Hamming_weight Hamming Weight'.
-- 
--          
popCount :: Bits.Bits a => a -> Int

-- |  @'rotate' x i@ rotates @x@ left by @i@ bits if @i@ is positive,
--         or right by @-i@ bits otherwise.
-- 
--         For unbounded types like 'Integer', 'rotate' is equivalent to 'shift'.
-- 
--         An instance can define either this unified 'rotate' or 'rotateL' and
--         'rotateR', depending on which is more convenient for the type in
--         question.      
rotate :: Bits.Bits a => a -> Int -> a

-- |  Rotate the argument left by the specified number of bits
--         (which must be non-negative).
-- 
--         An instance can define either this and 'rotateR' or the unified
--         'rotate', depending on which is more convenient for the type in
--         question.      
rotateL :: Bits.Bits a => a -> Int -> a

-- |  Rotate the argument right by the specified number of bits
--         (which must be non-negative).
-- 
--         An instance can define either this and 'rotateL' or the unified
--         'rotate', depending on which is more convenient for the type in
--         question.      
rotateR :: Bits.Bits a => a -> Int -> a

-- |  @x \`setBit\` i@ is the same as @x .|. bit i@   
setBit :: Bits.Bits a => a -> Int -> a

-- |  @'shift' x i@ shifts @x@ left by @i@ bits if @i@ is positive,
--         or right by @-i@ bits otherwise.
--         Right shifts perform sign extension on signed number types;
--         i.e. they fill the top bits with 1 if the @x@ is negative
--         and with 0 otherwise.
-- 
--         An instance can define either this unified 'shift' or 'shiftL' and
--         'shiftR', depending on which is more convenient for the type in
--         question.      
shift :: Bits.Bits a => a -> Int -> a

-- |  Shift the argument left by the specified number of bits
--         (which must be non-negative).
-- 
--         An instance can define either this and 'shiftR' or the unified
--         'shift', depending on which is more convenient for the type in
--         question.      
shiftL :: Bits.Bits a => a -> Int -> a

-- |  Shift the first argument right by the specified number of bits
--         (which must be non-negative).
--         Right shifts perform sign extension on signed number types;
--         i.e. they fill the top bits with 1 if the @x@ is negative
--         and with 0 otherwise.
-- 
--         An instance can define either this and 'shiftL' or the unified
--         'shift', depending on which is more convenient for the type in
--         question.      
shiftR :: Bits.Bits a => a -> Int -> a

-- |  Return 'true' if the @n@th bit of the argument is 1   
testBit :: Bits.Bits a => a -> Int -> Bool

-- |  Unsigned shift right   
ushiftR :: Bits.Bits a => a -> Int -> a

-- |  Haskell compatibility. Same as `.^.`   
xor :: Bits.Bits a => a -> a -> a



-- |  Haskell compatibility   
module frege.data.Char

instance ArrayElement Char.GeneralCategory


instance Bounded Char.GeneralCategory


CATEGORY17 :: Char.GeneralCategory


COMBINING_SPACING_MARK :: Char.GeneralCategory


CONNECTOR_PUNCTUATION :: Char.GeneralCategory


CONTROL :: Char.GeneralCategory


CURRENCY_SYMBOL :: Char.GeneralCategory


DASH_PUNCTUATION :: Char.GeneralCategory


DECIMAL_DIGIT_NUMBER :: Char.GeneralCategory


ENCLOSING_MARK :: Char.GeneralCategory


END_PUNCTUATION :: Char.GeneralCategory


instance Enum Char.GeneralCategory


FINAL_QUOTE_PUNCTUATION :: Char.GeneralCategory


FORMAT :: Char.GeneralCategory

-- |  The general categories for unicode characters and code points.   
data GeneralCategory


INITIAL_QUOTE_PUNCTUATION :: Char.GeneralCategory


LETTER_NUMBER :: Char.GeneralCategory


LINE_SEPARATOR :: Char.GeneralCategory


LOWERCASE_LETTER :: Char.GeneralCategory


MATH_SYMBOL :: Char.GeneralCategory


MODIFIER_LETTER :: Char.GeneralCategory


MODIFIER_SYMBOL :: Char.GeneralCategory


NON_SPACING_MARK :: Char.GeneralCategory


OTHER_LETTER :: Char.GeneralCategory


OTHER_NUMBER :: Char.GeneralCategory


OTHER_PUNCTUATION :: Char.GeneralCategory


OTHER_SYMBOL :: Char.GeneralCategory


PARAGRAPH_SEPARATOR :: Char.GeneralCategory


PRIVATE_USE :: Char.GeneralCategory


SPACE_SEPARATOR :: Char.GeneralCategory


START_PUNCTUATION :: Char.GeneralCategory


SURROGATE :: Char.GeneralCategory


instance Show Char.GeneralCategory


TITLECASE_LETTER :: Char.GeneralCategory


UNASSIGNED :: Char.GeneralCategory


UPPERCASE_LETTER :: Char.GeneralCategory


chr :: Int -> Char

-- |  Convert a hexadecimal digit to its 'Int' value.   
-- 
--  For different number bases, see 'Char.digit'   
digitToInt :: Char -> Int

-- |  return the general category of a 'Char'   
generalCategory :: Char -> Char.GeneralCategory

-- |  Convert an 'Int' in the range 0..15 to the corresponding hexadecimal digit.   
-- 
--  For other number bases than 16, see 'Char.forDigit'   
intToDigit :: Int -> Char


isAlpha :: ω


isAlphaNum :: ω

-- |  Check if the argument is from the ASCII character set.   
isAscii :: Char -> Bool

-- |  Check if the argument is an ASCII lower case letter.   
isAsciiLower :: Char -> Bool

-- |  Check if the argument is an ASCII upper case letter.   
isAsciiUpper :: Char -> Bool

-- |  Check if the argument is a control character.   
isControl :: Char -> Bool


isDigit :: ω

-- |  Check if the argument is a digit, in the range \'a\'..\'f\' or  in the range \'A\'..\'F\'   
isHexDigit :: Char -> Bool

-- |  Check if the argument is from the Latin1 character set.   
isLatin1 :: Char -> Bool


isLower :: ω

-- |  Check if the 'generalCategory' of the argument is one of 'NON_SPACING_MARK', 'ENCLOSING_MARK' or 'COMBINING_SPACING_MARK'   
isMark :: Char -> Bool

-- |  Check if the 'generalCategory' of the argument is one of 'DECIMAL_DIGIT_NUMBER', 'LETTER_NUMBER' or 'OTHER_NUMBER'   
isNumber :: Char -> Bool

-- |  Check if the argument is in the range \'0\'..\'7\'   
isOctDigit :: Char -> Bool

-- |  Check if a character is printable.   
-- 
--  True for a defined character that is neither a surrogate character nor a control character.     
isPrint :: Char -> Bool

-- |     Check if the 'generalCategory' of the argument is one of 'DASH_PUNCTUATION',
--     'START_PUNCTUATION', 'END_PUNCTUATION', 'CONNECTOR_PUNCTUATION' or 'OTHER_PUNCTUATION'.
--      
isPunctuation :: Char -> Bool

-- |     Check if the 'generalCategory' of the argument is one of 'SPACE_SEPARATOR',
--     'LINE_SEPARATOR' or 'PARAGRAPH_SEPARATOR'.
--      
isSeparator :: Char -> Bool


isSpace :: ω

-- |     Check if the 'generalCategory' of the argument is one of 'MATH_SYMBOL', 
--     'CURRENCY_SYMBOL', 'MODIFIER_SYMBOL' or 'OTHER_SYMBOL'.
--      
isSymbol :: Char -> Bool


isUpper :: ω

-- |      * @c.ord@ is the ordinal (integer) value of the character @c@.
--      * It holds: @c.ord.char@ == @c@, see 'Int.char'.
--      * (But note that @i.char.ord@ is not necessarily @i@)
--           
ord :: Char -> Int

-- |  The lowercase equivalent of the character, if any; otherwise, the character itself.   
toLower :: ω

-- |  The titlecase equivalent of the character, if any; otherwise, the character itself.   
toTitle :: ω

-- |  The uppercase equivalent of the character, if any; otherwise, the character itself.   
toUpper :: ω



-- |     Composition of two applicative functors _f_ and _g_
--     such that the type _f (g a)_ can itself be treated
--     as aplicative functor.
--      
module frege.data.Compose

instance (Applicative f,Applicative g) => Applicative (Compose.Compose f g)


instance (Functor f,Functor g) => Functor (Compose.Compose f g)


data Compose


Compose :: f (g a) -> Compose.Compose f g a


compose :: f (g a) -> Compose.Compose f g a



-- |  co-product   
module frege.data.Coproduct

instance (Functor f,Functor g) => Functor (Coproduct.Coproduct f g)


data Coproduct


Inl :: f a -> Coproduct.Coproduct f g a


Inr :: g a -> Coproduct.Coproduct f g a



-- |  Data structures that can be folded.   
module frege.data.Foldable
-- |     Data structures that can be folded.
-- 
--     Minimal complete definition: 'foldMap' or 'foldr'.
-- 
--     For example, given a data type
-- 
--     > data Tree a = Empty | Leaf a | Node (Tree a) a (Tree a)
-- 
--     a suitable instance would be
-- 
--     > instance Foldable Tree where
--     >    foldMap f Empty = mempty
--     >    foldMap f (Leaf x) = f x
--     >    foldMap f (Node l k r) = foldMap f l `mappend` f k `mappend` foldMap f r
-- 
--     This is suitable even for abstract types, as the monoid is assumed
--     to satisfy the monoid laws.  Alternatively, one could define @foldr@:
-- 
--     > instance Foldable Tree where
--     >    foldr f z Empty = z
--     >    foldr f z (Leaf x) = f x z
--     >    foldr f z (Node l k r) = foldr f (f k (foldr f z r)) l
--      
class Foldable


instance Foldable.Foldable Identity.Identity


instance Foldable.Foldable Maybe


instance Foldable.Foldable []

-- |  Determines whether all elements of the structure satisfy the predicate.   
all :: Foldable.Foldable t => (a -> Bool) -> t a -> Bool

-- |    'and' returns the conjunction of a container of Bools.  For the
--    result to be *true*, the container must be finite; *false*, however,
--    results from a *false* value finitely far from the left end.
--      
and :: Foldable.Foldable t => t Bool -> Bool

-- |   Determines whether any element of the structure satisfies the predicate.   
any :: Foldable.Foldable t => (a -> Bool) -> t a -> Bool

-- |  The concatenation of all the elements of a container of lists.   
concat :: Foldable.Foldable t => t [a] -> [a]

-- |     Map a function over all the elements of a container and concatenate
--     the resulting lists.
--      
concatMap :: Foldable.Foldable t => (a -> [b]) -> t a -> [b]

-- |   Does the element occur in the structure?   
elem :: (Foldable.Foldable t,Eq a) => a -> t a -> Bool

-- |     The 'find' function takes a predicate and a structure and returns
--     the leftmost element of the structure matching the predicate, or
--     'Nothing' if there is no such element.
--      
find :: Foldable.Foldable t => (a -> Bool) -> t a -> Maybe a

-- |  Combine the elements of a structure using a monoid.     
fold :: (Foldable.Foldable t,Monoid.Monoid m) => t m -> m

-- |  versions without base case       
-- 
--  A variant of fold that has no base case, and thus may only be applied to non-empty structures.    
-- 
--  (not in Haskell's Foldable, because they have no Semigroup)   
fold1 :: (Foldable.Foldable t,Monoid.Semigroup m) => t m -> m

-- |  Map each element of the structure to a monoid, and combine the results.    
foldMap :: (Foldable.Foldable t,Monoid.Monoid m) => (a -> m) -> t a -> m

-- |  A variant of foldMap that has no base case, and thus may only be applied to non-empty structures.    
-- 
--  (not in Haskell's Foldable, because they have no Semigroup)   
foldMap1 :: (Foldable.Foldable t,Monoid.Semigroup m) => (a -> m) -> t a -> m

-- |  Left-associative fold of a structure.    
foldl :: Foldable.Foldable t => (a -> b -> a) -> a -> t b -> a

-- |     Fold over the elements of a structure,
--     associating to the left, but strictly.
--      
foldl' :: Foldable.Foldable t => (a -> b -> a) -> a -> t b -> a

-- |  nowarn: not easy enough   
-- 
--  A variant of foldl that has no base case, and thus may only be applied to non-empty structures.    
foldl1 :: Foldable.Foldable t => (a -> a -> a) -> t a -> a

-- |  nowarn: not easy enough   
-- 
--  A variant of foldl that has no base case, and thus may only be applied to non-empty structures.    
foldl1a :: Foldable.Foldable t => (a -> a -> a) -> t a -> a

-- |     Monadic fold over the elements of a structure,
--     associating to the left, i.e. from left to right.
--      
foldlM :: (Foldable.Foldable t,Monad m) => (a -> b -> m a) -> a -> t b -> m a

-- |  Right-associative fold of a structure.    
foldr :: Foldable.Foldable t => (a -> b -> b) -> b -> t a -> b

-- |     Fold over the elements of a structure,
--     associating to the right, but strictly.
--      
foldr' :: Foldable.Foldable t => (a -> b -> b) -> b -> t a -> b

-- |  nowarn: not easy enough   
-- 
--  A variant of foldr that has no base case, and thus may only be applied to non-empty structures.    
foldr1 :: Foldable.Foldable t => (a -> a -> a) -> t a -> a

-- |  nowarn: not easy enough   
-- 
--  A variant of foldr that has no base case, and thus may only be applied to non-empty structures.    
foldr1a :: Foldable.Foldable t => (a -> a -> a) -> t a -> a

-- |     Monadic fold over the elements of a structure,
--     associating to the right, i.e. from right to left.
--      
foldrM :: (Foldable.Foldable t,Monad m) => (a -> b -> m b) -> b -> t a -> m b

-- |  'forM_' is 'mapM_' with its arguments flipped.   
forM_ :: (Foldable.Foldable t,Monad m) => t a -> (a -> m b) -> m ()

-- |  'for_' is 'traverse_' with its arguments flipped.   
for_ :: (Foldable.Foldable t,Applicative f) => t a -> (a -> f b) -> f ()

-- |     Map each element of a structure to a monadic action, evaluate
--     these actions from left to right, and ignore the results.
--      
mapM_ :: (Foldable.Foldable t,Monad m) => (a -> m b) -> t a -> m ()

-- |  The largest element of a non-empty structure.   
maximum :: (Foldable.Foldable t,Ord a) => t a -> a

-- |  The largest element of a non-empty structure with respect to the
--     given comparison function.      
maximumBy :: Foldable.Foldable t => (a -> a -> Ordering) -> t a -> a

-- |  The least element of a non-empty structure.   
minimum :: (Foldable.Foldable t,Ord a) => t a -> a

-- |     The least element of a non-empty structure with respect to the
--     given comparison function.
--      
minimumBy :: Foldable.Foldable t => (a -> a -> Ordering) -> t a -> a

-- |  The sum of a collection of actions, generalizing 'concat'.   
msum :: (Foldable.Foldable t,MonadPlus m) => t (m a) -> m a

-- |   'notElem' is the negation of 'elem'.   
notElem :: (Foldable.Foldable t,Eq a) => a -> t a -> Bool

-- |     'or' returns the disjunction of a container of Bools.  For the
--     result to be *false*, the container must be finite; *true*, however,
--     results from a *true* value finitely far from the left end.
--      
or :: Foldable.Foldable t => t Bool -> Bool

-- |   The 'product' function computes the product of the numbers of a structure.   
product :: (Foldable.Foldable t,Num a) => t a -> a

-- |    Evaluate each action in the structure from left to right,
--    and ignore the results.
--      
sequenceA_ :: (Foldable.Foldable t,Applicative f) => t (f a) -> f ()

-- |     Evaluate each monadic action in the structure from left to right,
--     and ignore the results.
--      
sequence_ :: (Foldable.Foldable t,Monad m) => t (m a) -> m ()

-- |  The 'sum' function computes the sum of the numbers of a structure.   
sum :: (Foldable.Foldable t,Num a) => t a -> a

-- |     Map each element of a structure to an action, evaluate
--     these actions from left to right, and ignore the results.
--      
traverse_ :: (Foldable.Foldable t,Applicative f) => (a -> f b) -> t a -> f ()



-- |      [Module]     Data.Graph
--      [Copyright]  (c) The University of Glasgow 2002
--      [License]    BSD-style (see the file libraries/base/LICENSE)
--  
--     A version of the graph algorithms described in:
-- 
--    _Lazy Depth-First Search and Linear Graph Algorithms in Haskell_,
--    by David King and John Launchbury.
-- 
--     Ported to Frege from the Haskell library source.
--      
module frege.data.Graph
-- |  A single vertex that is not in any cycle.   
AcyclicSCC :: vertex -> Graph.SCC vertex

-- |  A maximal set of mutually reachable vertices.   
CyclicSCC :: [vertex] -> Graph.SCC vertex

-- |  Strongly connected component.   
data SCC

-- |  The biconnected components of a graph.   
-- 
--  An undirected graph is biconnected if the deletion of any vertex leaves it connected.   
bcc :: JArray [Int] -> [Tree.Tree [Int]]


bicomps :: Tree.Tree (Int,Int,Int) -> [Tree.Tree [Int]]


bounds :: JArray a -> (Int,Int)

-- |  Build a graph from a list of edges.   
buildG :: (Int,Int) -> [(Int,Int)] -> JArray [Int]


chop :: [Tree.Tree Int] -> ArrayOf s Bool -> ST s [Tree.Tree Int]


collect :: Tree.Tree (Int,Int,Int) -> (Int,Tree.Tree [Int])

-- |  The connected components of a graph.   
-- 
--  Two vertices are connected if there is a path between them, traversing edges in either direction.   
components :: JArray [Int] -> [Tree.Tree Int]

-- |     A spanning forest of the graph, obtained from a depth-first search of
--     the graph starting from each vertex in an unspecified order. 
--      
dff :: JArray [Int] -> [Tree.Tree Int]

-- |     A spanning forest of the part of the graph reachable from the listed
--     vertices, obtained from a depth-first search of the graph starting at
--     each of the listed vertices in order. 
--          
dfs :: JArray [Int] -> [Int] -> [Tree.Tree Int]


do_label :: JArray [Int] -> JArray Int -> Tree.Tree Int -> Tree.Tree (Int,Int,Int)

-- |  Make a (key, [key]) list into one that is accepted by 'stronglyConnComp'   
edgeFromTuple :: (b,a) -> (b,b,a)

-- |  All edges of a graph.   
edges :: JArray [Int] -> [(Int,Int)]

-- |  The vertices of a strongly connected component.   
flattenSCC :: Graph.SCC vertex -> [vertex]

-- |  The vertices of a list of strongly connected components.   
flattenSCCs :: [Graph.SCC a] -> [a]


generate :: JArray [Int] -> Int -> Tree.Tree Int

-- |     Build a graph from a list of nodes uniquely identified by keys,
--     with a list of keys of nodes this node should have edges to.
--     The out-list may contain keys that don't correspond to
--     nodes of the graph; they are ignored.      
graphFromEdges :: Ord key => [(node,key,[key])] -> (JArray [Int],Int->(node,key,[key]),key->Maybe Int)

-- |     Identical to 'graphFromEdges', except that the return value
--     does not include the function which maps keys to vertices.  This
--     version of 'graphFromEdges' is for backwards compatibility.
--          
graphFromEdges' :: Ord key => [(node,key,[key])] -> (JArray [Int],Int->(node,key,[key]))

-- |  A table of the count of edges into each node.   
indegree :: JArray [Int] -> JArray Int


mapT :: (ArrayElem a,ArrayElem b) => (Int -> a -> b) -> JArray a -> JArray b

-- |  A table of the count of edges from each node.   
outdegree :: JArray [Int] -> JArray Int

-- |  Is the second vertex reachable from the first?   
path :: JArray [Int] -> Int -> Int -> Bool


postOrd :: JArray [Int] -> [Int]


postorder :: Tree.Tree a -> [a]


postorderF :: [Tree.Tree a] -> [a]


preArr :: (Int,Int) -> [Tree.Tree Int] -> JArray Int


preorder :: Tree.Tree a -> [a]


preorderF :: [Tree.Tree a] -> [a]


prune :: (Int,Int) -> [Tree.Tree Int] -> [Tree.Tree Int]

-- |  A list of vertices reachable from a given vertex.   
reachable :: JArray [Int] -> Int -> [Int]


reverseE :: JArray [Int] -> [(Int,Int)]

-- |  The strongly connected components of a graph.   
scc :: JArray [Int] -> [Tree.Tree Int]


size :: (Int,Int) -> Int

-- |     The strongly connected components of a directed graph, 
--     topologically sorted.
--     
--     The graph is a list of nodes uniquely identified by keys,
--     with a list of keys of nodes this node has edges to.
--     The latter one may contain keys that don't correspond to
--     nodes of the graph; such edges are ignored.
--          
stronglyConnComp :: Ord key => [(node,key,[key])] -> [Graph.SCC node]

-- |     The strongly connected components of a directed graph, topologically
--     sorted.  The function is the same as 'stronglyConnComp', except that
--     all the information about each node retained.
--     
--     This interface is used when you expect to apply 'SCC' to
--     (some of) the result of 'SCC', so you don't want to lose the
--     dependency information. 
--          
stronglyConnCompR :: Ord key => [(node,key,[key])] -> [Graph.SCC (node,key,[key])]

-- |     Convenience function to compute topologically sorted
--     strongly connected components of an adjacency list
--     of the form:
--     
--     >  [(key, [key])]
--     
--     The result will be a list of lists of _keys_, 
--     where a singleton indicates no mutual dependency with other keys
--     and a list consisting of several keys means that those are mutually
--     dependend on each other.
--     
--     In addition, earlier elements will not depend on later ones.
--     
--     If the result contains only singletons, then the input was
--     an acyclic graph. 
--      
stronglyConnectedComponents :: Ord key => [(key,[key])] -> [[key]]


tabulate :: (Int,Int) -> [Int] -> JArray Int

-- |     A topological sort of the graph.
--     
--     The order is partially specified by the condition that a vertex _i_
--     precedes _j_ whenever _j_ is reachable from _i_ but not vice versa.      
topSort :: JArray [Int] -> [Int]

-- |  The graph obtained by reversing all edges.   
transposeG :: JArray [Int] -> JArray [Int]


undirected :: JArray [Int] -> JArray [Int]

-- |  All vertices of a graph.   
vertices :: JArray [Int] -> [Int]

-- |  Get non-null element at index from immutable array, see 'JArray.elemAt'   
(§) :: ArrayElem a => JArray a -> Int -> a



-- |     A HashMap implementation based on a 
--     'https://en.wikipedia.org/wiki/Hash_array_mapped_trie Hash Array Mapped Trie'
-- 
--     The hash array mapped trie achieves almost hash table-like speed 
--     while using memory much more economically. 
--     Also, a hash table may have to be periodically resized, 
--     an expensive operation, whereas HAMTs grow and shrink dynamically.
--     
--     ## Comparison with 'Data.TreeMap'
--     
--     ### Advantages of the 'HashMap'
--     
--     - The hash map can be used with key types that do not have a 'Ord' instance.
--     - It is less affected by slow implementations of the ('==') operation on keys.
--     - There is less aggregated memory overhead per key/value pair.
--     
--     ### Disadvantages of the 'HashMap'
--     
--     - Performance is severely affected when the hashing function tends to 
--         produce many collisions.
--     - It does not support getting the minimum/maximum key in logarithmic time,
--         nor processing in key order in linear time.
-- 
--     ## Creating Hash Maps
-- 
--     Get an empty map with 'HashMap.mempty' or 'HashMap.empty', make a singleton one
--     with 'singleton' or turn an association list into a 'HashMap' with 'fromList'.
--     The more general function 'fromListWith' allows custom handling of 
--     associations with duplicate keys.
-- 
--     ## Add, Change or Remove Associations
-- 
--     Use 'insert', 'delete', 'adjust' and 'replace'. The more general form of 'insert' 
--     is 'insertWith' which accepts a function to combine the given value with an
--     already existing one.
-- 
--     ## Lookups
-- 
--     The basic function is 'lookup', of which 'member' and 'lookupDefault' are variants.
--     The operator ('!!') may be used when the existence of the keys looked for is out
--     of the question.
-- 
--     ## Set operations
-- 
--     There is 'union', 'difference' and 'intersection'. More general functions 
--     'unionWith' and 'intersectionWith' allow combination of the affected values.
-- 
--     ## Folds
-- 
--     Left folds as well as right folds are provided by 'foldValues' and 'foldrValues'. 
--     Variants 'foldWithKey' and 'foldrWithKey' allow examination not only of the value, 
--     but also of the key.
-- 
--     Frequently needed functions such as 'values', 'keys', 'each' and 'size' are just
--     predefined folds for your convenience.
-- 
--     ## Filtering
-- 
--     Create a subset of an existing map with 'filterValues' or 'filterWithKey'.
-- 
--     ## Transformations
-- 
--     'mapValues', 'mapWithKey' and 'traverseWithKey' should cover any need to 
--     transform an existing map.
-- 
--     ### Naming Conventions
-- 
--     Functions whose name have the _With_ suffix take a custom function to combine two
--     values and are thus more general than the ones without that suffix. 
--     Most often it is the case that 
--     > xxx = xxxWith const
-- 
--     Functions whose name have the _Values_ suffix operate on the values of the mappings
--     contained in the map and take an appropriate custom function as argument. 
--     The _Values_ suffix also serves to avoid conflicts with
--     Prelude functions (i.e. 'map', 'filter', 'fold', 'foldr').
-- 
--     The companions of the _Values_ functions have the suffix _WithKey_ and accept 
--     functions that take an extra argument for the key. The key portion of
--     a mapping or association is always passed first, followed by the associated value.
-- 
--      
module frege.data.HashMap
-- |  _O(log n)_
-- 
--     Return the value associated with the given key in the map.
--     Fails with 'error' if the key is not present.
--      
(!!) :: Eq k => HashMap.HashMap k v -> k -> v


instance (Eq k,Eq v) => Eq (HashMap.HashMap k v)


instance (JSON.ToJSON k,JSON.ToJSON v) => JSON.ToJSON (HashMap.HashMap k v)


instance (JSON.ToJSON k,JSON.ToJSON v) => Show (HashMap.HashMap k v)


instance ArrayElement (HashMap.HashMap k v)


instance Eq k => ListMonoid (HashMap.HashMap k)


instance Eq k => Monoid.Monoid (HashMap.HashMap k v)


instance Foldable.Foldable (HashMap.HashMap k)


instance Functor (HashMap.HashMap k)

-- |     A map from hashable keys to values based on a Hash Mapped Array Trie.
-- 
--     A map cannot contain duplicate keys; each key can map to at most one value. 
--     A 'HashMap' makes no guarantees as to the order of its elements.
-- 
--     A node of the 'HashMap' is either
-- 
--         - a key/value pair
--         - a list of key/value tuples with pair-wise different keys,
--         where the hash code for all keys is identical (collisions). 
--         In the (hopefully) unlikely case of such collisions,
--         the performance of operations using the affected keys degrades to 
--         that of similar operations on lists. 
--         However, collision lists should be short, if occurring at all.
--         - a bitmapped node with a bitmap of size 32 to indicate
--         absence or presence of sub-nodes, followed by an array of up to 32
--         (sub)nodes.
--     
--     This implementation of a
--     'https://en.wikipedia.org/wiki/Persistent_data_structure persistent' 
--     hash array mapped trie uses 32 bit hash values as provided by Java and the
--     Frege 'Eq' type class. 
-- 
--     To find a value, the search starts with the root node.
--     If the node is a key/value pair, the node's key is compared to the search key.
--     When the keys are equal, the value is returned, otherwise the key is not in the map. 
-- 
--     If the node is a bitmapped node, the hash code of the lookup key is computed 
--     and the presence of the index provided by the last five bits is checked in the bitmap.
--     If it is there, the search continues with the corresponding node 
--     from the node array, otherwise the key is not in the map. With every recursion,
--     the next five bits of the hash code will be used for indexing.
-- 
--     It remains the case that the node is a collision list. The searched key's
--     hashcode either is the same as the one of the keys in the collision list, 
--     in which case the search degrades to a sequential search in that list, or it
--     is different, and in the latter case we know that the key is not in the
--     map without even touching the list.
--     
--     Hence, the worst case in searching must do the following: 
--     
--       - 1 time: compute the hash code of the key
--       - 7 times: find the next node through the sub-node array. This is in 
--         essence computation of an index with bit operations, followed by a
--         memory read. The reason this is done at max 7 times is that it consumes
--         5 bits of the hash code every time. With 32 bit hash codes, we have 6 5-bit
--         quantities that can range from 0 to 31, while the last 5-bit quantity has
--         only 2 significant bits, the other ones are always zero. The hashmapped nodes
--         at the 7th level of the map will consequently have at most 4 sub-nodes.
--         (Note that this is an intrinsic limit that is 
--         determined by the hash code bit size, *not* by the algorithm.
--         Should later Java versions choose to provide 'Long' bitcodes, for example,
--         this code will still work with marginal adjustments, 
--         just that there would be 13 levels of bitmapped nodes instead of 7.)
--       - _n_ times: comparison with the keys in the collision list, where _n_
--         is the number of elements of the collision list, or comparison with the
--         key of a key/value node (this is equivalent to a collision list of length 1).
-- 
--     It turns out that - absent hash collisions - lookups will be done almost in 
--     *constant time*. 
--     And so will be inserts and deletes, although with a slightly larger constant
--     factor due to the house-keeping necessary for a persistent data structure. 
--     However, even this are in the worst case 7 array copies, where 6 of them may
--     be of size 32 and one of size 4. Assuming that the pointers are 4 bytes long, 
--     this amounts to copying at most 196*4 bytes of memory. 
-- 
--     The map can have at most 2^32 non-bitmapped nodes maintained in
--     1+32+1024+32768+1048576+33554432+1073741824 bitmapped nodes. 
--     But because collision lists can be arbitrary long, 
--     the total number of key/value pairs is *not limited*. 
-- 
--      
data HashMap


instance ListEmpty (HashMap.HashMap k)


instance ListSource (HashMap.HashMap k)


instance Traversable.Traversable (HashMap.HashMap k)

-- |  _O(log n)_ 
--     
--     Adjust the value tied to a given key in this map only if it is present. 
--     Otherwise, leave the map alone. 
--      
adjust :: Eq k => (v -> v) -> k -> HashMap.HashMap k v -> HashMap.HashMap k v

-- |     _O(log n)_
--     > delete k m
--     is a 'HashMap' h such that
--     > lookup k h = Nothing
--     and for any other key _o_
--     > lookup o h = lookup o m
-- 
--     Less formally, the association of _k_ with some value, if any, 
--     is removed in the result, while all other associations are retained.
-- 
--     If _m_ didn't contain _k_ in the first place,
--     > delete k m = m    
--      
delete :: Eq k => k -> HashMap.HashMap k v -> HashMap.HashMap k v

-- |     _O(n*log m)_ 
-- 
--     Computes the difference of two maps. 
-- 
--     Returns a map that contains the mappings of the first map 
--     whose keys do not exist in the second.
--      
difference :: Eq k => HashMap.HashMap k v -> HashMap.HashMap k u -> HashMap.HashMap k v

-- |  _O(n)_ Retrieve a list of the associations in the map   
each :: HashMap.HashMap k v -> [(k,v)]

-- |     _O(n)_
-- 
--     Filter a map, retaining only mappings whose value satisfies
--     a given predicate.
--      
filterValues :: (v -> Bool) -> HashMap.HashMap k v -> HashMap.HashMap k v

-- |     _O(n)_
-- 
--     Filter a map, retaining only mappings whose key and value satisfy
--     a given predicate.
--      
filterWithKey :: (k -> v -> Bool) -> HashMap.HashMap k v -> HashMap.HashMap k v

-- |  _O(n)_
-- 
--     Reduce this map by applying a binary operator to all values, 
--     using the given starting value (typically the left-identity of the operator). 
--     Each application of the operator is evaluated before 
--     using the result in the next application. 
-- 
--     This function is strict in the starting value.
--      
foldValues :: (a -> v -> a) -> a -> HashMap.HashMap k v -> a

-- |  _O(n)_
-- 
--     Reduce this map by applying a function to all associations, 
--     using the given starting value (typically the left-identity of the operator). 
--     Each application of the function is evaluated before 
--     using the result in the next application. 
-- 
--     This function is strict in the starting value.
--      
foldWithKey :: (a -> k -> v -> a) -> a -> HashMap.HashMap k v -> a

-- |  _O(n)_
-- 
--     Reduce this map by applying a binary operator to all values, 
--     using the given starting value (typically the right-identity of the operator).
--     
--     *Warning*: this function exists for Haskell compatibility only. 
--     Please be aware that right folds suffer from the danger of stack overflows,
--     while left folds don't and are also faster because of tail recursion. Since
--     the order of values is arbitrary anyway, there is often no good reason to insist on
--     a right fold, so please use 'foldValues' instead.
--      
foldrValues :: (v -> a -> a) -> a -> HashMap.HashMap k v -> a

-- |  _O(n)_
-- 
--     Reduce this map by applying a binary operator to all mappings, 
--     using the given starting value (typically the right-identity of the operator).
--     
--     *Warning*: this function exists for Haskell compatibility only. 
--     Please be aware that right folds suffer from the danger of stack overflows,
--     while left folds don't and are also faster because of tail recursion. Since
--     the order of values is arbitrary anyway, there is often no good reason to insist on
--     a right fold, so please use 'foldWithKey' instead.
--      
foldrWithKey :: (k -> v -> a -> a) -> a -> HashMap.HashMap k v -> a

-- |     _O(n)_
-- 
--     Build a map from an association list.
--     If the list contains duplicate mappings, the later mappings take precedence.
--      
fromList :: Eq k => [(k,v)] -> HashMap.HashMap k v

-- |     _O(n)_
--     
--     Build a map from an association list.
--     Uses the provided function to merge values associated 
--     with duplicate keys.
--      
fromListWith :: Eq k => (v -> v -> v) -> [(k,v)] -> HashMap.HashMap k v

-- |     _O(log n)_
--     > insert k v m
--     is a 'HashMap' _h_ such that 
--     > lookup k h = Just v
--     and lookup for any other key _o_
--     > lookup o h = lookup o m  
-- 
--     Less formally said, _k_ is associated with _v_ in the resulting map, updating
--     a previously existing association of _k_ if it exists, while all other associations
--     are left untouched.
-- 
--     In the case of an update, the new value will get forced, see 'insertWith' for details. 
--      
insert :: Eq k => k -> v -> HashMap.HashMap k v -> HashMap.HashMap k v

-- |     _O(log n)_
--     > insertWith f k v m
--     If _m_ does not contain _k_, this works like 'insert'.
--     Otherwise, the existing association of _k_ with some value _v'_ is replaced by
--     an association of _k_ with the result of evaluating 
--     > f v v'
--     in the resulting map. 
-- 
--     Strict evaluation is necessary to prevent building up of large thunks 
--     of the form
--     > f v3 (f v2 (f v1 v0))
-- 
--     Note that
--     > insert = insertWith const
--     and that this will evaluate the *new* value in case of an update. If you
--     want to prevent this, use
-- 
--     > replace k v = insert k v . delete k
--     
--     The replaced value will be evaluated only if the given function is strict
--     in the second argument. Since 'const' is lazy in the second argument, the
--     following will be fine:
--     
--     > insert "foo" 7 (insert "foo" undefined (delete "foo" m))
--     
--     That is, the value that is inserted for a given key first is not evaluated on
--     insertion, and only evaluated on update if the update function demands it, which
--     is not the case for a plain 'insert'.
--      
insertWith :: Eq k => (v -> v -> v) -> k -> v -> HashMap.HashMap k v -> HashMap.HashMap k v

-- |     _O(n*log m)_ 
-- 
--     Computes the intersection of two maps. 
-- 
--     Return a map that contains the mappings of the first map 
--     for keys that also exist in the second.
--      
intersection :: Eq k => HashMap.HashMap k v -> HashMap.HashMap k u -> HashMap.HashMap k v

-- |     _O(n*log m)_
-- 
--     Computes the intersection of two maps, combining the values with a
--     given function.
--      
intersectionWith :: Eq k => (v -> u -> w) -> HashMap.HashMap k v -> HashMap.HashMap k u -> HashMap.HashMap k w

-- |  _O(n)_ Retrieve a list of the keys in the map   
keys :: HashMap.HashMap k v -> [k]

-- |     _O(log n)_
--     > lookup k m
--     If _k_ is associated with some value _v_  in map _m_, it returns
--     > Just v
--     and otherwise
--     > Nothing 
--      
lookup :: Eq k => k -> HashMap.HashMap k v -> Maybe v

-- |  _O(log n)_ 
-- 
--     Return the value to which the specified key is mapped, 
--     or the default value if this map contains no mapping for the key.
--      
lookupDefault :: Eq k => v -> k -> HashMap.HashMap k v -> v

-- |  _O(n)_
-- 
--     Transform a map by applying a function to every value.
--      
mapValues :: (v -> u) -> HashMap.HashMap k v -> HashMap.HashMap k u

-- |     _O(n)_ 
-- 
--     Transform a map by applying a function to every key and its
--     associated value.
--      
mapWithKey :: (k -> v -> u) -> HashMap.HashMap k v -> HashMap.HashMap k u

-- |  _O(log n)_    
-- 
--  Checks whether the key is present in the map   
member :: Eq k => k -> HashMap.HashMap k v -> Bool

-- |  _O(log n)_
--     > replace k v m = insert k v . delete k $ m
--     
--     Insert or update the association of _k_ with _v_ in _m_
--     but avoid evaluation of _v_ even if _m_ already contains _k_.
--     
--     See also notes concerning updates on function 'insertWith'.
--      
replace :: Eq k => k -> v -> HashMap.HashMap k v -> HashMap.HashMap k v

-- |  _O(1)_ Create a singleton map   
singleton :: Eq k => k -> v -> HashMap.HashMap k v

-- |  _O(n)_ Compute the size of the map   
size :: HashMap.HashMap k v -> Int

-- |     _O(n)_
--     
--     Transform a map by applying an applicative functor to every key
--     and its associated value.
--      
traverseWithKey :: Applicative a => (k -> v -> a u) -> HashMap.HashMap k v -> a (HashMap.HashMap k u)

-- |  _O(m*log n)_
-- 
--     Computes the union of two hash maps.
-- 
--     If a key occurs in both maps, the value from the left map will be 
--     evaluated and taken over to the new map.
--     
--     Because
--     > union  =  unionWith const 
--     the considerations concerning strictness apply for 'union' in the same
--     way as for 'unionWith'.
--      
union :: Eq k => HashMap.HashMap k v -> HashMap.HashMap k v -> HashMap.HashMap k v

-- |  _O(m*log n)_
-- 
--     Computes the union of two hash maps.
-- 
--     If a key occurs in both maps, the function provided in the first argument 
--     will be used to compute the result in the same way as 'insertWith' would do
--     it, that is, the value from the left hash map will be evaluated while the
--     value from the right map may be evaluated only if the function demands it.
--     However, values associated with keys that are member of only one map are
--     left alone.
--      
unionWith :: Eq k => (v -> v -> v) -> HashMap.HashMap k v -> HashMap.HashMap k v -> HashMap.HashMap k v

-- |     The union of all 'HashMap's in a list.
--      
unions :: Eq k => [HashMap.HashMap k v] -> HashMap.HashMap k v

-- |  _O(n)_ Retrieve a list of the values in the map   
values :: HashMap.HashMap k v -> [v]



-- |  Provide Iterators for 'String' and 'JArray'   
module frege.data.Iterators
-- |     A 'ArrayIterator' is a data structure that lets us 
--     view a part of a 'JArray' as a list.
--     
--     With large 'JArray's, doing 'toList' and iterating through
--     the list can get expensive memory-wise.
--     
--     Construction, 'drop', 'take', 'head' and 'tail' on a 'ArrayIterator' 
--     are O(1) operations with a minimal memory overhead.
--     The drawback is that it holds on to the underlying 'JArray'. 
--          
data ArrayIterator


instance ListMonoid Iterators.StringIterator


instance ListView Iterators.ArrayIterator


instance ListView Iterators.StringIterator

-- |     A 'StringIterator' is a data structure that lets us 
--     view a part of a 'String' as a list.
--     
--     With large 'String's, performing list work on 'String's can be
--     expensive, because more recent JVMs implement the @substring@
--     operation via copying.
--     
--     Construction, 'drop', 'take', 'head' and 'tail' on a 'StringIterator' are O(1) operations.
--     The drawback is that it holds on to the underlying 'String'. 
--          
data StringIterator



-- | 
module frege.data.Ix

instance (Ix.Ix a,Ix.Ix b) => Ix.Ix (a,b)


instance (Ix.Ix a1,Ix.Ix a2,Ix.Ix a3) => Ix.Ix (a1,a2,a3)


instance (Ix.Ix a1,Ix.Ix a2,Ix.Ix a3,Ix.Ix a4) => Ix.Ix (a1,a2,a3,a4)


instance (Ix.Ix a1,Ix.Ix a2,Ix.Ix a3,Ix.Ix a4,Ix.Ix a5) => Ix.Ix (a1,a2,a3,a4,a5)

-- |  The 'Ix' class is used to map a contiguous subrange of values in
--     a type onto integers.  It is used primarily for array indexing.
--     (see the array package).
--     
--     The first argument @(l,u)@ of each of these operations is a pair
--     specifying the lower and upper bounds of a contiguous subrange of values.
--     An implementation is entitled to assume the following laws about these
--     operations:
-- 
--     > inRange (l,u) i == elem i (range (l,u))
-- 
--     > range (l,u) !! index (l,u) i == i
--     , when
--     > inRange (l,u) i
-- 
--     > map (index (l,u)) (range (l,u)) == [0..rangeSize (l,u)-1]
-- 
--     > rangeSize (l,u) == length (range (l,u))
--      
class Ix


instance Ix.Ix ()


instance Ix.Ix Bool


instance Ix.Ix Char


instance Ix.Ix Int


instance Ix.Ix Integer


instance Ix.Ix Ordering


hopelessIndexError :: Int

-- |  Returns 'True' the given subscript lies in the range defined the bounding pair.   
inRange :: Ix.Ix a => (a,a) -> a -> Bool

-- |  The position of a subscript in the subrange.   
-- 
--  Must specify one of index, unsafeIndex
-- 
--          'index' is typically over-ridden in instances, with essentially
--          the same code, but using indexError instead of hopelessIndexError
--          Reason: we have 'Show' at the instances
--          
index :: Ix.Ix a => (a,a) -> a -> Int


indexError :: Show a => (a,a) -> a -> String -> b

-- |  The list of values in the subrange defined by a bounding pair.   
range :: Ix.Ix a => (a,a) -> [a]

-- |  The size of the subrange defined by a bounding pair.   
rangeSize :: Ix.Ix a => (a,a) -> Int

-- |  Like 'index', but without checking that the value is in range.   
unsafeIndex :: Ix.Ix a => (a,a) -> a -> Int

-- |  like 'rangeSize', but without checking that the upper bound is in range.   
unsafeRangeSize :: Ix.Ix a => (a,a) -> Int



-- |  This module provides 'http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf JSON support' for Frege.   
-- 
--     JSON support comprises 4 levels:
-- 
--     1. On the lexical level, we analyze a 'String' and produce a list of JSON 'Token's.
--     2. On the grammar level, we parse a list of 'Token's and produce a JSON 'Value',
--        the internal representation of JSON data.
--        (It is also possible to write custom parsers that produce values
--        of certain data types directly.)
--     3. On the value level, we convert JSON 'Value's to and from values of algebraic data types.
--        This is accomplished by type classes 'ToJSON' and 'FromJSON'. Instances for basic types,
--        in particular for all tuple types, are provided.
--     4. On the presentation level, a JSON 'Value' is rendered as 'String' 
--        that conforms to the JSON standard and can thus be used to exchange data
--        with other software or over the internet.
-- 
--     The users of this library can get full JSON support by concentrating on the
--     third point, which essentially means that they have to write 'FromJSON' and 'ToJSON'
--     instances for their data types. It follows a short tutorial on how to do this.
-- 
--     ## Encoding of algebraic data types in JSON
-- 
--     The following suggestions will foster a compact and easy to decode
--     'String' representation of Frege data.
-- 
--     (There is currently no support for automatically derived instances yet,
--     but when it gets implemented it shall comply with this suggestions.)
-- 
--     - 'Bool', numbers, 'String': @true@, @false@, _number_, "_string_"
--     - a 'Char' _c_ will be encoded as JSON string "_c_"
--     - lists, arrays and the like: @[ value0, value1, ... ]@
--     - the trivial type @()@: @[]@
--     - tuples and other product types: @[ field1, field2, ... ]@
--     - enumerations: the constructor name as string
--     - type renamings: same as the wrapped type
--     - algebraic types: for each variant, make a JSON struct with the
--       constructor name as key. Example:
--       > { "Just": 42 }
--       > {"Nothing":null}
--     - If there is more than one component for the constructor, treat
--       the values as tuple: 
--       > { "Data": [field1,field2,...]}. 
--     - A record could also get encoded like: 
--       > { "case":"Person", "name":"Smith", "age":42}
--     - inside @[]@ or @{}@ brackets, 'Maybe' values can be abbreviated 
--       in such a way that @null@ stands for 'Nothing' and @v@ for 'Just' v, but
--       observe that values of type @(Maybe (Maybe x))@ cannot be encoded like this, 
--       because there would be no encoding for the value @Just Nothing@. 
-- 
--     ## Create JSON documents from your data
-- 
--     This will be done in two steps:
--     
--     1. Convert your data to JSON 'Value's, the internal generic representation
--         for JSON data provided by this module.
--     2. Show the JSON 'Value'. This reults in a 'String' which is a standard
--         conforming JSON document.
--     
--     The conversion should be done by implementing type class 'ToJSON' for your data.
--     There is just one class operation 'toJSON' to implement.
--     
--     Because standard Frege types, lists, arrays and all tuple types are already
--     instances of 'ToJSON', this is easy to accomplish, as will be demonstrated
--     below.   
-- 
--     Given the following definitions:
--     >  data Engine = Electric Double --- just performance in kW
--     >               | Combustion { fuel :: [Fuel], displacement :: Double, cyls :: Int }
--     >  data Fuel = DIESEL | GASOLINE | NATURALGAS | LPG
--     >  data Vehicle = Vehicle { wheels :: Int, engine :: Maybe Engine }
--     we could make the following instances:
--     
--     > derive Show Fuel      -- we need this in the ToJSON instance
-- 
--     Use the 'Value.String' constructor to create a JSON string value 
--     from an ordinary 'String'.
-- 
--     > instance ToJSON Fuel where
--     >    toJSON = String . show
-- 
--     The instance for @Engine@ makes JSON structs for the @Engine@ constructors
--     by associating the constructor name with the values under the constructor.
--     There is a function 'struct', designed to create such structures that have just
--     a single association, which is - according to our encoding suggestions -
--     a most frequent case.
-- 
--     > instance ToJSON Engine where
--     >    toJSON (Electric d) 
--     >            = struct "Electric" d
--     >    toJSON Combustion{fuel, displacement, cyls}
--     >            = struct "Combustion" (fuel, displacement, cyls)
--     
--     The @Vehicle@ instance demonstractes a more complex JSON struct, where 
--     the record field names are associated with their values. The 'Struct'
--     constructor takes a list of associations, created with 'assoc'.
--     The constructor name is reduntant here, as @Vehicle@ is a product type,
--     so it is not included.
--     
--     If we have 'Maybe' values in the struct that are actually 'Nothing', 
--     we can as well omit their associations
--     and thus reduce the size of the generated JSON. 
--     However, the corresponding
--     'fromJSON' function will then have to interpret a missing association as
--     'Nothing' - this is exactly the purpose of the 'optional' function.
--  
--     > instance ToJSON Vehicle where
--     >    {-- For illustration, we use a struct with record fields
--     >    
--     >       The first clause is not strictly necessary, 
--     >       but helps to reduce the generated json size
--     >       in the case that we have no engine, by just not
--     >       producing an association for "engine".
--     >    
--     >       This assumes that the corresponding 'fromJSON' function takes care of that,
--     >       preferably by extracting the "engine" field with 'optional'.
--     >   -}
--     >    toJSON Vehicle{wheels, engine=Nothing} 
--     >           = Struct [ assoc "wheels" wheels ]   -- just leave out engine
--     >    toJSON Vehicle{wheels, engine} 
--     >            = Struct [
--     >                    assoc "wheels" wheels,
--     >                    -- uses the short form for Maybe
--     >                    assoc "engine" (maybeToJSON engine), 
--     >            ]
-- 
--     We can now construct some vehicles and print a JSON document. 
--     The translation of the internal to the external (i.e. 'String') form
--     is done by the 'Show' instance for JSON 'Value's.
--     
--     > bicycle = Vehicle { wheels = 2, engine = Nothing }
--     > ebike   = Vehicle { wheels = 2, engine = Just (Electric 0.9) }
--     > car     = Vehicle { wheels = 4, 
--     >                     engine = Just Combustion {
--     >                              fuel = [LPG, GASOLINE], 
--     >                              displacement = 2.0,
--     >                              cyls = 4 }}
--     > vehicles = [car, bicycle, ebike]
--     > main = println (toJSON vehicles)
--     
--     The output looks like:
--     
--     > [{
--     >  "wheels" : 4,
--     >  "engine" : {"Combustion" : [["LPG", "GASOLINE"], 2.0, 4]}
--     > },
--     > {"wheels" : 2, "engine" : null},
--     > {"wheels" : 2, "engine" : {"Electric" : 0.9}}]
-- 
-- 
--     ## Reconstruct your data from JSON data
--     
--     There are 2 ways one could get confronted with JSON data:
--     
--     1. A JSON document in the form of a 'String'
--     2. A JSON 'Value'
--     
--     The type class 'FromJSON' has two operations to deal with those scenarios: 
--     'parseJSON' and 'fromJSON'. But only the latter one needs to be implemented, 
--     the default implementation of 'parseJSON' will parse a 'String' to a generic
--     JSON 'Value' and pass this to 'fromJSON'.
--     
--     While it may cost a bit of memory to first create the JSON 'Value', this
--     two-step approach has a number of advantages. Not the least one being clear
--     separation of lexical and syntactical issues from semantical ones. But it
--     is also the case that writing 'fromJSON' functions is quite easy, 
--     if not boring. The type checker, the support for basic types, lists and tuples
--     and the internal plumbing make it hard to write a wrong implementation.
--     Whereas writing a parser is comparatively hard and error prone.
-- 
--     ### Implementing 'fromJSON'
--     
--     Reconstruction of values from JSON data can fail, 
--     therefore the 'fromJSON' function delivers its result in a failure monad
--     ('MonadFail' - two well known failure monads are 'Maybe' and 'Either' 'String').
--     'fromJSON' is therefore overloaded twice in the return type: one for the
--     actual data type and then the monad.  
--     
--     If one has already a 'ToJSON' instance, it should go without saying
--     that the implementations should satisfy the following law:
--     
--     > decodeEncoded x = fromJSON (toJSON x) == Just x
-- 
--     Here are, in continuation of our example from above, the 'FromJSON' instances:
-- 
--     > instance FromJSON Fuel where
--     >     fromJSON (String "DIESEL") = return DIESEL
--     >     fromJSON (String "GASOLINE") = return GASOLINE
--     >     fromJSON (String "NATURALGAS") = return NATURALGAS
--     >     fromJSON (String "LPG") = return LPG
--     >     fromJSON s = fail ("cannot decode fuel from " ++ show s)
-- 
--     Note the use of 'fail' and 'return' which is needed because we produce
--     our value in a failure monad like 'Maybe' or 'Either' 'String'. In fact, 
--     every correct implementation of 'fromJSON' will have at least two equations 
--     (or, equivalently, case alternatives) where at least one does 'fail' and 
--     at least one is 'return'ing an actual value.  
-- 
--     > import Data.List(lookup)  -- for looking up associations
--     > instance FromJSON Engine where
--     >    fromJSON (Struct as)
--     >       | Just n   <- lookup "Electric" as   = Electric <$> fromJSON n
--     >       | Just fdc <- lookup "Combustion" as = do
--     >               (fuel, displacement, cyls) <- fromJSON fdc
--     >               return Combustion{fuel, displacement, cyls}
--     >    fromJSON x = fail ("invalid engine: " ++ show x)
--     
--     We need to look up the keys to find out which variant we have. We then
--     just decode the associated values and recreate our value. Failures
--     for sub-components are propagated upwards automatically, thanks to the 
--     monadic approach. For example, when we try to decode an engine from
--     
--     > { "Combustion" : [ ["Water"], 2.7, 3]}
--     
--     we will get the error 
--     
--     > cannot decode fuel from "Water"
--     
--     Because the fuel cannot get decoded, the decoding of the 3-tuple fails, and
--     our combustion engine will not be constructed.  
--     
--     Note how the existence of generic 'FromJSON' instances for primitives, 
--     tuples and lists makes the decoding a no brainer. 
--     
--     Finally we can decode vehicles:
--     
--     > instance FromJSON Vehicle where
--     >   fromJSON (Struct as)  = do
--     >       wheels ← field    "wheels" as
--     >       engine ← optional "engine" as
--     >       pure Vehicle{wheels, engine}
--     >   fromJSON garbage = fail ("couldn't decode Vehicle from: " ++ show garbage)
-- 
--     The 'field' function extracts a field from an association list, or fails with an
--     appropriate message. The "engine" field has type ('Maybe' Engine) and could be extracted
--     with the 'field' function as well, but a missing "engine" association would then
--     mean failure. 
--     With 'optional', a missing "engine" association means that "engine" is 'Nothing'.
--          
--     Observe that this instance allows the following: 
--     1. key/value pairs can occur in any order
--     2. additional keys besides @"wheels"@ and @"engine"@ are ignored
--     3. the "engine" key can be missing, and this will be interpreted as a
--         vehicle without engine.
-- 
--     Such a forgiving and fault-tolerant implementation is oftentimes in order.
--     However, if one needs it stricter, one can pattern match the association
--     list directly:
--     
--     > fromJSON (Struct [("wheels", jw), ("engine", je)]) = do
--     >                  wheels <- fromJSON jw
--     >                  engine <- fromJSON je
--     >                  return Vehicle{wheels, engine}
-- 
--     To read a vehicle from a 'String',
--     we just need to run the automatically supplied 'parseJSON' function:
--     
--     >  case parseJSON "{\"wheels\" : 3 }"  of
--     >       Just Vehicle{wheels=w} -> -- we have w wheels ...
--     
--     Like with 'fromJSON', 
--     the 'parseJSON' function needs to know the type of the item to decode as
--     well as the failure monad to work with. Most often, this can be inferred
--     by the compiler, like in the example above where it is clear that we want
--     a @Maybe Vehicle@.
--  
--     ### Very brief guide to 'Parser's
--     
--     Sometimes memory and time are extremely scarce, and the data to decode
--     are comparatively simple. This is the time to roll your own custom 
--     JSON parser.
--     
--     The parsers provided in this module fall into 4 classes:
--     1. 'Parser' 'Value' are not interesting for custom parser builders, because 
--     they are used to implement the generic 'Value' parsers. (The source code
--     could give some inspiration, though ...)
--     2. 'Parser' 'Token' such as 'parseComma', 'parseColon' and so on parse 
--     punctuation occuring in JSON syntax, and can be re-used in any other parser.
--     3. 'Parser' _a_ where _a_ is some basic type like 'Bool', 'Int' or 'String'. 
--     You most likely want to reuse those in your cutom parser.
--     4. 'Parser' combinators like 'parsePair', 'parseTuple' and 'parseList' 
--     take one or two parsers as arguments and build parsers for more
--     complex structures that contain the provided ones.
--     
--     All 'Parser's supported by this module operate on list of 'Token's. 
--     The function 'lexer' can be used to turn a 'String' into such a list, 
--     obeying the JSON lexical syntax. Finally, the function 'runParser' 
--     actually applies a parser to a token list.
--     
--     So the skeleton of your code should read like this example:
--     
--     > run :: MonadFail m => String -> m [Float] 
--     > run = runParser custom . lexer 
--     >        where custom = parseList parseFloat
--     
--     The "custom parser" here parses a list of floating point values, and
--     on success returns a @[Float]@ in the failure monad of your choice.
--  
--      
module frege.data.JSON

instance (JSON.FromJSON a,JSON.FromJSON b) => JSON.FromJSON (a | b)


instance (JSON.FromJSON a,JSON.FromJSON b) => JSON.FromJSON (a,b)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c) => JSON.FromJSON (a,b,c)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d) => JSON.FromJSON (a,b,c,d)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e) => JSON.FromJSON (a,b,c,d,e)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f) => JSON.FromJSON (a,b,c,d,e,f)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f,JSON.FromJSON g) => JSON.FromJSON (a,b,c,d,e,f,g)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f,JSON.FromJSON g,JSON.FromJSON h) => JSON.FromJSON (a,b,c,d,e,f,g,h)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f,JSON.FromJSON g,JSON.FromJSON h,JSON.FromJSON i) => JSON.FromJSON (a,b,c,d,e,f,g,h,i)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f,JSON.FromJSON g,JSON.FromJSON h,JSON.FromJSON i,JSON.FromJSON j) => JSON.FromJSON (a,b,c,d,e,f,g,h,i,j)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f,JSON.FromJSON g,JSON.FromJSON h,JSON.FromJSON i,JSON.FromJSON j,JSON.FromJSON k) => JSON.FromJSON (a,b,c,d,e,f,g,h,i,j,k)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f,JSON.FromJSON g,JSON.FromJSON h,JSON.FromJSON i,JSON.FromJSON j,JSON.FromJSON k,JSON.FromJSON l) => JSON.FromJSON (a,b,c,d,e,f,g,h,i,j,k,l)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f,JSON.FromJSON g,JSON.FromJSON h,JSON.FromJSON i,JSON.FromJSON j,JSON.FromJSON k,JSON.FromJSON l,JSON.FromJSON m) => JSON.FromJSON (a,b,c,d,e,f,g,h,i,j,k,l,m)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f,JSON.FromJSON g,JSON.FromJSON h,JSON.FromJSON i,JSON.FromJSON j,JSON.FromJSON k,JSON.FromJSON l,JSON.FromJSON m,JSON.FromJSON n) => JSON.FromJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f,JSON.FromJSON g,JSON.FromJSON h,JSON.FromJSON i,JSON.FromJSON j,JSON.FromJSON k,JSON.FromJSON l,JSON.FromJSON m,JSON.FromJSON n,JSON.FromJSON o) => JSON.FromJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f,JSON.FromJSON g,JSON.FromJSON h,JSON.FromJSON i,JSON.FromJSON j,JSON.FromJSON k,JSON.FromJSON l,JSON.FromJSON m,JSON.FromJSON n,JSON.FromJSON o,JSON.FromJSON p) => JSON.FromJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f,JSON.FromJSON g,JSON.FromJSON h,JSON.FromJSON i,JSON.FromJSON j,JSON.FromJSON k,JSON.FromJSON l,JSON.FromJSON m,JSON.FromJSON n,JSON.FromJSON o,JSON.FromJSON p,JSON.FromJSON q) => JSON.FromJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f,JSON.FromJSON g,JSON.FromJSON h,JSON.FromJSON i,JSON.FromJSON j,JSON.FromJSON k,JSON.FromJSON l,JSON.FromJSON m,JSON.FromJSON n,JSON.FromJSON o,JSON.FromJSON p,JSON.FromJSON q,JSON.FromJSON r) => JSON.FromJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f,JSON.FromJSON g,JSON.FromJSON h,JSON.FromJSON i,JSON.FromJSON j,JSON.FromJSON k,JSON.FromJSON l,JSON.FromJSON m,JSON.FromJSON n,JSON.FromJSON o,JSON.FromJSON p,JSON.FromJSON q,JSON.FromJSON r,JSON.FromJSON s) => JSON.FromJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f,JSON.FromJSON g,JSON.FromJSON h,JSON.FromJSON i,JSON.FromJSON j,JSON.FromJSON k,JSON.FromJSON l,JSON.FromJSON m,JSON.FromJSON n,JSON.FromJSON o,JSON.FromJSON p,JSON.FromJSON q,JSON.FromJSON r,JSON.FromJSON s,JSON.FromJSON t) => JSON.FromJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f,JSON.FromJSON g,JSON.FromJSON h,JSON.FromJSON i,JSON.FromJSON j,JSON.FromJSON k,JSON.FromJSON l,JSON.FromJSON m,JSON.FromJSON n,JSON.FromJSON o,JSON.FromJSON p,JSON.FromJSON q,JSON.FromJSON r,JSON.FromJSON s,JSON.FromJSON t,JSON.FromJSON u) => JSON.FromJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f,JSON.FromJSON g,JSON.FromJSON h,JSON.FromJSON i,JSON.FromJSON j,JSON.FromJSON k,JSON.FromJSON l,JSON.FromJSON m,JSON.FromJSON n,JSON.FromJSON o,JSON.FromJSON p,JSON.FromJSON q,JSON.FromJSON r,JSON.FromJSON s,JSON.FromJSON t,JSON.FromJSON u,JSON.FromJSON v) => JSON.FromJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f,JSON.FromJSON g,JSON.FromJSON h,JSON.FromJSON i,JSON.FromJSON j,JSON.FromJSON k,JSON.FromJSON l,JSON.FromJSON m,JSON.FromJSON n,JSON.FromJSON o,JSON.FromJSON p,JSON.FromJSON q,JSON.FromJSON r,JSON.FromJSON s,JSON.FromJSON t,JSON.FromJSON u,JSON.FromJSON v,JSON.FromJSON w) => JSON.FromJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f,JSON.FromJSON g,JSON.FromJSON h,JSON.FromJSON i,JSON.FromJSON j,JSON.FromJSON k,JSON.FromJSON l,JSON.FromJSON m,JSON.FromJSON n,JSON.FromJSON o,JSON.FromJSON p,JSON.FromJSON q,JSON.FromJSON r,JSON.FromJSON s,JSON.FromJSON t,JSON.FromJSON u,JSON.FromJSON v,JSON.FromJSON w,JSON.FromJSON x) => JSON.FromJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f,JSON.FromJSON g,JSON.FromJSON h,JSON.FromJSON i,JSON.FromJSON j,JSON.FromJSON k,JSON.FromJSON l,JSON.FromJSON m,JSON.FromJSON n,JSON.FromJSON o,JSON.FromJSON p,JSON.FromJSON q,JSON.FromJSON r,JSON.FromJSON s,JSON.FromJSON t,JSON.FromJSON u,JSON.FromJSON v,JSON.FromJSON w,JSON.FromJSON x,JSON.FromJSON y) => JSON.FromJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y)


instance (JSON.FromJSON a,JSON.FromJSON b,JSON.FromJSON c,JSON.FromJSON d,JSON.FromJSON e,JSON.FromJSON f,JSON.FromJSON g,JSON.FromJSON h,JSON.FromJSON i,JSON.FromJSON j,JSON.FromJSON k,JSON.FromJSON l,JSON.FromJSON m,JSON.FromJSON n,JSON.FromJSON o,JSON.FromJSON p,JSON.FromJSON q,JSON.FromJSON r,JSON.FromJSON s,JSON.FromJSON t,JSON.FromJSON u,JSON.FromJSON v,JSON.FromJSON w,JSON.FromJSON x,JSON.FromJSON y,JSON.FromJSON z) => JSON.FromJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z)


instance (JSON.FromJSON e,ArrayElem e) => JSON.FromJSON (JArray e)


instance (JSON.ToJSON a,JSON.ToJSON b) => JSON.ToJSON (a | b)


instance (JSON.ToJSON a,JSON.ToJSON b) => JSON.ToJSON (a,b)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c) => JSON.ToJSON (a,b,c)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d) => JSON.ToJSON (a,b,c,d)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e) => JSON.ToJSON (a,b,c,d,e)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f) => JSON.ToJSON (a,b,c,d,e,f)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f,JSON.ToJSON g) => JSON.ToJSON (a,b,c,d,e,f,g)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f,JSON.ToJSON g,JSON.ToJSON h) => JSON.ToJSON (a,b,c,d,e,f,g,h)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f,JSON.ToJSON g,JSON.ToJSON h,JSON.ToJSON i) => JSON.ToJSON (a,b,c,d,e,f,g,h,i)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f,JSON.ToJSON g,JSON.ToJSON h,JSON.ToJSON i,JSON.ToJSON j) => JSON.ToJSON (a,b,c,d,e,f,g,h,i,j)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f,JSON.ToJSON g,JSON.ToJSON h,JSON.ToJSON i,JSON.ToJSON j,JSON.ToJSON k) => JSON.ToJSON (a,b,c,d,e,f,g,h,i,j,k)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f,JSON.ToJSON g,JSON.ToJSON h,JSON.ToJSON i,JSON.ToJSON j,JSON.ToJSON k,JSON.ToJSON l) => JSON.ToJSON (a,b,c,d,e,f,g,h,i,j,k,l)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f,JSON.ToJSON g,JSON.ToJSON h,JSON.ToJSON i,JSON.ToJSON j,JSON.ToJSON k,JSON.ToJSON l,JSON.ToJSON m) => JSON.ToJSON (a,b,c,d,e,f,g,h,i,j,k,l,m)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f,JSON.ToJSON g,JSON.ToJSON h,JSON.ToJSON i,JSON.ToJSON j,JSON.ToJSON k,JSON.ToJSON l,JSON.ToJSON m,JSON.ToJSON n) => JSON.ToJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f,JSON.ToJSON g,JSON.ToJSON h,JSON.ToJSON i,JSON.ToJSON j,JSON.ToJSON k,JSON.ToJSON l,JSON.ToJSON m,JSON.ToJSON n,JSON.ToJSON o) => JSON.ToJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f,JSON.ToJSON g,JSON.ToJSON h,JSON.ToJSON i,JSON.ToJSON j,JSON.ToJSON k,JSON.ToJSON l,JSON.ToJSON m,JSON.ToJSON n,JSON.ToJSON o,JSON.ToJSON p) => JSON.ToJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f,JSON.ToJSON g,JSON.ToJSON h,JSON.ToJSON i,JSON.ToJSON j,JSON.ToJSON k,JSON.ToJSON l,JSON.ToJSON m,JSON.ToJSON n,JSON.ToJSON o,JSON.ToJSON p,JSON.ToJSON q) => JSON.ToJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f,JSON.ToJSON g,JSON.ToJSON h,JSON.ToJSON i,JSON.ToJSON j,JSON.ToJSON k,JSON.ToJSON l,JSON.ToJSON m,JSON.ToJSON n,JSON.ToJSON o,JSON.ToJSON p,JSON.ToJSON q,JSON.ToJSON r) => JSON.ToJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f,JSON.ToJSON g,JSON.ToJSON h,JSON.ToJSON i,JSON.ToJSON j,JSON.ToJSON k,JSON.ToJSON l,JSON.ToJSON m,JSON.ToJSON n,JSON.ToJSON o,JSON.ToJSON p,JSON.ToJSON q,JSON.ToJSON r,JSON.ToJSON s) => JSON.ToJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f,JSON.ToJSON g,JSON.ToJSON h,JSON.ToJSON i,JSON.ToJSON j,JSON.ToJSON k,JSON.ToJSON l,JSON.ToJSON m,JSON.ToJSON n,JSON.ToJSON o,JSON.ToJSON p,JSON.ToJSON q,JSON.ToJSON r,JSON.ToJSON s,JSON.ToJSON t) => JSON.ToJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f,JSON.ToJSON g,JSON.ToJSON h,JSON.ToJSON i,JSON.ToJSON j,JSON.ToJSON k,JSON.ToJSON l,JSON.ToJSON m,JSON.ToJSON n,JSON.ToJSON o,JSON.ToJSON p,JSON.ToJSON q,JSON.ToJSON r,JSON.ToJSON s,JSON.ToJSON t,JSON.ToJSON u) => JSON.ToJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f,JSON.ToJSON g,JSON.ToJSON h,JSON.ToJSON i,JSON.ToJSON j,JSON.ToJSON k,JSON.ToJSON l,JSON.ToJSON m,JSON.ToJSON n,JSON.ToJSON o,JSON.ToJSON p,JSON.ToJSON q,JSON.ToJSON r,JSON.ToJSON s,JSON.ToJSON t,JSON.ToJSON u,JSON.ToJSON v) => JSON.ToJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f,JSON.ToJSON g,JSON.ToJSON h,JSON.ToJSON i,JSON.ToJSON j,JSON.ToJSON k,JSON.ToJSON l,JSON.ToJSON m,JSON.ToJSON n,JSON.ToJSON o,JSON.ToJSON p,JSON.ToJSON q,JSON.ToJSON r,JSON.ToJSON s,JSON.ToJSON t,JSON.ToJSON u,JSON.ToJSON v,JSON.ToJSON w) => JSON.ToJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f,JSON.ToJSON g,JSON.ToJSON h,JSON.ToJSON i,JSON.ToJSON j,JSON.ToJSON k,JSON.ToJSON l,JSON.ToJSON m,JSON.ToJSON n,JSON.ToJSON o,JSON.ToJSON p,JSON.ToJSON q,JSON.ToJSON r,JSON.ToJSON s,JSON.ToJSON t,JSON.ToJSON u,JSON.ToJSON v,JSON.ToJSON w,JSON.ToJSON x) => JSON.ToJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f,JSON.ToJSON g,JSON.ToJSON h,JSON.ToJSON i,JSON.ToJSON j,JSON.ToJSON k,JSON.ToJSON l,JSON.ToJSON m,JSON.ToJSON n,JSON.ToJSON o,JSON.ToJSON p,JSON.ToJSON q,JSON.ToJSON r,JSON.ToJSON s,JSON.ToJSON t,JSON.ToJSON u,JSON.ToJSON v,JSON.ToJSON w,JSON.ToJSON x,JSON.ToJSON y) => JSON.ToJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y)


instance (JSON.ToJSON a,JSON.ToJSON b,JSON.ToJSON c,JSON.ToJSON d,JSON.ToJSON e,JSON.ToJSON f,JSON.ToJSON g,JSON.ToJSON h,JSON.ToJSON i,JSON.ToJSON j,JSON.ToJSON k,JSON.ToJSON l,JSON.ToJSON m,JSON.ToJSON n,JSON.ToJSON o,JSON.ToJSON p,JSON.ToJSON q,JSON.ToJSON r,JSON.ToJSON s,JSON.ToJSON t,JSON.ToJSON u,JSON.ToJSON v,JSON.ToJSON w,JSON.ToJSON x,JSON.ToJSON y,JSON.ToJSON z) => JSON.ToJSON (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z)

-- |  > [ value, ... ]   
Array :: [JSON.Value] -> JSON.Value

-- |  @true@ or @false@      
Bool :: Bool -> JSON.Value


instance Eq JSON.Token


instance Eq JSON.Value

-- |     Class of types whose values can be reconstructed from JSON.
-- 
--     There are two ways to accomplish this:
-- 
--     1. take a JSON 'Value' and try to reconstruct a value of the desired type,
--        that is, implement function 'fromJSON'
--     2. write a 'Parser' that produces the desired value directly and use
--        this to implement 'parseJSON'
-- 
--     The usual way is to implement 'fromJSON' and keep the default for 'parseJSON', 
--     which parses a 'String' to a  'Value' and passes that value to 'fromJSON'.
-- 
--     Minimal complete definition: 'fromJSON'
-- 
--     The instances of all standard types that are not encoded as objects will
--     have an implementation of 'parseJSON' that fails immediately. This behaviour 
--     is in line with the JSON standard which allows only objects
--     (that is, maps or arrays) to appear on the top level.
-- 
--      
class FromJSON


instance JSON.FromJSON ()


instance JSON.FromJSON Bool


instance JSON.FromJSON Byte


instance JSON.FromJSON Char


instance JSON.FromJSON Double


instance JSON.FromJSON Float


instance JSON.FromJSON Int


instance JSON.FromJSON Integer


instance JSON.FromJSON JSON.Value


instance JSON.FromJSON Long


instance JSON.FromJSON Short


instance JSON.FromJSON String


instance JSON.FromJSON e => JSON.FromJSON (Maybe e)


instance JSON.FromJSON e => JSON.FromJSON [e]


instance JSON.ToJSON ()


instance JSON.ToJSON Bool


instance JSON.ToJSON Byte


instance JSON.ToJSON Char


instance JSON.ToJSON Double


instance JSON.ToJSON Float


instance JSON.ToJSON Int


instance JSON.ToJSON Integer


instance JSON.ToJSON JSON.Value


instance JSON.ToJSON Long


instance JSON.ToJSON Short


instance JSON.ToJSON String


instance JSON.ToJSON e => JSON.ToJSON (JArray e)

-- |  'Maybe.toJSON' produces one of   
-- 
--  > {"Nothing" : null }   
-- 
--  > {"Just"    : v }   
-- 
--  For a more concise representation see 'maybeToJSON'   
instance JSON.ToJSON e => JSON.ToJSON (Maybe e)


instance JSON.ToJSON e => JSON.ToJSON [e]

-- |  just @null@   
Null :: JSON.Value

-- |  a number   
Number :: String -> JSON.Value

-- |  A JSON parser processes a list of 'Token's.   
type Parser = MicroParsec.Parser [] JSON.Token


instance Show JSON.Token


instance Show JSON.Value

-- |  a string   
String :: String -> JSON.Value

-- |  > { "name":value, ... }   
Struct :: [(String,JSON.Value)] -> JSON.Value

-- |     The class of types that support their serialization to JSON.
-- 
--     Note that the JSON value for primitive types and 'String's yields no
--     valid JSON document when printed.
--      
class ToJSON

-- |  lexical entities that can appear in a JSON String   
data Token

-- |  Internal representation of JSON data   
data Value

-- |  Make a single association    
assoc :: JSON.ToJSON b => String -> b -> (String,JSON.Value)

-- |  Extract a required field from an association list or 'fail' with an appropriate message.    
field :: (JSON.FromJSON b,MonadFail m) => String -> [(String,JSON.Value)] -> m b

-- |         Interpret a JSON value as a value of the instance type, or 'fail'.
-- 
--         This function must be implemented by all instances.
-- 
--         If one has a non-standard implementation of 'parseJSON' that does
--         not use 'fromJSON', a conforming, but inefficient implementation would be
-- 
--         > fromJSON = parseJSON . show 
--          
fromJSON :: (JSON.FromJSON a,MonadFail m) => JSON.Value -> m a

-- |  Convenience function to do 'fromJSON' in the 'Either' monad.   
fromJSONEither :: JSON.FromJSON b => JSON.Value -> (String | b)

-- |  Convenience function to do 'fromJSON' in the 'Maybe' monad.   
fromJSONMaybe :: JSON.FromJSON b => JSON.Value -> Maybe b

-- |     Translate a 'String' into a lazy list of 'Token's.
-- 
--     There will be at most one 'Token.ERROR' token in the result, 
--     and it will be the last in the list. This is, the 'lexer' will stop
--     on the first lexical error.
--     
--     Absence of lexical errors does not mean valid JSON, for example
--     > "null, true,"
--     is lexed as
--     > [NULL, COMMA, TRUE, COMMA]
--     but is, of course invalid.
--      
lexer :: String -> [JSON.Token]

-- |  The short encoding for 'Maybe' values.   
-- 
--  Produces 'Null' for 'Nothing' and the jsonized value for 'Just' value.   
-- 
--  The 'FromJSON' instance for 'Maybe' is prepared to deal with the different encodings.   
maybeToJSON :: JSON.ToJSON a => Maybe a -> JSON.Value

-- |  Convenience function for optional fields, use like   
-- 
--  >  foo ← optional  "foo" s   
-- 
--  This will decode any of the following   
-- 
--  > { ... }                       -- no "foo" in structure, hence Nothing   
-- 
--  > { ..., "foo" : null, ... }    -- again, foo is Nothing   
-- 
--  > { ..., "foo" : {"Nothing" : null}, ...} --- again Nothing   
-- 
--  > { ..., "foo" : 42, ...}       -- foo is Just 42   
-- 
--  > { ..., "foo" : {"Just" : 42}} -- foo is Just 42    
optional :: (JSON.FromJSON α,MonadFail m) => String -> [(String,JSON.Value)] -> m (Maybe α)

-- |  Parse a JSON array   
parseArray :: MicroParsec.Parser [] JSON.Token JSON.Value

-- |  parse a 'Bool'   
parseBool :: MicroParsec.Parser [] JSON.Token Bool

-- |  Parse a JSON boolean   
parseBoolean :: MicroParsec.Parser [] JSON.Token JSON.Value

-- |  parse a colon   
parseColon :: MicroParsec.Parser [] JSON.Token JSON.Token

-- |  parse a comma   
parseComma :: MicroParsec.Parser [] JSON.Token JSON.Token

-- |  parse a raw 'Double'   
parseDouble :: MicroParsec.Parser [] JSON.Token Double

-- |  parse a raw 'Float'   
parseFloat :: MicroParsec.Parser [] JSON.Token Float

-- |  parse an 'Int'   
parseInt :: MicroParsec.Parser [] JSON.Token Int

-- |  parse an 'Integer'   
parseInteger :: MicroParsec.Parser [] JSON.Token Integer

-- |         Parse a 'String' which must contain valid JSON, and interpret
--         as value of the instance type.
-- 
--         The standard implementation uses 'parseObject' to make a JSON
--         'Value' that is passed on to 'fromJSON'.
--          
parseJSON :: (JSON.FromJSON a,MonadFail m) => String -> m a

-- |  parse a left brace   
parseLbrace :: MicroParsec.Parser [] JSON.Token JSON.Token

-- |  parse a left bracket   
parseLbrack :: MicroParsec.Parser [] JSON.Token JSON.Token

-- |  parse a list   
-- 
--  For example,    
-- 
--  > parseList parseFloat   
-- 
--  produces a [Float] directly   
parseList :: MicroParsec.Parser [] JSON.Token a -> MicroParsec.Parser [] JSON.Token [a]

-- |  parse a 'Long'   
parseLong :: MicroParsec.Parser [] JSON.Token Long

-- |  Parse JSON @null@   
parseNull :: MicroParsec.Parser [] JSON.Token JSON.Value

-- |  Parse a JSON number   
parseNumber :: MicroParsec.Parser [] JSON.Token JSON.Value

-- |  Parses an 'Array' or a 'Struct'   
-- 
--  This is the parser that will be used in type class 'FromJSON' by default.   
-- 
--  This parser fails unless it could consume all input.   
parseObject :: MicroParsec.Parser [] JSON.Token JSON.Value

-- |  parse a pair @"string" : v@   
parsePair :: MicroParsec.Parser [] JSON.Token v -> MicroParsec.Parser [] JSON.Token (String,v)

-- |  parse a right brace   
parseRbrace :: MicroParsec.Parser [] JSON.Token JSON.Token

-- |  parse a right bracket   
parseRbrack :: MicroParsec.Parser [] JSON.Token JSON.Token

-- |  parse a 'String'   
parseString :: MicroParsec.Parser [] JSON.Token String

-- |  Parse a JSON struct   
-- 
--  If one and the same key appears multiple times, only the last one will be taken into account.   
parseStruct :: MicroParsec.Parser [] JSON.Token JSON.Value

-- |  parse a raw tuple   
-- 
--  Use like   
-- 
--  > parseTuple (parseFloat, parseString)   
-- 
--  This would produce @(Float, String)@   
parseTuple :: (MicroParsec.Parser [] JSON.Token a,MicroParsec.Parser [] JSON.Token b) -> MicroParsec.Parser [] JSON.Token (a,b)

-- |  parse any JSON value   
parseValue :: MicroParsec.Parser [] JSON.Token JSON.Value

-- |  run a 'Parser' and extract the result    
runParser :: MicroParsec.Parser [] JSON.Token a -> [JSON.Token] -> (String | a)

-- |  Make a 'Struct' with just a single association, suitable for variants   
struct :: JSON.ToJSON a => String -> a -> JSON.Value


toJSON :: JSON.ToJSON a => a -> JSON.Value

-- |     Pretty print a 'Value'.
--     
--     This is used in the 'Show' instance for 'Value', but can be useful otherwise.
--     For example, to print a large 'Value' directly to 'stdout' without
--     realizing the full intermediate 'String' in memory with a line width of 
--     120 use:
--     > import Lib.PP(prettyIO)
--     > prettyIO stdout 120 . valDoc
--      
valDoc :: JSON.Value -> PP.DOCUMENT



-- |     This package provides common list functions for the Frege language.
--     
--     It contains all functions described in chapter 20 "Data.List" of the 
--     _Haskell 2010 Language Report_. Where possible, the code has been ported
--     from public Haskell source code 
--     (http://www.haskell.org/ghc/docs/latest/html/libraries/base/src/Data-List.html).
--    
--       
module frege.data.List
-- |     @xs !! n@ is the element with index _n_ of the list _xs_,
--     where the head element of a list has index 0.
--      
(!!) :: [a] -> Int -> a

-- |     The '\\' function is list difference (non-associative).
--     In the result of @xs@ '\\' @ys@, the first occurrence of each element of
--     @ys@ in turn (if any) has been removed from @xs@.  Thus
-- 
--     > (xs ++ ys) \\ xs == ys.
--     
--     It is a special case of 'deleteFirstsBy', which allows the programmer
--     to supply their own equality test.
--          
(\\) :: Eq a => [a] -> [a] -> [a]

-- |     'delete' @x@ removes the first occurrence of @x@ from its list argument. 
--     For example,
--     
--     > delete ’a’ "banana" == "bnana"
-- 
--     It is a special case of 'deleteBy', which allows the programmer to supply their own equality test.
--     
--          
delete :: Eq a => a -> [a] -> [a]

-- |  The 'deleteBy' function behaves like 'delete', but takes a user-supplied equality predicate.   
deleteBy :: (b->a->Bool) -> b -> [a] -> [a]

-- |     The 'deleteFirstsBy' function takes a predicate and two lists and
--     returns the first list with the first occurrence of each element of
--     the second list removed.
--          
deleteFirstsBy :: (a->b->Bool) -> [b] -> [a] -> [b]

-- |     @dropUntil p xs@ is the same as @dropWhile (not • p) xs@
-- 
--     Consequently, for all lists /xs/
--     > takeUntil p xs ++ dropUntil p xs == xs
--          
dropUntil :: (a->Bool) -> [a] -> [a]

-- |  @elemBy f@ is a more general version of 'elem' that uses /f/ instead of '=='.   
-- 
--  See also: 'using'   
elemBy :: (a->b->Bool) -> a -> [b] -> Bool

-- |     The 'elemIndex' function returns the index of the first element
--     in the given list which is equal (by '==') to the query element,
--     or 'Nothing' if there is no such element.
--      
elemIndex :: Eq a => a -> [a] -> Maybe Int

-- |     The 'elemIndices' function extends 'elemIndex', by returning the
--     indices of all elements equal to the query element, in ascending order.
--          
elemIndices :: Eq a => a -> [a] -> [Int]

-- |     The 'find' function takes a predicate and a list and returns the
--     first element in the list matching the predicate, or 'Nothing' if
--     there is no such element.
--          
find :: (a -> Bool) -> [a] -> Maybe a

-- |     The 'findIndex' function takes a predicate and a list and returns
--     the index of the first element in the list satisfying the predicate,
--     or 'Nothing' if there is no such element.
--          
findIndex :: (a -> Bool) -> [a] -> Maybe Int

-- |     The 'findIndices' function extends 'findIndex', by returning the
--     indices of all elements satisfying the predicate, in ascending order.
--      
findIndices :: (a -> Bool) -> [a] -> [Int]

-- |     The 'genericDrop' function is an overloaded version of 'drop', which
--     accepts any 'Integral' value as the number of elements to drop.
--          
genericDrop :: Integral i => i -> [a] -> [a]

-- |     The 'genericIndex' function is an overloaded version of '!!', which
--     accepts any 'Integral' value as the index.
--          
genericIndex :: Integral a => [b] -> a -> b

-- |     The 'genericLength' function is an overloaded version of 'length'.  In
--     particular, instead of returning an 'Int', it returns any type which is
--     an instance of 'Num'.  It is, however, less efficient than 'length'.
--          
genericLength :: Num i => [b] -> i

-- |     The 'genericReplicate' function is an overloaded version of 'replicate',
--     which accepts any 'Integral' value as the number of repetitions to make.
--          
genericReplicate :: Integral i => i -> a -> [a]

-- |     The 'genericSplitAt' function is an overloaded version of 'splitAt', which
--     accepts any 'Integral' value as the position at which to split.
--          
genericSplitAt :: Integral i => i -> [b] -> ([b],[b])

-- |     The 'genericTake' function is an overloaded version of 'take', which
--     accepts any 'Integral' value as the number of elements to take.
--          
genericTake :: Integral i => i -> [a] -> [a]

-- |     @group xs@ returns a list of sub-lists made of adjacent equal elements in @xs@.
--     All sublist are not empty and their concatenation yields again @xs@.
--          
group :: Eq a => [a] -> [[a]]

-- |     @groupBy f xs@ groups by function @f@ instead of (==) that is used by @group@
--          
groupBy :: (a->a->Bool) -> [a] -> [[a]]

-- |     The 'inits' function returns all initial segments of the argument,
--     shortest first.  For example,
-- 
--     > inits "abc" == ["","a","ab","abc"]
--          
inits :: [a] -> [[a]]


insert :: Ord a => a -> [a] -> [a]

-- |  The non-overloaded version of 'insert'.   
insertBy :: (a->a->Ordering) -> a -> [a] -> [a]

-- |     @intercalate xs xss@ is equivalent to @concat (intersperse xs xss)@    
--          
intercalate :: (ListEmpty a,ListSemigroup a) => a b -> [a b] -> a b

-- |     The 'intersect' function takes the list intersection of two lists.
--     For example,
-- 
--     > [1,2,3,4] `intersect` [2,4,6,8] == [2,4]
-- 
--     If the first list contains duplicates, so will the result.
-- 
--     > [1,2,2,3,4] `intersect` [6,4,4,2] == [2,2,4]
-- 
--     It is a special case of 'intersectBy', which allows the programmer to
--     supply their own equality test.
--          
intersect :: Eq a => [a] -> [a] -> [a]

-- |  The 'intersectBy' function is the non-overloaded version of 'intersect'.   
intersectBy :: ListSource a => (b->c->Bool) -> a b -> [c] -> [b]

-- |     @intersperse a xs@ inserts _a_ between every two elements of _xs_
--     > intersperse 0 (1..3) == [1,0,2,0,3]
--          
intersperse :: a -> [a] -> [a]

-- |     The 'isInfixOf' function takes two lists and returns @true@
--     iff the first list is contained, wholly and intact,
--     anywhere within the second.
-- 
--     Example:
-- 
--     > isInfixOf "Haskell" "I really like Haskell." == true
--     > isInfixOf "Ial" "I really like Haskell." == false
--      
isInfixOf :: Eq a => [a] -> [a] -> Bool

-- |     The 'isPrefixOf' function takes two lists and returns @true@
--     iff the first list is a prefix of the second.
--          
isPrefixOf :: Eq a => [a] -> [a] -> Bool

-- |     The 'isSuffixOf' function takes two lists and returns @true@
--     iff the first list is a suffix of the second.
--     Both lists must be finite.
--          
isSuffixOf :: Eq a => [a] -> [a] -> Bool

-- |  lookup a key in an association list   
lookup :: Eq a => a -> [(a,b)] -> Maybe b

-- |     The 'mapAccumL' function behaves like a combination of 'map' and
--     'fold'; it applies a function to each element of a list, passing
--     an accumulating parameter from left to right, and returning a final
--     value of this accumulator together with the new list.
--          
mapAccumL :: (acc -> x -> (acc,y)) -> acc -> [x] -> (acc,[y])

-- |     The 'mapAccumR' function behaves like a combination of 'map' and
--     'foldr'; it applies a function to each element of a list, passing
--     an accumulating parameter from right to left, and returning a final
--     value of this accumulator together with the new list.
--          
mapAccumR :: (acc -> x -> (acc,y)) -> acc -> [x] -> (acc,[y])

-- |     The 'maximumBy' function takes a comparison function and a list
--     and returns the greatest element of the list by the comparison function.
--     The list must be finite and non-empty.
--          
maximumBy :: (a->a->Ordering) -> [a] -> a

-- |     Merge two lists, taking elements from the left as long as
--     they are not 'Gt' (according to the passed comparison function)
--     than the head element from the right.
--     
--     Makes most sense when the lists are sorted by the same criteria.
--          
merge :: (a->a->Ordering) -> [a] -> [a] -> [a]

-- |     The 'minimumBy' function takes a comparison function and a list
--     and returns the least element of the list by the comparison function.
--     The list must be finite and non-empty.
--          
minimumBy :: (a->a->Ordering) -> [a] -> a

-- |     The 'nonEmptySubsequences' function returns the list of all subsequences 
--     of the argument, except for the empty list.
--     > nonEmptySubsequences "abc" == ["a","b","ab","c","ac","bc","abc"]
--          
nonEmptySubsequences :: [a] -> [[a]]

-- |     'unique' removes duplicate elements from an unsorted list,
--     which may or may not be faster than using @(uniq • sort)@
--     
--     This function is known as @nub@ in Haskell and Prelude provides this as alias.
-- 
--     However, the following holds
--     > sort (unique xs) == uniq (sort xs)
--       
nub :: Eq a => [a] -> [a]

-- |     @uniqueBy f@ is a more general form of 'unique',
--     but uses @f@ instead of '==' to decide
--     whether equal elements are contained in the list.
-- 
--     The following holds:
--     > sortBy (comparing f) (uniqueBy (using f) xs) == uniqBy (using f) (sortBy (comparing f) xs)
--          
nubBy :: (a->a->Bool) -> [a] -> [a]

-- |      A variant of 'partition' that satisfies the Haskell 2010 specification.
--     When the order of the results is irrelevant or one actually wants the results reversed, 
--     consider the more efficient 'partitioned'.
--          
partition :: (a->Bool) -> [a] -> ([a],[a])

-- |     @partitioned p xs@ splits _xs_ in 2 lists and returns them as a tuple @(xs1, xs2)@,
--     such that  _xs1_
--     contains all elements of _xs_ that satisfy predicate _p_ and _xs2_ contains
--     those that do not.
-- 
--     The order of the elements of _xs_ is reversed in the results.
--     The argument must be finite, it is processed in a tail recursive loop.
--     
--     See also 'partition', which is lazy and works on infinite lists, but may be slower
--     on finite lists because it processes the argument twice.
-- 
--     The following is true for all finite lists xs
--     > let ps = partitionR p xs
--     > in    all p (fst ps)
--     >    && (not • any p) (snd ps)
--     >    && length (fst ps) + length (snd ps) == length xs
--     >    && all (`elem` xs) (fst ps)
--     >    && all (`elem` xs) (snd ps)
--     >    && all (\x -> x `elem` fst ps || x `elem` snd ps) xs
--          
partitioned :: (a->Bool) -> [a] -> ([a],[a])

-- |  The 'permutations' function returns the list of all permutations of the argument.   
-- 
--  > permutations "abc" == ["abc","bac","cba","bca","cab","acb"]   
permutations :: [a] -> [[a]]

-- |     Standard sort uses operator '<=>' and demands that the type of 
--     the list elements is an instance of 'Ord'
--          
sort :: (Ord a,ListSource b) => b a -> [a]

-- |     @sortBy f xs@ is a stable sort (merge sort), it uses /f/ to decide the order of elements.
--     If @a `f` b@ is 'Lt' or 'Eq', then /a/ comes before /b/, otherwise /b/ comes before /a/.
-- 
--     see also 'comparing',  'descending'
--      
sortBy :: ListSource b => (a->a->Ordering) -> b a -> [a]

-- |     The 'stripPrefix' function drops the given prefix from a list.
--     It returns 'Nothing' if the list did not start with the prefix
--     given, or 'Just' the list after the prefix, if it does.
-- 
--     > stripPrefix "foo" "foobar" -> Just "bar"
--     > stripPrefix "foo" "foo" -> Just ""
--     > stripPrefix "foo" "barfoo" -> Nothing
--     > stripPrefix "foo" "barfoobaz" -> Nothing
--          
stripPrefix :: Eq a => [a] -> [a] -> Maybe [a]

-- |  The 'subsequences' function returns the list of all subsequences of the argument.   
-- 
--  > subsequences "abc" == ["","a","b","ab","c","ac","bc","abc"]   
subsequences :: [a] -> [[a]]

-- |     The 'tails' function returns all final segments of the argument,
--     longest first.  For example,
-- 
--     > tails "abc" == ["abc", "bc", "c",""]
--          
tails :: [a] -> [[a]]

-- |     @takeUntil p xs@ is the same as @takeWhile (not • p) xs@
--          
takeUntil :: (a->Bool) -> [a] -> [a]

-- |  The 'transpose' function transposes the rows and columns of its argument.   
-- 
--  For example,   
-- 
--  > transpose [[1,2,3],[4,5,6]] == [[1,4],[2,5],[3,6]]   
transpose :: [[a]] -> [[a]]

-- |    The 'unfoldr' function is a dual to 'foldr': while 'foldr'
--    reduces a list to a summary value, 'unfoldr' builds a list from
--    a seed value.  The function takes the element and returns 'Nothing'
--    if it is done producing the list or returns 'Just' @(a,b)@, in which
--    case, @a@ is a prepended to the list and @b@ is used as the next
--    element in a recursive call.  For example,
-- 
--    > iterate f == unfoldr (\x -> Just (x, f x))
-- 
--    In some cases, 'unfoldr' can undo a 'foldr' operation:
-- 
--    > unfoldr f' (foldr f z xs) == xs
-- 
--    if the following holds:
-- 
--    > f' (f x y) = Just (x,y)
--    > f' z       = Nothing
-- 
--    A simple use of unfoldr:
-- 
--    > unfoldr (\b -> if b == 0 then Nothing else Just (b, b-1)) 10
--    >  [10,9,8,7,6,5,4,3,2,1]
--      
unfoldr :: (b -> Maybe (a,b)) -> b -> [a]

-- |     The 'union' function returns the list union of the two lists.
--     For example,
--     
--     > "dog" `union` "cow" == "dogcw"
-- 
--     Duplicates, and elements of the first list, are removed from the
--     the second list, but if the first list contains duplicates, so will
--     the result.
--     
--     It is a special case of 'unionBy', which allows the programmer to supply
--     their own equality test.
--          
union :: Eq a => [a] -> [a] -> [a]

-- |  The 'unionBy' function is the non-overloaded version of 'union'.   
unionBy :: (a->a->Bool) -> [a] -> [a] -> [a]

-- |     'uniq' removes adjacent equal elements from a list
--     > uniq [1, 2, 2, 3, 2] = [1, 2, 3, 2]
--     This is most useful on sorted lists to remove duplicates.
--     For unsorted lists use 'unique'
--          
uniq :: Eq a => [a] -> [a]

-- |     @uniqBy f@ is a variant of 'uniq' that uses _f_ instead of '=='.
--     In the result, there are no two adjacent elements _x_ and _y_ where
--     the relation @y `f` x@ holds.
-- 
--     This is most useful on sorted lists with projection functions that
--     compare parts of the value for equality. See also 'using'.
-- 
--     > uniqBy (using fst) [(1, 1), (2, 2), (2, 3), (3, 4), (2, 5)]
--     >   = uniqBy (\a\b -> fst a == fst b) [(1, 1), (2, 2), (2, 3), (3, 4), (2, 5)]
--     >   = [(1, 1), (2, 2), (3, 4), (2, 5)]
-- 
--     The example shows that the first of adjacent, equal comparing elements is retained.
--       
uniqBy :: (a->a->Bool) -> [a] -> [a]

-- |     'unique' removes duplicate elements from an unsorted list,
--     which may or may not be faster than using @(uniq • sort)@
--     
--     This function is known as @nub@ in Haskell and Prelude provides this as alias.
-- 
--     However, the following holds
--     > sort (unique xs) == uniq (sort xs)
--       
unique :: Eq a => [a] -> [a]

-- |     @uniqueBy f@ is a more general form of 'unique',
--     but uses @f@ instead of '==' to decide
--     whether equal elements are contained in the list.
-- 
--     The following holds:
--     > sortBy (comparing f) (uniqueBy (using f) xs) == uniqBy (using f) (sortBy (comparing f) xs)
--          
uniqueBy :: (a->a->Bool) -> [a] -> [a]

-- |  'unzip4' unzips a list of quadrupels and returns a quadrupel of lists.   
unzip4 :: [(b,a,d,c)] -> ([b],[a],[d],[c])

-- |  'unzip5' unzips a list of quintupels and returns a quintupel of lists.   
unzip5 :: [(e,b,a,c,d)] -> ([e],[b],[a],[c],[d])

-- |  'unzip6' unzips a list of sextupels and returns a sextupel of lists.   
unzip6 :: [(c,a,b,e,d,f)] -> ([c],[a],[b],[e],[d],[f])

-- |  'unzip7' unzips a list of septupels and returns a septupel of lists.   
unzip7 :: [(g,e,f,b,a,c,d)] -> ([g],[e],[f],[b],[a],[c],[d])

-- |  'zip4' zips 4 lists in the same way as 'zip' does it.   
zip4 :: [b] -> [a] -> [d] -> [c] -> [(b,a,d,c)]

-- |  'zip5' zips 5 lists in the same way as 'zip' does it.   
zip5 :: [e] -> [b] -> [a] -> [d] -> [c] -> [(e,b,a,d,c)]

-- |  'zip6' zips 6 lists in the same way as 'zip' does it.   
zip6 :: [a] -> [c] -> [b] -> [e] -> [d] -> [f] -> [(a,c,b,e,d,f)]

-- |  'zip7' zips 7 lists in the same way as 'zip' does it.   
zip7 :: [b] -> [a] -> [e] -> [d] -> [g] -> [f] -> [c] -> [(b,a,e,d,g,f,c)]

-- |  'zipWith4' /f/ zips 4 lists with function /f/ instead of the standard '(,,,)' that is used by 'zip4'   
zipWith4 :: (a->b->c->d->e) -> [a] -> [b] -> [c] -> [d] -> [e]

-- |  'zipWith5' /f/ zips 5 lists with function /f/ instead of the standard '(,,,,)' that is used by 'zip5'   
zipWith5 :: (b->c->e->f->d->a) -> [b] -> [c] -> [e] -> [f] -> [d] -> [a]

-- |  'zipWith6' /f/ zips 6 lists with function /f/ instead of the standard '(,,,,,)' that is used by 'zip6'   
zipWith6 :: (d->b->c->f->g->e->a) -> [d] -> [b] -> [c] -> [f] -> [g] -> [e] -> [a]

-- |  'zipWith7' /f/ zips 7 lists with function /f/ instead of the standard '(,,,,,,)' that is used by 'zip7'   
zipWith7 :: (h->c->d->a->b->e->f->g) -> [h] -> [c] -> [d] -> [a] -> [b] -> [e] -> [f] -> [g]



-- |     This package simply re-exports what is required by Haskell 2010    
--      
module frege.data.Maybe

Just :: a -> Maybe a


data Maybe


Nothing :: Maybe a

-- |  The 'catMaybes' function takes a list of 'Maybe's and returns a list of all the 'Just' values.   
catMaybes :: ListSource b => b (Maybe a) -> [a]

-- |  @unJust Nothing@ is 'undefined' whereas @unJust (Just a)@ is @a@   
fromJust :: Maybe a -> a

-- |  @fromMaybe d (Just a)@ returns @a@ and @fromMaybe d Nothing@ returns @d@   
fromMaybe :: a -> Maybe a -> a

-- |  @true@ if and only if the argument is a 'Just' value   
isJust :: Maybe a -> Bool

-- |  @true@ if and only if the argument is 'Nothing'   
-- 
--  This function is preferable over @v == Nothing@ because no 'Eq' constraint is needed.   
isNothing :: Maybe a -> Bool

-- |  give the first element of a list or 'Nothing'   
listToMaybe :: ListSource a => a b -> Maybe b

-- |     The 'mapMaybe' function is a version of 'map' which can throw out elements. 
--     In particular, the functional argument returns something of type 'Maybe' _b_. 
--     If this is 'Nothing', no element is added on to the result list. 
--     If it just 'Just' _b_, then _b_ is included in the result list.
--          
mapMaybe :: (b->Maybe a) -> [b] -> [a]

-- |     The 'maybe' function takes a default value, a function, and a 'Maybe' value. 
--     If the 'Maybe' value is 'Nothing', the function returns the default value. 
--     Otherwise, it applies the function to the value inside the 'Just' and returns the result.
--          
maybe :: a -> (b->a) -> Maybe b -> a



-- |  Small parser, inspired by Parsec, but much less versatile.   
--  A bit faster and uses less memory than the transformer in Data.NanoParsec.   
module frege.data.MicroParsec
-- |     > p <?> msg
--     
--     Causes the error message to be _msg_ when _p_ fails.
--     
--     The error will be reported at the position where _p_ failed.
--      
(<?>) :: MicroParsec.Parser b a c -> String -> MicroParsec.Parser b a c


instance MonadAlt (MicroParsec.Parser s t)

-- |     Parser Monad
--     
--     > Parser s t m r
--     
--     is the type of parsers that reads tokens of type _t_
--     from a stream _s t_ and returns either an error message string
--     or a result _r_ paired with the yet unprocessed input.
--     
--     
--     Works in principle like a combination of 
--     'State' and 'Either', 
--     where the state is the current input to get parsed, and the bind operations 
--     will stop on the first 'Left' result, which signals a syntax error.
--     
--     'Parser' is also an instance of 'MonadAlt'. The operations '<+>' and '<|>'
--     can be used to implement choice, i.e. they allow to continue on failure. 
--     
--     The input for a 'Parser' must be something that is an instance of 'ListView'.
--     Ordinary lists, 'String's, 'frege.data.Iterators#StringIterator'
--     and 'frege.data.Iterators#ArrayIterator' are such types. The parser
--     combinators use only the 'uncons' and 'null' operations.
--      
data Parser

-- |  > between left right p    
-- 
--  Parses _left_, then _p_ and finally _right_ and returns the result of _p_   
between :: Monad c => c b -> c d -> c a -> c a

-- |  > choice ps   
-- 
--  Tries the parsers in the list from left to right, until success.    
choice :: Plus a => [a b] -> a b

-- |  > cond pcond pthen pelse   
-- 
--  if _pcond_ succeeds, then _pthen_ is run, else _pelse_   
-- 
--  To both _pthen_ and _pelse_ it will appear as if _pcond_ didn't consume any tokens.   
cond :: MicroParsec.Parser d a c -> MicroParsec.Parser d a b -> MicroParsec.Parser d a b -> MicroParsec.Parser d a b

-- |  > count n p   
-- 
--  Applies _p_ _n_ times and returns a list of the results   
count :: Monad a => Int -> a b -> a [b]


digit :: ListView a => MicroParsec.Parser a Char Char

-- |  > p `endBy` q   
-- 
--  Parses zero or more occurrences of _p_ separated and ended by _q_   
endBy :: MicroParsec.Parser b a d -> MicroParsec.Parser b a c -> MicroParsec.Parser b a [d]

-- |  > p `endBy1` q   
-- 
--  Parses one or more occurrences of _p_ separated and ended by _q_   
endBy1 :: MicroParsec.Parser c b d -> MicroParsec.Parser c b a -> MicroParsec.Parser c b [d]

-- |  The 'eos' parser succeeds if the input is empty.   
eos :: ListView a => MicroParsec.Parser a b ()

-- |  > exceptWhen prop   
-- 
--  Fails if and only if there is a next token _t_ and _prop t_ is true.   
-- 
--  Succeeds on end of stream or when the token does not satisfy the property.   
-- 
--  In other words, @exceptWhen p@ succeeds if and only if @satisfy p@ fails.   
exceptWhen :: ListView a => (b->Bool) -> MicroParsec.Parser a b ()

-- |     > expect t
--     This parser succeeds if the input is not empty and the head
--     of the input equals _t_. 
--      
expect :: (Show a,Eq a,ListView b) => a -> MicroParsec.Parser b a a

-- |  fail with given error message   
failure :: String -> MicroParsec.Parser c b a

-- |  Remember the current state of the input stream.   
-- 
--  'getPos' always succeeds.   
getPos :: MicroParsec.Parser b a (b a)

-- |     Causes the error message to be _msg_ when _p_ fails.
--     
--     The error will be reported at the position where _p_ was attempted,
--     not necessarily at the position where _p_ failed: 
--   
--     > Parser.run (letter >> digit) "a?"  
--     > unexpected token, found ?
--     > Parser.run (label "id expected" $ letter >> digit) "a?"
--     > id expected, found a?
--      
label :: String -> MicroParsec.Parser b a c -> MicroParsec.Parser b a c


letter :: ListView a => MicroParsec.Parser a Char Char

-- |  > many p   
-- 
--  Collects as many _p_ as possible and returns the results in a list.   
-- 
--  Succeeds also when _p_ fails the first time, in that case the result is an empty list.   
-- 
--  Must not be applied to a parser that always succeeds!   
many :: MicroParsec.Parser c b a -> MicroParsec.Parser c b [a]

-- |  > some p   
-- 
--  Like 'many', except there must be at least one _p_   
-- 
--  Must not be applied to a parser that always succeeds!   
many1 :: MicroParsec.Parser c b a -> MicroParsec.Parser c b [a]

-- |  > manyWhile p   
-- 
--  Collect tokens as long as they satisfy _p_   
manyWhile :: ListView b => (a->Bool) -> MicroParsec.Parser b a [a]

-- |  This parser succeeds if the pattern matches the beginning of the string.   
-- 
--  For efficiency reasons, the pattern should start with @^@   
match :: Regex -> MicroParsec.Parser StringJ Char MatchResult


modifyPos :: (b a->b a) -> MicroParsec.Parser b a ()

-- |  > option v p    
-- 
--  Applies _p_, and returns _v_ when it fails.   
-- 
--  Always succeeds.   
option :: c -> MicroParsec.Parser b a c -> MicroParsec.Parser b a c

-- |  The optional parser always succeeds and returns its result wrapped in 'Maybe'   
optional :: MicroParsec.Parser s t r -> MicroParsec.Parser s t (Maybe r)

-- |  > pany   
-- 
--  Fails if and only if 'eos' succeeds, otherwise returns the next token.   
pany :: ListView b => MicroParsec.Parser b a a

-- |  run a Parser, return just the result/error   
parse :: MicroParsec.Parser (b) a c -> (b,a) -> ((String | c),b)

-- |  run a 'Parser' on some input and report   
parseTest :: (Show r,Show t,ListView s) => MicroParsec.Parser s t r -> s t -> IO ()

-- |  Resume parsing with the given input stream.   
-- 
--  'putPos' always succeeds.    
putPos :: b a -> MicroParsec.Parser b a ()


reporterror :: (ListSource b,Show a) => b a -> String -> String

-- |  run a  parser   
runid :: MicroParsec.Parser b c a -> b c -> ((String | a),b c)

-- |  > satisfy property   
-- 
--  Succeeds if there is a next token _t_ and  _property_ _t_ is true.   
satisfy :: ListView s => (t -> Bool) -> MicroParsec.Parser s t t

-- |  > select [(if1, t1), (if2, t2), ..., (ifn, tn)] e   
-- 
--  unfolds as   
-- 
--  > cond if1 t1 (cond if2 t2 (... (cond ifn tn e)))    
select :: [(MicroParsec.Parser a d b,MicroParsec.Parser a d c)] -> MicroParsec.Parser a d c -> MicroParsec.Parser a d c

-- |  > p `sepBy` q   
-- 
--  Like 'sepBy1', but allows zero _p_ elements   
sepBy :: MicroParsec.Parser d c b -> MicroParsec.Parser d c a -> MicroParsec.Parser d c [b]

-- |  > p `sepBy1` q   
-- 
--  Parses p and many q followed by p   
sepBy1 :: MicroParsec.Parser c b a -> MicroParsec.Parser c b d -> MicroParsec.Parser c b [a]

-- |  > p `sepEndBy` q   
-- 
--  Parses zero or more occurrences of _p_, separated and optionally ended by _q_   
sepEndBy :: MicroParsec.Parser d c b -> MicroParsec.Parser d c a -> MicroParsec.Parser d c [b]

-- |  > p `sepEndBy1` q   
-- 
--  Parses one or more occurrences of _p_, separated and optionally ended by _q_   
sepEndBy1 :: MicroParsec.Parser b a d -> MicroParsec.Parser b a c -> MicroParsec.Parser b a [d]

-- |  > skip p   
-- 
--  equivalent to    
-- 
--  > many p >> return ()   
-- 
--  but faster, because it does not build up lists.   
-- 
--  Must not be applied to a parser that always succeeds!   
skip :: MicroParsec.Parser β δ γ -> MicroParsec.Parser β δ ()

-- |  > skipUntil p   
-- 
--  Skip tokens as long as they do not satisfy p   
-- 
--  When this succeeds, the next token will satisfy p or the stream is exhausted.   
skipUntil :: ListView a => (b->Bool) -> MicroParsec.Parser a b ()

-- |     > skipWhile p
--     
--     Skip tokens as long as they 'satisfy' predicate _p_.
--     
--     Beware of negative predicates like 
--     > skipWhile (!= 'a')
--     
--     This will loop forever if there is no @\'a\'@ in the input stream.
--     Instead use
--     
--     > skipUntil (== 'a')
--      
skipWhile :: ListView a => (b->Bool) -> MicroParsec.Parser a b ()

-- |  > some p   
-- 
--  Like 'many', except there must be at least one _p_   
-- 
--  Must not be applied to a parser that always succeeds!   
some :: MicroParsec.Parser c b a -> MicroParsec.Parser c b [a]


space :: ListView a => MicroParsec.Parser a Char Char


spaces :: ListView a => MicroParsec.Parser a Char ()


string :: String -> MicroParsec.Parser StringJ Char String

-- |  > symbol p   
-- 
--  Is the same parser as _p_, but skips spaces afterwards   
symbol :: ListView b => MicroParsec.Parser b Char a -> MicroParsec.Parser b Char a


uppercase :: ListView a => MicroParsec.Parser a Char Char



-- |  This module deals with Semigroups and Monoids   
module frege.data.Monoid

(<>) :: Monoid.Semigroup this => this -> this -> this


instance Eq a => Eq (Monoid.First a)


instance Eq a => Eq (Monoid.Last a)


data First


First :: Maybe a -> Monoid.First a


data Last


Last :: Maybe a -> Monoid.Last a


class Monoid


instance Monoid.Monoid ()


instance Monoid.Monoid (Monoid.First a)


instance Monoid.Monoid (Monoid.Last a)


instance Monoid.Monoid (a->a)


instance Monoid.Monoid Ordering


instance Monoid.Monoid String


instance Monoid.Monoid [a]


instance Monoid.Monoid a => Monoid.Monoid (IO a)


instance Monoid.Semigroup a => Monoid.Monoid (Maybe a)


instance Ord a => Ord (Monoid.First a)


instance Ord a => Ord (Monoid.Last a)


class Semigroup


instance Show a => Show (Monoid.First a)


instance Show a => Show (Monoid.Last a)


mappend :: Monoid.Semigroup this => this -> this -> this


mconcat :: Monoid.Monoid this => [this] -> this


mempty :: Monoid.Monoid this => this


mtimes :: Monoid.Monoid this => Int -> this -> this


sconcat :: Monoid.Semigroup this => [this] -> this


stimes :: Monoid.Semigroup this => Int -> this -> this



-- |  A non-empty list   
module frege.data.NonEmpty
-- |  Prepends a value to a 'NonEmpty'.   
(.:) :: a -> NonEmpty.NonEmpty a -> NonEmpty.NonEmpty a


instance Eq a => Eq (NonEmpty.NonEmpty a)


instance Foldable.Foldable NonEmpty.NonEmpty


instance Functor NonEmpty.NonEmpty


instance ListMonoid NonEmpty.NonEmpty


instance ListSource NonEmpty.NonEmpty


instance Monad NonEmpty.NonEmpty


instance Monoid.Semigroup (NonEmpty.NonEmpty a)

-- |     A 'NonEmpty' is like a list, but never empty.
--      
data NonEmpty


NonEmpty :: a -> [a] -> NonEmpty.NonEmpty a


instance Ord a => Ord (NonEmpty.NonEmpty a)


instance Show a => Show (NonEmpty.NonEmpty a)


instance Traversable.Traversable NonEmpty.NonEmpty

-- |  cycle ties a finite 'NonEmpty' into a circular one, or equivalently, the infinite repetition
--     of the original 'NonEmpty'. It is the identity on infinite 'NonEmpty's. 
--          
cycle :: ListSource src => src a -> NonEmpty.NonEmpty a

-- |  The inits function returns all initial segments of the argument, shortest first.   
inits :: NonEmpty.NonEmpty a -> [NonEmpty.NonEmpty a]

-- |  The insert function takes an element and a 'NonEmpty' and inserts the element 
--     into the 'NonEmpty' at the last position where it is still less than or equal to the next element.
--          
insert :: Ord a => a -> NonEmpty.NonEmpty a -> NonEmpty.NonEmpty a

-- |  iterate f x returns an infinite 'NonEmpty' of repeated applications of f to x   
iterate :: (a -> a) -> a -> NonEmpty.NonEmpty a

-- |  Constructs a non-empty list with the given head and tail.   
nonEmpty :: a -> [a] -> NonEmpty.NonEmpty a

-- |  Reverses the elements of the (finite) 'NonEmpty'.   
reverse :: NonEmpty.NonEmpty a -> NonEmpty.NonEmpty a

-- |  scanl is similar to foldl, but returns a 'NonEmpty' of successive reduced values from the left   
scanl :: (b -> a -> b) -> b -> NonEmpty.NonEmpty a -> NonEmpty.NonEmpty b

-- |  scanl1 is similar to foldl1, but returns a 'NonEmpty' of successive reduced values from the left   
scanl1 :: (a -> a -> a) -> NonEmpty.NonEmpty a -> NonEmpty.NonEmpty a

-- |  scanr is similar to foldr, but returns a 'NonEmpty' of successive reduced values from the right   
scanr :: (a -> b -> b) -> b -> NonEmpty.NonEmpty a -> NonEmpty.NonEmpty b

-- |  scanr1 is similar to foldr1, but returns a 'NonEmpty' of successive reduced values from the right   
scanr1 :: (a -> a -> a) -> NonEmpty.NonEmpty a -> NonEmpty.NonEmpty a

-- |  The sort function implements a stable sorting algorithm.   
sort :: Ord a => NonEmpty.NonEmpty a -> NonEmpty.NonEmpty a

-- |  The tails function returns all final segments of the argument, longest first.   
tails :: NonEmpty.NonEmpty a -> [NonEmpty.NonEmpty a]

-- |  Tries to convert a list to a 'NonEmpty' returning 'Nothing' if the given list is empty.   
toNonEmpty :: [a] -> Maybe (NonEmpty.NonEmpty a)

-- |  Converts a list to a 'NonEmpty' using the given default value for the empty list case.   
toNonEmpty' :: NonEmpty.NonEmpty a -> [a] -> NonEmpty.NonEmpty a

-- |  _WARNING: Fails if given the empty list._   
-- 
--  Tries to convert a list to a 'NonEmpty'.   
unsafeToNonEmpty :: [a] -> NonEmpty.NonEmpty a

-- |  unzip transforms a 'NonEmpty' of pairs into a 'NonEmpty' of first components and a 'NonEmpty' of second components.    
unzip :: NonEmpty.NonEmpty (a,b) -> (NonEmpty.NonEmpty a,NonEmpty.NonEmpty b)

-- |  zip takes two 'NonEmpty's and returns a 'NonEmpty' of corresponding pairs.
--     If one input 'NonEmpty's is short, excess elements of the longer 'NonEmpty' are discarded. 
--          
zip :: NonEmpty.NonEmpty a -> NonEmpty.NonEmpty b -> NonEmpty.NonEmpty (a,b)

-- |  Constructs a non-empty list with the given head and tail (an alias for 'nonEmpty').   
(|:) :: a -> [a] -> NonEmpty.NonEmpty a



-- |  A pair of two applicative functors, both applied to the same type   
module frege.data.Product

instance (Functor f,Functor g) => Functor (Product.Product f g)


Prod :: f a -> g a -> Product.Product f g a


data Product

-- |  view a tuple as 'Product'   
product :: (a b,c b) -> Product.Product a c b

-- |  make a tuple from a 'Product'   
unproduct :: Product.Product b a c -> (b c,a c)



-- |     Implementation of and functions for the 'Stream' data type
--      
module frege.data.Stream
-- | xs !! n returns the element of the stream xs at index n.
-- Note that the head of the stream has index 0.
-- 
-- Beware: passing a negative integer as the first argument will cause
-- an error.
--      
(!!) :: Stream.Stream a -> Int -> a

-- |     The <:> operator is a left strict infix version of the 'Cons' constructor.
--     
--     In this module, it will always be used when the _head_ part of a 'Stream' result
--     is computed with some function passed as argument.
--     
--     This way, the strictness of the passed function is indirectly taken in account.
--     
--     For example, in the result of
--     
--     > zipWith (,) stream1 stream2
--     
--     the data of stream1 and stream2 are not evaluated, because the tuple constructor doesn't do it.
--     
--     Hence 
--     
--     > let us = repeat undefined in length • take 10 • zipWith (,) us $ us 
-- 
--     will be 10. Whereas
--     
--     > let us = repeat undefined in length • take 10 • zipWith (+) us $ us
--     
--     will be undefined.
--      
(<:>) :: a -> Stream.Stream a -> Stream.Stream a


Cons :: a -> Stream.Stream a -> Stream.Stream a


instance Eq a => Eq (Stream.Stream a)

-- |  toList converts a stream into an infinite list.   
instance ListSource Stream.Stream


instance ListView Stream.Stream


instance Monad Stream.Stream


instance Monoid.Monoid a => Monoid.Monoid (Stream.Stream a)


instance Monoid.Semigroup a => Monoid.Semigroup (Stream.Stream a)


instance Ord a => Ord (Stream.Stream a)

-- |     A Show instance for Streams.
--     Note that 'show' returns an infinite 'String'.
--     Hence you can't use this function on old fashioned computers with finite memory.
--      
instance Show a => Show (Stream.Stream a)

-- | Streams are infinite lists. Most operations on streams are
-- completely analogous to the definitions for [].
-- 
-- Beware: If you use any function from the Eq or Ord
-- class to compare two equal streams, these functions will diverge.
--      
data Stream

-- |  The break p function is equivalent to span (not <~ p).   
break :: (a -> Bool) -> Stream.Stream a -> ([a],Stream.Stream a)

-- | cycle xs returns the infinite repetition of xs:
-- 
--  cycle [1,2,3] = Cons 1 (Cons 2 (Cons 3 (Cons 1 (Cons 2 ...
--      
cycle :: [a] -> Stream.Stream a

-- | dropWhile p xs returns the suffix remaining after
-- takeWhile p xs.
-- 
-- Beware: this function may diverge if every element of xs
-- satisfies p, e.g.  dropWhile even (repeat 0) will loop.
--      
dropWhile :: (a -> Bool) -> Stream.Stream a -> Stream.Stream a

-- | The elemIndex function returns the index of the first element
-- in the given stream which is equal (by '==') to the query element,
-- 
-- Beware: elemIndex x xs will diverge if none of the elements
-- of xs equal x.
--      
elemIndex :: Eq a => a -> Stream.Stream a -> Int

-- | The elemIndices function extends elemIndex, by returning the
-- indices of all elements equal to the query element, in ascending order.
-- 
-- Beware: elemIndices x xs will diverge if any suffix of
-- xs does not contain x.
--      
elemIndices :: Eq a => a -> Stream.Stream a -> Stream.Stream Int

-- | filter p xs removes any elements from xs that do not satisfy p.
-- 
-- Beware: this function may diverge if there is no element of
-- xs that satisfies p, e.g.  filter odd (repeat 0) will loop.
--      
filter :: (a -> Bool) -> Stream.Stream a -> Stream.Stream a

-- | The findIndex function takes a predicate and a stream and returns
-- the index of the first element in the stream that satisfies the predicate,
-- 
-- Beware: findIndex p xs will diverge if none of the elements of
-- xs satisfy p.
--      
findIndex :: (a -> Bool) -> Stream.Stream a -> Int

-- | The findIndices function extends findIndex, by returning the
-- indices of all elements satisfying the predicate, in ascending
-- order.
-- 
-- Beware: findIndices p xs will diverge if all the elements
-- of any suffix of xs fails to satisfy p.
--      
findIndices :: (a -> Bool) -> Stream.Stream a -> Stream.Stream Int

-- | The 'fromList' converts an infinite list to a
-- stream.
-- 
-- Beware: Passing a finite list, will cause an error.
--      
fromList :: [a] -> Stream.Stream a

-- | The group function takes a stream and returns a stream of
-- lists such that flattening the resulting stream is equal to the
-- argument.  Moreover, each sublist in the resulting stream
-- contains only equal elements.  For example,
-- 
--  group $ cycle "Mississippi" = "M" ::: "i" ::: "ss" ::: "i" ::: "ss" ::: "i" ::: "pp" ::: "i" ::: "M" ::: "i" ::: ...
--      
group :: Eq a => Stream.Stream a -> Stream.Stream [a]

-- | The 'inits' function takes a stream xs and returns all the
-- finite prefixes of xs.
-- 
-- Note that this 'inits' is lazier then 'frege.data.List#inits':
-- 
--  > inits _|_ = [] ::: _|_
-- 
-- while for 'frege.data.List#inits':
-- 
--  > inits _|_ = _|_
--      
inits :: Stream.Stream a -> Stream.Stream [a]

-- | Interleave two Streams xs and ys, alternating elements
-- from each list.
-- 
--  [x1,x2,...] `interleave` [y1,y2,...] == [x1,y1,x2,y2,...]
--      
interleave :: Stream.Stream a -> Stream.Stream a -> Stream.Stream a

-- |  intersperse y xs creates an alternating stream of elements from xs and y   
intersperse :: a -> Stream.Stream a -> Stream.Stream a

-- | The isPrefix function returns true if the first argument is
-- a prefix of the second.
--      
isPrefixOf :: Eq a => [a] -> Stream.Stream a -> Bool

-- | iterate f x function produces the infinite sequence
-- of repeated applications of f to x.
-- 
--  iterate f x = [x, f x, f (f x), ..]
--       
iterate :: (a -> a) -> a -> Stream.Stream a

-- | The lines function breaks a stream of characters into a list
-- of strings at newline characters. The resulting strings do not
-- contain newlines.
-- 
-- Beware: if the stream of characters xs does not contain
-- newline characters, accessing the tail of lines xs will loop.
--      
lines :: Stream.Stream Char -> Stream.Stream String

-- |  Apply a function uniformly over all elements of a sequence.   
map :: (a -> b) -> Stream.Stream a -> Stream.Stream b

-- | The 'partition' function takes a predicate p and a stream
-- xs@, and returns a pair of streams. The first stream corresponds
-- to the elements of @xs@ for which p holds; the second stream
-- corresponds to the elements of xs for which p does not hold.
-- 
-- Beware: One of the elements of the tuple may be undefined. For
-- example, fst (partition even (repeat 0)) == repeat 0; on the
-- other hand snd (partition even (repeat 0)) is undefined.
--      
partition :: (a -> Bool) -> Stream.Stream a -> (Stream.Stream a,Stream.Stream a)

-- |  repeat x returns a constant stream, where all elements are equal to x.   
repeat :: a -> Stream.Stream a

-- | scan yields a stream of successive reduced values from:
-- 
--  scan f z [x1, x2, ...] == [z, z `f` x1, (z `f` x1) `f` x2, ...]
--      
scan :: (a -> b -> a) -> a -> Stream.Stream b -> Stream.Stream a

-- |  scan' is a strict scan.   
scan' :: (a -> b -> a) -> a -> Stream.Stream b -> Stream.Stream a

-- | scan1 is a variant of scan that has no starting value argument:
-- 
--  scan1 f [x1, x2, ...] == [x1, x1 `f` x2, ...]
--      
scan1 :: (a -> a -> a) -> Stream.Stream a -> Stream.Stream a

-- |  scan1' is a strict scan that has no starting value.   
scan1' :: (a -> a -> a) -> Stream.Stream a -> Stream.Stream a

-- | span p xs returns the longest prefix of xs that satisfies
-- p, together with the remainder of the stream.
--      
span :: (a -> Bool) -> Stream.Stream a -> ([a],Stream.Stream a)

-- | The splitAt function takes an integer n and a stream xs
-- and returns a pair consisting of the prefix of xs of length
-- n and the remaining stream immediately following this prefix.
-- 
-- Beware: passing a negative integer as the first argument will
-- cause an error.
--      
splitAt :: Int -> Stream.Stream a -> ([a],Stream.Stream a)

-- |  The 'tails' function takes a stream xs and returns all the suffixes of xs.   
tails :: Stream.Stream a -> Stream.Stream (Stream.Stream a)

-- | takeWhile p xs returns the longest prefix of the stream
-- xs for which the predicate p holds.
--      
takeWhile :: (a -> Bool) -> Stream.Stream a -> [a]

-- |  transpose computes the transposition of a stream of streams.   
transpose :: Stream.Stream (Stream.Stream a) -> Stream.Stream (Stream.Stream a)

-- | The unfold function is similar to the unfold for lists. Note
-- there is no base case: all streams must be infinite.
--      
unfold :: (c -> (a,c)) -> c -> Stream.Stream a

-- | The unlines function is an inverse operation to lines. It
-- joins lines, after appending a terminating newline to each.
--      
unlines :: Stream.Stream String -> Stream.Stream Char

-- | The unwords function is an inverse operation to words. It
-- joins words with separating spaces.
--      
unwords :: Stream.Stream String -> Stream.Stream Char

-- |  The unzip function is the inverse of the zip function.   
unzip :: Stream.Stream (a,b) -> (Stream.Stream a,Stream.Stream b)

-- | The words function breaks a stream of characters into a
-- stream of words, which were delimited by white space.
-- 
-- Beware: if the stream of characters xs does not contain white
-- space, accessing the tail of words xs will loop.
--      
words :: Stream.Stream Char -> Stream.Stream String

-- | The zip function takes two streams and returns a list of
-- corresponding pairs.
--      
zip :: Stream.Stream a -> Stream.Stream b -> Stream.Stream (a,b)

-- | The zipWith function generalizes zip. Rather than tupling
-- the functions, the elements are combined using the function
--  passed as the first argument to zipWith.
--       
zipWith :: (a -> b -> c) -> Stream.Stream a -> Stream.Stream b -> Stream.Stream c



-- |  Functors representing data structures that can be traversed from left to right.   
module frege.data.Traversable

instance Applicative (Traversable.StateL s)


instance Applicative (Traversable.StateR s)


instance Functor (Traversable.StateL s)


instance Functor (Traversable.StateR s)


data StateL


StateL :: (s -> (s,a)) -> Traversable.StateL s a


data StateR


StateR :: (s -> (s,a)) -> Traversable.StateR s a

-- |    Functors representing data structures that can be traversed from left to right.
-- 
--    Minimal complete definition: 'traverse' or 'sequenceA'.
--  
--    The superclass instances should satisfy the following:
-- 
--     * In the 'Functor' instance, 'fmap' should be equivalent to traversal
--       with the identity applicative functor ('fmapDefault').
-- 
--     * In the 'Foldable' instance, 'Foldable.foldMap' should be
--       equivalent to traversal with a constant applicative functor
--       ('foldMapDefault').
--       
--     Note that the functions 'mapM', 'sequence', 'forM' are just specialized versions 
--     of 'traverse', 'sequenceA' and 'for', and wouldn't be required in Frege.
--     They are included for Haskell compatibility only. In Haskell the specialized 
--     functions are needed as Haskell monads are no Applicatives.      
--         
class Traversable


instance Traversable.Traversable Identity.Identity


instance Traversable.Traversable Maybe


instance Traversable.Traversable []

-- |  This function may be used as a value for `fmap` in a `Functor`
--     instance, provided that 'traverse' is defined. (Using
--     'fmapDefault' with a 'Traversable' instance defined only by
--     'sequenceA' will result in infinite recursion.)
--          
fmapDefault :: Traversable.Traversable t => (a -> b) -> t a -> t b

-- |  This function may be used as a value for `Data.Foldable.foldMap`
--     in a `Foldable` instance.
--      
foldMapDefault :: (Traversable.Traversable t,Monoid.Monoid m) => (a -> m) -> t a -> m

-- |  'for' is 'traverse' with its arguments flipped.   
for :: (Traversable.Traversable t,Applicative f) => t a -> (a -> f b) -> f (t b)

-- |  'forM' is 'mapM' with its arguments flipped.   
-- 
--   This function exists for Haskell compatibility only.   
forM :: (Traversable.Traversable t,Monad m) => t a -> (a -> m b) -> m (t b)

-- |  The 'mapAccumL' function behaves like a combination of 'fmap'
--     and 'fold'; it applies a function to each element of a structure,
--     passing an accumulating parameter from left to right, and returning
--     a final value of this accumulator together with the new structure.
--          
mapAccumL :: Traversable.Traversable t => (a -> b -> (a,c)) -> a -> t b -> (a,t c)

-- |  The 'mapAccumR' function behaves like a combination of 'fmap'
--     and 'foldr'; it applies a function to each element of a structure,
--     passing an accumulating parameter from right to left, and returning
--     a final value of this accumulator together with the new structure.
--          
mapAccumR :: Traversable.Traversable t => (a -> b -> (a,c)) -> a -> t b -> (a,t c)

-- |  Map each element of a structure to a monadic action, evaluate
--         these actions from left to right, and collect the results.
--         This function exists for Haskell compatibility only.
--          
mapM :: (Traversable.Traversable t,Monad m) => (a -> m b) -> t a -> m (t b)

-- |  Evaluate each monadic action in the structure from left to right,
--         and collect the results.
--         This function exists for Haskell compatibility only.
--          
sequence :: (Traversable.Traversable t,Monad m) => t (m a) -> m (t a)

-- |  Evaluate each action in the structure from left to right,
--         and collect the results.
--          
sequenceA :: (Traversable.Traversable t,Applicative f) => t (f a) -> f (t a)

-- |  Map each element of a structure to an action, evaluate
--         these actions from left to right, and collect the results.
--           
traverse :: (Traversable.Traversable t,Applicative f) => (a -> f b) -> t a -> f (t b)



-- |     Multi-way trees (_aka_ rose trees) and forests.
--     
--     [Module]    Data.Tree
--     [Copyright] (c) The University of Glasgow 2002
--     [License]   BSD-style (see the file libraries/base/LICENSE)
-- 
--     This is a port of Haskell library code.
--      
module frege.data.Tree

instance Applicative Tree.Tree


instance Eq a => Eq (Tree.Tree a)


instance Foldable.Foldable Tree.Tree


type Forest = [Tree.Tree a]


instance Functor Tree.Tree


instance Monad Tree.Tree


Node :: a -> [Tree.Tree a] -> Tree.Tree a


instance Show a => Show (Tree.Tree a)


instance Traversable.Traversable Tree.Tree

-- |  Multi-way trees, also known as _rose trees_.   
data Tree


draw :: Tree.Tree String -> [String]

-- |  Neat 2-dimensional drawing of a forest.   
drawForest :: [Tree.Tree String] -> String

-- |  Neat 2-dimensional drawing of a tree.   
drawTree :: Tree.Tree String -> String

-- |  The elements of a tree in pre-order.   
flatten :: Tree.Tree a -> [a]

-- |  Lists of nodes at each level of the tree.   
levels :: Tree.Tree a -> [[a]]

-- |  Build a forest from a list of seed values   
unfoldForest :: (b -> (a,[b])) -> [b] -> [Tree.Tree a]

-- |  Monadic forest builder, in depth-first order   
unfoldForestM :: Monad m => (b -> m (a,[b])) -> [b] -> m [Tree.Tree a]

-- |  Build a tree from a seed value   
unfoldTree :: (b -> (a,[b])) -> b -> Tree.Tree a

-- |  Monadic tree builder, in depth-first order   
unfoldTreeM :: Monad m => (b -> m (a,[b])) -> b -> m (Tree.Tree a)



-- |     An efficient implementation of
--     'https://en.wikipedia.org/wiki/Persistent_data_structure persistent' 
--     ordered maps from keys to values
--     based on 'http://en.wikipedia.org/wiki/AVL_tree AVL trees'.
-- 
--     ## Properties of ordered maps
--     
--     An AVL tree is a self-balancing binary search tree. 
--     In an AVL tree, the heights of the two child subtrees of any node 
--     differ by at most one; if at any time they differ by more than one, 
--     rebalancing is done to restore this property. 
--     
--     Lookup, insertion, and deletion all take O(log n) time in both the average 
--     and worst cases, where n is the number of nodes in the tree prior to the 
--     operation. Insertions and deletions may require the tree to be rebalanced 
--     by one or more tree rotations.
-- 
--     AVL trees are height-balanced, but not weight-balanced nor μ-balanced,
--     that is, sibling nodes can have hugely differing numbers of descendants.
-- 
--     ## Properties of this implementation
-- 
--     Keys will always be strict, whereas values can remain un-evaluated until
--     two values will have to be combined. 
-- 
--     Combination of two values takes place when a mapping for 
--     an already existing key is inserted in a map. In order to prevent
--     building up of thunks that could lead to stack overflows later, the
--     function combining the values will be evaluated right away, and this may 
--     trigger evaluation of one or both values in turn. 
--     
--     The default function used by operations like 'insert' or 'union' is 'const'; 
--     and this will cause evaluation of the *new* value. Take a look at
--     the following example:
-- 
--     > insert 7 undefined (insert 7 25 empty)            -- will fail
--     > insert 7 42 (insert 7 undefined empty)            -- will succeed
--     > insertWith (+) 7 42 (insert 7 undefined empty)    -- will fail
-- 
--     The last expression will fail because ('+') needs to evaluate both 
--     arguments. OTOH, expressions like
-- 
--     > fold (\t\v -> insertWith (+) 42 v t) empty [1..1_000_000]
--  
--     will not cause stack overflow when later the value associated with 42 is
--     actually used, nor will it need heap memory for one million thunks.
-- 
--     ## Operations
-- 
--     ### Creating Maps
-- 
--     Get an empty map with 'TreeMap.mempty' or 'TreeMap.empty', make a singleton one
--     with 'singleton' or turn an association list into a 'TreeMap' with 'fromList'.
--     The more general function 'fromListWith' allows custom handling of 
--     associations with duplicate keys.
-- 
--     ## Add, Change or Remove Associations
-- 
--     Use 'insert', 'delete', 'adjust' and 'replace'. The more general form of 'insert' 
--     is 'insertWith' which accepts a function to combine the given value with an
--     already existing one.
-- 
--     ## Lookups
-- 
--     The basic function is 'lookup', of which 'member' and 'lookupDefault' are variants.
--     The operator ('!!') may be used when the existence of the keys looked for is out
--     of the question.
--     
--     Because a tree map is ordered, we can find the associations with the smallest
--     and largest keys in logarithmic time. See 'findMin' and 'findMax'. 
-- 
--     ## Set operations
-- 
--     There is 'union', 'difference' and 'intersection'. More general functions 
--     'unionWith' and 'intersectionWith' allow combination of the affected values.
-- 
--     ## Folds
-- 
--     Left folds as well as right folds are provided by 'foldValues' and 'foldrValues'. 
--     Variants 'foldWithKey' and 'foldrWithKey' allow examination not only of the value, 
--     but also of the key and they walk the tree in key order.
-- 
--     Frequently needed functions such as 'values', 'keys', 'each' and 'size' are just
--     predefined folds for your convenience.
-- 
--     ## Filtering
-- 
--     Create a subset of an existing map with 'filterValues' or 'filterWithKey'.
-- 
--     ## Transformations
-- 
--     'mapValues', 'mapWithKey' and 'traverseWithKey' should cover any need to 
--     transform an existing map.
-- 
--     ### Naming Conventions
-- 
--     Functions whose name have the _With_ suffix take a custom function to combine two
--     values and are thus more general than the ones without that suffix. 
--     Most often it is the case that 
--     > xxx = xxxWith const
-- 
--     Functions whose name have the _Values_ suffix operate on the values of the mappings
--     contained in the map and take an appropriate custom function as argument. 
--     The _Values_ suffix also serves to avoid conflicts with
--     Prelude functions (i.e. 'map', 'filter', 'fold', 'foldr').
-- 
--     The companions of the _Values_ functions have the suffix _WithKey_ and accept 
--     functions that take an extra argument for the key. The key portion of
--     a mapping or association is always passed first, followed by the associated value.
-- 
--      
module frege.data.TreeMap
-- |  _O(log n)_
--  
--      Return the value associated with the given key in the map.
--      Fails with 'error' if the key is not present.
--      
(!!) :: Ord k => TreeMap.TreeMap k v -> k -> v


instance (Show k,Show v) => Show (TreeMap.TreeMap k v)

-- |  'TreeMap' can be used as array element   
instance ArrayElement (TreeMap.TreeMap a b)


instance Functor (TreeMap.TreeMap a)


instance ListEmpty (TreeMap.TreeMap a)


instance Ord a => Monoid.Monoid (TreeMap.TreeMap a b)


instance Traversable.Traversable (TreeMap.TreeMap k)


data TreeMap


type TreeSet = TreeMap.TreeMap a ()

-- |  _O(log n)_ 
--     
--     Adjust the value tied to a given key in this map only if it is present. 
--     Otherwise, leave the map alone. 
--      
adjust :: Ord k => (v -> v) -> k -> TreeMap.TreeMap k v -> TreeMap.TreeMap k v


contains :: Ord b => TreeMap.TreeMap b a -> b -> Bool

-- |     _O(log n)_
--     > delete k tm
--     is a 'HashMap' m such that
--     > lookup k m = Nothing
--     and for any other key _o_
--     > lookup o m = lookup o tm
-- 
--     Less formally, the association of _k_ with some value, if any, 
--     is removed in the result, while all other associations are retained.
-- 
--     If _tm_ didn't contain _k_ in the first place,
--     > delete k tm = tm    
--      
delete :: Ord k => k -> TreeMap.TreeMap k v -> TreeMap.TreeMap k v

-- |     _O(n*log m)_ 
-- 
--     Computes the difference of two maps. 
-- 
--     Returns a map that contains the mappings of the first map 
--     whose keys do not exist in the second.
--      
difference :: Ord k => TreeMap.TreeMap k v -> TreeMap.TreeMap k u -> TreeMap.TreeMap k v

-- |  produces the key/value pairs of a map sorted by key   
each :: TreeMap.TreeMap a b -> [(a,b)]

-- |     _O(n)_
-- 
--     Filter a map, retaining only mappings whose value satisfies
--     a given predicate.
--      
filterValues :: Ord k => (v -> Bool) -> TreeMap.TreeMap k v -> TreeMap.TreeMap k v

-- |     _O(n)_
-- 
--     Filter a map, retaining only mappings whose key and value satisfy
--     a given predicate.
--      
filterWithKey :: Ord k => (k -> v -> Bool) -> TreeMap.TreeMap k v -> TreeMap.TreeMap k v

-- |  _O(log n)_   
-- 
--  Find the maximum element in the tree. For empty trees, this is 'Nothing'.   
findMax :: TreeMap.TreeMap k v -> Maybe (k,v)

-- |  _O(log n)_   
-- 
--  Find the minimum element in the tree. For empty trees, this is  'Nothing'.   
findMin :: TreeMap.TreeMap k v -> Maybe (k,v)

-- |     _O(n)_
-- 
--     > foldValues f a map
-- 
--     applies the operation _f_ to the values in the _map_ in no particular order. 
--      
foldValues :: (a -> v -> a) -> a -> TreeMap.TreeMap k v -> a

-- |     _O(n)_
-- 
--     > foldWithKey f a map
-- 
--     applies the operation _f_ to the keys and values in the _map_ 
--     using the left identity _a_ as starting value 
--     from the left in ascending key order. 
-- 
--     > f (f (f a k0 v0) k1 v1) kn vn 
--      
foldWithKey :: (a -> c -> b -> a) -> a -> TreeMap.TreeMap c b -> a

-- |     _O(n)_
-- 
--     > foldrValues f a map
-- 
--     applies the operation _f_ to the values in the _map_ in no particular order. 
--      
foldrValues :: (v -> a -> a) -> a -> TreeMap.TreeMap k v -> a

-- |     _O(n)_
-- 
--     > foldrWithKey f a map
-- 
--     applies the operation _f_ to the keys and values in the _map_ 
--     using the right identity _a_ as starting value
--     from the right in descending key order:
--     
--     > f k0 v0 (f k1 v1 (f kn vn a))  
--      
foldrWithKey :: (c -> b -> a -> a) -> a -> TreeMap.TreeMap c b -> a


fromKeys :: Ord a => [a] -> TreeMap.TreeMap a ()

-- |     _O(n)_
-- 
--     Build a map from an association list.
--     If the list contains duplicate mappings, the later mappings take precedence.
--      
fromList :: Ord a => [(a,b)] -> TreeMap.TreeMap a b

-- |     _O(n)_
--     
--     Build a map from an association list.
--     Uses the provided function to merge values associated 
--     with duplicate keys.
--      
fromListWith :: Ord k => (v -> v -> v) -> [(k,v)] -> TreeMap.TreeMap k v


including :: Ord a => TreeMap.TreeMap a () -> a -> TreeMap.TreeMap a ()

-- |     _O(log n)_
--     
--     > insert k v map
--     
--     returns a 'TreeMap' where _k_ is associated with _v_ such that
--     
--     > lookup k (insert k v map) = Just v
--     
--     If _k_ was already associated with some value in _map_, then _v_ will get 
--     evaluated to WHNF, otherwise it is left alone. 
--      
insert :: Ord a => a -> b -> TreeMap.TreeMap a b -> TreeMap.TreeMap a b

-- |     _O(log n)_
--     > insertWith f k v m
--     If _m_ does not contain _k_, this works like 'insert'.
--     Otherwise, the existing association of _k_ with some value _v'_ is replaced by
--     an association of _k_ with the result of evaluating 
--     > f v v'
--     in the resulting map. 
-- 
--     Strict evaluation is necessary to prevent building up of large thunks 
--     of the form
--     > f v3 (f v2 (f v1 v0))
-- 
--     Note that
--     > insert = insertWith const
--     and that this will evaluate the *new* value in case of an update. If you
--     want to prevent this, use
-- 
--     > replace k v = insert k v . delete k
--     
--     The replaced value will be evaluated only if the given function is strict
--     in the second argument. Since 'const' is lazy in the second argument, the
--     following will be fine:
--     
--     > insert "foo" 7 (insert "foo" undefined (delete "foo" m))
--     
--     That is, the value that is inserted for a given key first is not evaluated on
--     insertion, and only evaluated on update if the update function demands it, which
--     is not the case for a plain 'insert'.
--      
insertWith :: Ord a => (b->b->b) -> a -> b -> TreeMap.TreeMap a b -> TreeMap.TreeMap a b

-- |     _O(n*log m)_ 
-- 
--     Computes the intersection of two maps. 
-- 
--     Return a map that contains the mappings of the first map 
--     for keys that also exist in the second.
--      
intersection :: Ord k => TreeMap.TreeMap k v -> TreeMap.TreeMap k u -> TreeMap.TreeMap k v

-- |     _O(n*log m)_
-- 
--     Computes the intersection of two maps, combining the values with a
--     given function.
--      
intersectionWith :: Ord k => (v -> u -> w) -> TreeMap.TreeMap k v -> TreeMap.TreeMap k u -> TreeMap.TreeMap k w

-- |  produces the keys of the map in ascending order   
keys :: TreeMap.TreeMap a b -> [a]

-- |     _O(log n)_
--     > lookup k m
--     If _k_ is associated with some value _v_  in map _m_, it returns
--     > Just v
--     and otherwise
--     > Nothing 
--      
lookup :: Ord k => k -> TreeMap.TreeMap k v -> Maybe v

-- |  _O(log n)_ 
-- 
--     Return the value to which the specified key is mapped, 
--     or the default value if this map contains no mapping for the key.
--      
lookupDefault :: Ord b => a -> b -> TreeMap.TreeMap b a -> a

-- |  _O(n)_
-- 
--     Transform a map by applying a function to every value.
--      
mapValues :: (v -> u) -> TreeMap.TreeMap k v -> TreeMap.TreeMap k u

-- |     _O(n)_ 
-- 
--     Transform a map by applying a function to every key and its
--     associated value.
--      
mapWithKey :: (k -> v -> u) -> TreeMap.TreeMap k v -> TreeMap.TreeMap k u

-- |  _O(log n)_    
-- 
--  Checks whether the key is present in the map   
member :: Ord a => a -> TreeMap.TreeMap a b -> Bool

-- |  _O(log n)_
--     > replace k v m = insert k v . delete k $ m
-- 
--     Insert or update the association of _k_ with _v_ in _m_
--     but avoid evaluation of _v_ even if _m_ already contains _k_.
-- 
--     See also notes concerning updates on function 'insertWith'.
--      
replace :: Ord k => k -> v -> TreeMap.TreeMap k v -> TreeMap.TreeMap k v

-- |  _O(1)_ Create a singleton map   
singleton :: Ord k => k -> v -> TreeMap.TreeMap k v

-- |  _O(n)_ Compute the size of the map   
size :: TreeMap.TreeMap k v -> Int

-- |     _O(n)_
-- 
--     Transform a map by applying an applicative functor to every key
--     and its associated value.
--      
traverseWithKey :: Applicative a => (k -> v -> a u) -> TreeMap.TreeMap k v -> a (TreeMap.TreeMap k u)

-- |  _O(m*log n)_
-- 
--     Computes the union of two hash maps.
-- 
--     If a key occurs in both maps, the value from the left map will be 
--     evaluated and taken over to the new map.
-- 
--     Because
--     > union  =  unionWith const 
--     the considerations concerning strictness apply for 'union' in the same
--     way as for 'unionWith'.
--      
union :: Ord k => TreeMap.TreeMap k v -> TreeMap.TreeMap k v -> TreeMap.TreeMap k v

-- |  _O(m*log n)_
-- 
--     > unionWith f left right
-- 
--     Computes the union of two hash maps by inserting the elements of the _left_
--     map into the _right_ map.
-- 
--     If a key occurs in both maps, the function _f_ provided in the first argument 
--     will be applied to the value from the _left_ map and the _right_ map like so:
--     
--     > f leftval rightval
--     
--     to compute the result that goes into the resulting map.
--     
--     This works in the same way as 'insertWith', that is, 
--     the value from the _left_ hash map will be evaluated while the
--     value from the _right_ map may be evaluated only if the function demands it.
--     However, values associated with keys that are member of only one map are
--     left alone.
--      
unionWith :: Ord k => (v -> v -> v) -> TreeMap.TreeMap k v -> TreeMap.TreeMap k v -> TreeMap.TreeMap k v

-- |     The union of all 'TreeMap's in a list.
--      
unions :: Ord k => [TreeMap.TreeMap k v] -> TreeMap.TreeMap k v

-- |  produces a list of the values in the map, in no particular order.   
values :: TreeMap.TreeMap a b -> [b]



-- |  'Eq', 'Ord' and 'Show' instances for tuples 4 .. 7   
--  'Functor' instances for tuples 4 .. 7   
--  'Semigroup' and 'Monoid' instances for tuples 2 .. 7   
--  'Monad' instances for Tuples 2 .. 7   
module frege.data.Tuples

instance (Eq a,Eq b,Eq c,Eq d) => Eq (a,b,c,d)


instance (Eq a,Eq b,Eq c,Eq d,Eq e) => Eq (a,b,c,d,e)


instance (Eq a,Eq b,Eq c,Eq d,Eq e,Eq f) => Eq (a,b,c,d,e,f)


instance (Eq a,Eq b,Eq c,Eq d,Eq e,Eq f,Eq g) => Eq (a,b,c,d,e,f,g)


instance (Monoid.Monoid a,Monoid.Monoid b) => Monad (a,b)


instance (Monoid.Monoid a,Monoid.Monoid b) => Monoid.Monoid (a,b)


instance (Monoid.Monoid a,Monoid.Monoid b,Monoid.Monoid c) => Monad (a,b,c)


instance (Monoid.Monoid a,Monoid.Monoid b,Monoid.Monoid c) => Monoid.Monoid (a,b,c)


instance (Monoid.Monoid a,Monoid.Monoid b,Monoid.Monoid c,Monoid.Monoid d) => Monad (a,b,c,d)


instance (Monoid.Monoid a,Monoid.Monoid b,Monoid.Monoid c,Monoid.Monoid d) => Monoid.Monoid (a,b,c,d)


instance (Monoid.Monoid a,Monoid.Monoid b,Monoid.Monoid c,Monoid.Monoid d,Monoid.Monoid e) => Monad (a,b,c,d,e)


instance (Monoid.Monoid a,Monoid.Monoid b,Monoid.Monoid c,Monoid.Monoid d,Monoid.Monoid e) => Monoid.Monoid (a,b,c,d,e)


instance (Monoid.Monoid a,Monoid.Monoid b,Monoid.Monoid c,Monoid.Monoid d,Monoid.Monoid e,Monoid.Monoid f) => Monad (a,b,c,d,e,f)


instance (Monoid.Monoid a,Monoid.Monoid b,Monoid.Monoid c,Monoid.Monoid d,Monoid.Monoid e,Monoid.Monoid f) => Monoid.Monoid (a,b,c,d,e,f)


instance (Monoid.Monoid a,Monoid.Monoid b,Monoid.Monoid c,Monoid.Monoid d,Monoid.Monoid e,Monoid.Monoid f,Monoid.Monoid g) => Monoid.Monoid (a,b,c,d,e,f,g)


instance (Monoid.Semigroup a,Monoid.Semigroup b) => Monoid.Semigroup (a,b)


instance (Monoid.Semigroup a,Monoid.Semigroup b,Monoid.Semigroup c) => Monoid.Semigroup (a,b,c)


instance (Monoid.Semigroup a,Monoid.Semigroup b,Monoid.Semigroup c,Monoid.Semigroup d) => Monoid.Semigroup (a,b,c,d)


instance (Monoid.Semigroup a,Monoid.Semigroup b,Monoid.Semigroup c,Monoid.Semigroup d,Monoid.Semigroup e) => Monoid.Semigroup (a,b,c,d,e)


instance (Monoid.Semigroup a,Monoid.Semigroup b,Monoid.Semigroup c,Monoid.Semigroup d,Monoid.Semigroup e,Monoid.Semigroup f) => Monoid.Semigroup (a,b,c,d,e,f)


instance (Monoid.Semigroup a,Monoid.Semigroup b,Monoid.Semigroup c,Monoid.Semigroup d,Monoid.Semigroup e,Monoid.Semigroup f,Monoid.Semigroup g) => Monoid.Semigroup (a,b,c,d,e,f,g)


instance (Ord a,Ord b,Ord c,Ord d) => Ord (a,b,c,d)


instance (Ord a,Ord b,Ord c,Ord d,Ord e) => Ord (a,b,c,d,e)


instance (Ord a,Ord b,Ord c,Ord d,Ord e,Ord f) => Ord (a,b,c,d,e,f)


instance (Ord a,Ord b,Ord c,Ord d,Ord e,Ord f,Ord g) => Ord (a,b,c,d,e,f,g)


instance (Show a,Show b,Show c,Show d) => Show (a,b,c,d)


instance (Show a,Show b,Show c,Show d,Show e) => Show (a,b,c,d,e)


instance (Show a,Show b,Show c,Show d,Show e,Show f) => Show (a,b,c,d,e,f)


instance (Show a,Show b,Show c,Show d,Show e,Show f,Show g) => Show (a,b,c,d,e,f,g)


instance Functor (a,b,c)


instance Functor (a,b,c,d)


instance Functor (a,b,c,d,e)


instance Functor (a,b,c,d,e,f)


instance Monoid.Monoid a => Monad (a)



-- |  Provide wrappers 'Any' and 'All' for 'Bool' 'Monoid's   
module frege.data.wrapper.Boolean
-- |     'Monoid' for 'Bool' with operation 'und' and identity @true@
--      
data All

-- |  wrap a 'Bool' value   
All :: Bool -> Boolean.All

-- |     'Monoid' for 'Bool' with operation 'oder' and identity @false@
--      
data Any

-- |  wrap a 'Bool' value   
Any :: Bool -> Boolean.Any


instance Eq Boolean.All


instance Eq Boolean.Any

-- |  The 'Monoid' for 'All' uses @true@ as identity.   
instance Monoid.Monoid Boolean.All

-- |  The 'Monoid' for 'Any' uses @false@ as identity.   
instance Monoid.Monoid Boolean.Any

-- |  The 'Semigroup' instance for 'All' uses operation 'und'.   
instance Monoid.Semigroup Boolean.All

-- |  The 'Semigroup' instance for 'Any' uses operation 'oder'.   
instance Monoid.Semigroup Boolean.Any


instance Ord Boolean.All


instance Ord Boolean.Any


instance Show Boolean.All


instance Show Boolean.Any

-- | access field @unwrap@
getAll :: Boolean.All -> Bool

-- | access field @unwrap@
getAny :: Boolean.Any -> Bool



-- |  type level 'const'   
--  'Const' is a way to use some arbitrary type as an applicative  'Functor'    
module frege.data.wrapper.Const

data Const


Const :: a -> Const.Const a b


instance Functor (Const.Const m)


instance Monoid.Monoid m => Applicative (Const.Const m)



-- |  Provides a wrapper for a 'Monoid' that works in reverse   
module frege.data.wrapper.Dual
-- |  Provides a 'Monoid' where 'mappend' appears flipped.   
data Dual

-- |  wrap a value to give a 'Dual'   
Dual :: a -> Dual.Dual a


instance Eq a => Eq (Dual.Dual a)


instance Monoid.Monoid a => Monoid.Monoid (Dual.Dual a)


instance Monoid.Semigroup a => Monoid.Semigroup (Dual.Dual a)


instance Ord a => Ord (Dual.Dual a)


instance Show a => Show (Dual.Dual a)

-- | access field @unwrap@
getDual :: Dual.Dual a -> a



-- |  'Monoid' instance for endofunctions   
module frege.data.wrapper.Endo
-- |  The monoid of endomorphisms under composition.   
data Endo


Endo :: (a -> a) -> Endo.Endo a

-- |     The 'Monoid' instance for 'Endo' has functions as objects, 
--     uses '•' as operation and the identity is 'id'.      
instance Monoid.Monoid (Endo.Endo a)

-- | access field @unwrap@
appEndo :: Endo.Endo a -> a -> a



-- |     'Identity', along with instances for 'Functor',
--     'Applicative', 'Bind', 'Apply', 'Monad', 
--     'Semigroup', 'Monoid' and 'ListSource'
--          
module frege.data.wrapper.Identity

instance Enum a => Enum (Identity.Identity a)


instance Eq a => Eq (Identity.Identity a)

-- |     The identity functor and monad.
-- 
--     This trivial type constructor serves two purposes:
-- 
--     - It can be used with functions parameterized by a 
--       'Functor' or 'Monad'.
-- 
--     - It can be used as a base monad to which a series of monad
--       transformers may be applied to construct a composite monad.
--       Most monad transformer modules include the special case of
--       applying the transformer to 'Identity'.  For example, @State s@
--       is an abbreviation for @StateT s 'Identity'@. 
--      
-- 
--  Identity functor and monad.   
data Identity


Identity :: a -> Identity.Identity a


instance ListSource Identity.Identity


instance Monad Identity.Identity


instance Monoid.Monoid a => Monoid.Monoid (Identity.Identity a)


instance Monoid.Semigroup a => Monoid.Semigroup (Identity.Identity a)


instance Ord a => Ord (Identity.Identity a)


instance Show a => Show (Identity.Identity a)



-- |  'Monoid' wrappers for numeric data   
module frege.data.wrapper.Num

instance Eq a => Eq (Num.Product a)


instance Eq a => Eq (Num.Sum a)

-- |  The 'Monoid' instance for 'Product' has identity @1@   
instance Num a => Monoid.Monoid (Num.Product a)

-- |  The 'Monoid' instance for 'Sum' has identity @0@   
instance Num a => Monoid.Monoid (Num.Sum a)

-- |  The 'Semigroup' instance for 'Product' uses operation '*'   
instance Num a => Monoid.Semigroup (Num.Product a)

-- |  The 'Semigroup' instance for 'Sum' uses operation '+'   
instance Num a => Monoid.Semigroup (Num.Sum a)


instance Ord a => Ord (Num.Product a)


instance Ord a => Ord (Num.Sum a)

-- |     'Monoid' wrapper for numbers with operation '*' and identity 1
--      
data Product

-- |  wrap a number   
Product :: a -> Num.Product a


instance Show a => Show (Num.Product a)


instance Show a => Show (Num.Sum a)

-- |     'Monoid' wrapper for numbers with operation '+' and identity 0
--      
data Sum

-- |  wrap a number   
Sum :: a -> Num.Sum a

-- | access field @unwrap@
getProduct :: Num.Product a -> a

-- | access field @unwrap@
getSum :: Num.Sum a -> a



-- |  'Monoid' instances for bounded and ordered values, using 'min' and 'max'   
module frege.data.wrapper.Ord

instance (Ord a,Bounded a) => Monoid.Monoid (Ord.Max a)


instance (Ord a,Bounded a) => Monoid.Monoid (Ord.Min a)


instance Eq a => Eq (Ord.Max a)


instance Eq a => Eq (Ord.Min a)


data Max


Max :: a -> Ord.Max a


data Min


Min :: a -> Ord.Min a


instance Ord a => Monoid.Semigroup (Ord.Max a)


instance Ord a => Monoid.Semigroup (Ord.Min a)


instance Ord a => Ord (Ord.Max a)


instance Ord a => Ord (Ord.Min a)


instance Show a => Show (Ord.Max a)


instance Show a => Show (Ord.Min a)

-- | access field @unwrap@
getMax :: Ord.Max a -> a

-- | access field @unwrap@
getMin :: Ord.Min a -> a



-- |  A zip list.   
module frege.data.wrapper.ZipList

instance Applicative ZipList.ZipList


instance Foldable.Foldable ZipList.ZipList


instance Functor ZipList.ZipList


instance ListMonoid ZipList.ZipList


instance ListSource ZipList.ZipList


instance ListView ZipList.ZipList


instance Monoid.Monoid (ZipList.ZipList a)


instance Monoid.Semigroup (ZipList.ZipList a)


instance Traversable.Traversable ZipList.ZipList


data ZipList


ZipList :: [a] -> ZipList.ZipList a



-- |     Provide functions for use in the fregIDE
--      
module frege.ide.Utilities
-- |     This resembles the SourceProposal class.
--     The additional information must be lazy!
--      
data Proposal


Proposal :: String -> String -> String -> Int -> Int -> Int -> IO String -> Utilities.Proposal


instance Show Utilities.Proposal

-- |  create a 'Token' list from an 'JArray' backwards   
backwards :: JArray Tokens.Token -> Int -> [Tokens.Token]

-- |     Correct the result of 'frege.compiler.Scanner.dependencies',
--     which returns a singleton list with one element @"frege.prelude.PreludeBase"@
--     for source files that don't have any import clauses. Yet, unless this is a
--     prelude package itself, @"frege.Prelude"@ will be imported.
--     
--     This discrepancy leads to files not compiling in the FregIDE builder 
--     because they are queued before @"frege/Prelude.fr"@
--      
correctDependenciesFor :: [String] -> String -> [String]

-- |  a double colon in spaces, could be ∷ symbol if options allow   
dcolon :: Global.Global -> String


exprSymbols :: Expression.ExprT -> State.State Global.Global [Symbols.SymbolT Global.Global]

-- |  Get all the dependencies from a source text   
-- 
--  This will be done on a fresh 'Global'   
getDependencies :: CharSequence -> State.State Global.Global [String]


htmlDocumentation :: String -> State.StateT Global.Global IO String


htmlify :: Global.Global -> String -> IO String

-- |     Create a list of triples with  position, namespace and package
--     for every import except the automatic ones.
--          
imports :: Global.Global -> [(Positions.Position,String,String)]

-- |  find all operators in the current symbol table and tabulate their fixities   
infixDoc :: Global.Global -> String

-- |  initialize the root of the package tree   
initRoot :: String -> IO (Modules.Y Modules.RTree)

-- |  add a new module   
justCompiled :: Global.Global -> Modules.Y Modules.RTree -> IO (Modules.Y Modules.RTree)

-- |     Make a label for a symbol
--          
label :: Global.Global -> Symbols.SymbolT a -> String

-- |  lexical analysis from the IDE does not read files, but takes the content directly   
lexPassIDE :: CharSequence -> State.StateT Global.Global IO (String,Int)

-- |  add magic package names   
magicPNs :: [([String],a)] -> [([String],a)]

-- |     Make a new loader for operation in the IDE.
--     The rationale is that _not_ making a new loader for every character typed
--     will save time and space.
-- 
--     The IDE code must decide when to make a new loader. For instance, this could be
--     appropriate when the editor is re-activated, because in the meantime other modules
--     could have been rebuild.
--      
newLoader :: State.StateT Global.Global IO ()


packDocumentation :: String -> State.StateT Global.Global IO String

-- |     Increment the pass number in the state
--          
passDone :: State.State Global.Global ()

-- |     Called by Eclipse Content Proposer to make proposals.
--     
--     Usage: @proposeContent global offset tokens index@
--     
--     [global] a symbol table, preferably with type information
--     [offset] position of the caret
--     [tokens] array of tokens
--     [index]  index into the array, points to the token that starts before  the caret
--          
proposeContent :: Global.Global -> Modules.Y Modules.RTree -> Int -> JArray Tokens.Token -> Int -> [Utilities.Proposal]

-- |  Force the import to re-create packages next time   
refreshPackages :: State.StateT Global.Global IO ()


symbolDocumentation :: Symbols.SymbolT Global.Global -> State.StateT Global.Global IO String

-- |     Create the list of symbols ordered by position
--          
symbols :: TreeMap.TreeMap String (Symbols.SymbolT Global.Global) -> [Symbols.SymbolT Global.Global]

-- |     Failure tolerant version of 'Global.thisTab' for use in TreeModelBuilder.
--     In case of syntax errors, there is no symtab yet, hence Global.thisTab
--     is undefined. This, in turn, causes an exception in Eclipse. We can avoid
--     this by just pretending the symbol table was empty.
--          
thisTab :: Global.Global -> TreeMap.TreeMap String (Symbols.SymbolT Global.Global)

-- |     This is called from the fregIDE documentation provider
--     when the reference resolver didn't find anything.
--     
--     This indicates the mouse was not hovering over some identifier.
--      
tokenDocumentation :: Tokens.Token -> State.StateT Global.Global IO String

-- |  Remove this package from the package cache   
updateCache :: Monad c => b -> a -> c ()


verbose :: (Nice.Nice a,QNameMatcher.QNameMatcher a) => Global.Global -> Types.SigmaT a -> String



-- |  * Definitions for native components found in packages @java.awt@, @java.awt.event@
--       
module frege.java.Awt
-- |  an object with compile time type @java.awt.AWTEvent@   
data AWTEvent

-- |  an object with compile time type @java.awt.event.ActionEvent@   
data ActionEvent

-- |  an object with compile time type @java.awt.event.ActionListener@   
data ActionListener

-- |  a bare @java.awt.Component@   
data Component

-- |  a bare @java.awt.Container@   
data Container


data Frame


data LayoutManager

-- |  some @java.awt.Window@   
data Window



-- |     Classes from java.io
--      
module frege.java.IO

data BufferedReader

-- |  frege equivalent of @java.io.Closeable@   
data Closeable


data EOFException


instance Exceptional EOFException


instance Exceptional FileNotFoundException


instance Exceptional UnsupportedEncodingException


data File


data FileInputStream


data FileNotFoundException

-- |  frege equivalent of @java.io.FileOutputStream@   
data FileOutputStream

-- |  frege equivalent of @java.io.Flushable@   
data Flushable


data IOException


data InputStream


data InputStreamReader

-- |  frege equivalent of @java.io.OutputStream@   
data OutputStream


data OutputStreamWriter


data PrintStream


data PrintWriter


data Reader


instance Serializable File


instance Show File

-- |     Frege type for a @java.io.StringWriter@
--     
--     Not intended for direct use but rather as something
--     a 'PrintWriter' can be made of. (Though, because
--     of the 'Appendable' inheritance, one could 
--     still 'Appendable.append' directly.)
--     
--     To be used like:
--     
--     > action :: PrintWriter -> IO ()
--     > action =  ...
--     > actionOnStringWriter :: IO String  
--     > actionOnStringWriter = do
--     >       sw <- StringWriter.new
--     >       pr <- sw.printer
--     >       action pr
--     >       pr.close
--     >       sw.toString  
--          
data StringWriter

-- |  forward declaration of URI   
data URI


data UnsupportedEncodingException


data Writer

-- |     Convenience function to open a file in append mode for 
--     writing through an UTF-8 encoding
--     'PrintWriter'.
--     
--     May throw 'FileNotFoundException'
--          
appendWriter :: String -> IO PrintWriter

-- |     Convenience function to open a file and wrap it with an UTF-8 decoding
--     buffered 'Reader'.
--     
--     May throw 'FileNotFoundException'
--          
openReader :: String -> IO BufferedReader

-- |     Convenience function to open a file for writing through an UTF-8 encoding
--     'PrintWriter'.
--          
openWriter :: String -> IO PrintWriter

-- |  nowarn: Don't warn because of constantness   
-- 
--  The standard error 'PrintWriter'   
stderr :: PrintWriter

-- |  nowarn: Don't warn because of constantness   
-- 
--  The standard input 'BufferedReader'   
stdin :: BufferedReader

-- |  nowarn: Don't warn because of constantness   
-- 
--  The standard output 'PrintWriter'   
stdout :: PrintWriter



-- |  * Here live all classes and interfaces from @java.lang@ except those already
--  * introduced in the Prelude.
--       
module frege.java.Lang

data Appendable


instance ArrayElement (JEnum e)


instance ArrayElement Object


data Boolean


instance Bounded Byte


instance Bounded Short

-- |  'Byte' is the Frege type for the primitive JVM @byte@   
-- 
--  However, it is given _unsigend_ semantics in Frege.   
-- 
--  Use 'Byte' only in 'JArray's or tightly packed records!    
-- 
--  Otherwise you'll waste time while not saving space.   
data Byte


data CharSequence


data Character


data ClassLoader

-- |  Forward declaration of 'frege.java.Lang#ClassNotFoundException'   
data ClassNotFoundException


data Comparable


instance Enum Byte


instance Enum Short


instance Eq Byte


instance Eq Short


data Error


data Exception


data ExceptionInInitializerError


instance Exceptional ClassNotFoundException


instance Exceptional Error


instance Exceptional ExceptionInInitializerError


instance Exceptional IOException


instance Exceptional IllegalAccessException


instance Exceptional IllegalArgumentException


instance Exceptional IllegalStateException


instance Exceptional IllegalThreadStateException


instance Exceptional IndexOutOfBoundsException


instance Exceptional InstantiationException


instance Exceptional InterruptedException


instance Exceptional NoSuchFieldException


instance Exceptional NoSuchMethodError


instance Exceptional NullPointerException


instance Exceptional SecurityException


instance Exceptional StringIndexOutOfBoundsException


instance Exceptional Throwable


data IOException


data IllegalAccessException


data IllegalArgumentException


data IllegalStateException


data IllegalThreadStateException


data IndexOutOfBoundsException


data InstantiationException


instance Integral Byte


instance Integral Short


data InterruptedException


data Iterable


data Iterator


data JEnum


data NoSuchFieldException


data NoSuchMethodError


data NullPointerException


instance Num Byte


instance Num Short

-- |  @java.lang.NumberFormatException@ needed for string conversion operations   
-- 
--  declared *@protected@* to avoid name conflicts with 'frege.java.Lang#NumberFormatException'    
data NumberFormatException

-- |     The Java Object type
--          
data Object

-- |  The 'Ord' instance for 'Byte's assumes that bytes are unsigned.   
-- 
--  Hence   
-- 
--  > byte (-1) > byte 1   
instance Ord Byte

-- |  The 'Ord' instance for 'Byte's assumes that bytes are unsigned.   
-- 
--  Hence   
-- 
--  > byte (-1) > byte 1   
instance Ord Short


instance PrimitiveArrayElement Byte


instance PrimitiveArrayElement Short


data PrintStream


data Readable

-- |  A @java.lang.Runnable@, can be created from 'IO' or 'ST' actions   
data Runnable


data SecurityException


instance Serializable StringBuffer

-- |  'Short' is the Frege type for the primitive JVM @short@   
-- 
--  However, it is given _unsigend_ semantics in Frege.   
-- 
--  Use 'Short' only in 'JArray's or tightly packed records!    
-- 
--  Otherwise you'll waste time while not saving space.   
data Short


data StringBuffer

-- |  Resembles @java.lang.StringBuilder@   
data StringBuilder


data StringIndexOutOfBoundsException


data System

-- |  An OS thread   
data Thread

-- |  Frege wrapper for java Throwables.   
data Throwable

-- |  convert an 'Int' to a 'Byte' by chopping off the leading 24 bits.   
byte :: Int -> Byte

-- |  convert an 'Int' to a 'Short' by chopping off the leading 16 bits.   
short :: Int -> Short



-- |     Java types from java.net
--      
module frege.java.Net

instance ArrayElement Net.URL


instance Exceptional Net.MalformedURLException


instance Exceptional Net.URISyntaxException


data MalformedURLException


data URI


data URISyntaxException

-- |     Frege type for @java.net.URL@, note that we do not support operations
--     that mutate the URL, hence we regard every instance as immutable.
--      
data URL


type URLArray = JArray Net.URL


data URLClassLoader


data URLConnection



-- |  * Definitions for native components below javax.swing
--       
module frege.java.Swing
-- |  an object with compiler time type @javax.swing.AbstractButton@   
data AbstractButton


data GroupLayout

-- |  an object with compiler time type @javax.swing.JButton@   
data JButton

-- |  an object with compiler time type @javax.swing.JComponent@   
data JComponent

-- |  A @javax.swing.JFrame@   
data JFrame

-- |  a swing label   
data JLabel

-- |  an object with compiler time type @javax.swing.JPanel@   
data JPanel


data JTextComponent

-- |  an object with compile time type @javax.swing.JTextField@   
data JTextField

-- |  this is defined as an abstract type so as to enable
--  * the access to the constants in the usual way.
--  *
--  * Note that the constants are in lowercase, in contrast to Java.
--       
data SwingConstants

-- |  wrapper for @javax.swing.SwingUtilities.invokeAndWait@   
invokeAndWait :: MutableIO Runnable -> IO ()

-- |  wrapper for @javax.swing.SwingUtilities.invokeLater@   
invokeLater :: MutableIO Runnable -> IO ()



-- |  Java classes from package @java.util@   
module frege.java.Util
-- |  This class provides a skeletal implementation of the Collection interface, to minimize the effort required to
--  implement this interface.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/AbstractCollection.html JavaDoc'
--      
data AbstractCollection

-- |  This class provides a skeletal implementation of the List interface to minimize the effort required to
--  implement this interface backed by a "random access" data store (such as an array).
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/AbstractList.html JavaDoc'
--      
data AbstractList

-- |  This class provides a skeletal implementation of the Map interface, to minimize the effort required to implement this interface.
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.html JavaDoc'
--      
data AbstractMap

-- |  An Entry maintaining a key and a value.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/AbstractMap.SimpleEntry.html JavaDoc'
--      
data AbstractMapSimpleEntry

-- |  An Entry maintaining an immutable key and value. This class does not support method @setValue@.
--  This class may be convenient in methods that return thread-safe snapshots of key-value mappings.
--      
data AbstractMapSimpleImmutableEntry

-- |  This class provides skeletal implementations of some Queue operations.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/AbstractQueue.html JavaDoc'
--      
data AbstractQueue

-- |  This class provides a skeletal implementation of the List interface to minimize the effort required to implement
--  this interface backed by a "sequential access" data store (such as a linked list). For random access data (such as an array),
--  AbstractList should be used in preference to this class.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/AbstractSequentialList.html AbstractSequentialList JavaDoc'
--      
data AbstractSequentialList

-- |  This class provides a skeletal implementation of the Set interface to minimize the effort required to implement this interface.
--  The process of implementing a set by extending this class is identical to that of implementing a Collection
--  by extending AbstractCollection, except that all of the methods and constructors in subclasses of this class
--  must obey the additional constraints imposed by the Set interface (for instance, the add method must not permit
--  addition of multiple instances of an object to a set).
-- 
--  Note that this class does not override any of the implementations from the AbstractCollection class.
--  It merely adds implementations for equals and hashCode.
--      
data AbstractSet

-- |  Resizable-array implementation of the Deque interface.
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/ArrayDeque.html JavaDoc'
--      
data ArrayDeque


instance ArrayElement Util.FormatterBigDecimalLayoutForm


instance ArrayElement Util.Locale


instance ArrayElement Util.LocaleCategory

-- |  Resizable-array implementation of the List interface.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/ArrayList.html JavaDoc'
--      
data ArrayList

-- |   This class contains various methods for manipulating arrays (such as sorting and searching).
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Arrays.html Javadoc'
--      
data Arrays


data BigDecimal

-- |   This class implements a vector of bits that grows as needed.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/BitSet.html JavaDoc'
--      
data BitSet


data ByteBuffer

-- |   The Calendar class is an abstract class that provides methods for converting between a specific instant in time and
--   a set of 'https://docs.oracle.com/javase/7/docs/api/java/util/Calendar.html#fields calendar fields' such as YEAR, MONTH,
--   DAY_OF_MONTH, HOUR, and so on, and for manipulating the calendar fields, such as getting the date of the next week.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Calendar.html JavaDoc'
--      
data Calendar

-- |  The root interface in the collection hierarchy.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Collection.html JavaDoc'
--      
data Collection

-- |   This class consists exclusively of static methods that operate on or return collections.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Collections.html JavaDoc'
--      
data Collections

-- |    From Javadoc:
--    A comparison function, which imposes a total ordering on some collection of objects.
--    Comparators can be passed to a sort method (such as Collections.sort or Arrays.sort) to allow
--    precise control over the sort order. Comparators can also be used to control the order of
--    certain data structures (such as sorted sets or sorted maps), or to provide
--    an ordering for collections of objects that don't have a natural ordering.
-- 
--    More: 'http://docs.oracle.com/javase/7/docs/api/java/util/Comparator.html Comparator JavaDoc'
--      
data Comparator


data ConcurrentModificationException

-- |   Represents a currency.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Currency.html JavaDoc'
--      
data Currency

-- |   The class Date represents a specific instant in time, with millisecond precision.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Date.html JavaDoc'
--      
data Date

-- |  A linear collection that supports element insertion and removal at both ends.
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Deque.html Deque JavaDoc'
--      
data Deque

-- |   The Dictionary class is the abstract parent of any class, such as Hashtable, which maps keys to values.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Dictionary.html JavaDoc'
--      
data Dictionary


data DuplicateFormatFlagsException

-- |  A specialized Map implementation for use with enum type keys.
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/EnumMap.html JavaDoc'
--      
data EnumMap

-- |  A specialized 'https://docs.oracle.com/javase/7/docs/api/java/util/Set.html Set' implementation for use with enum types.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/EnumSet.html JavaDoc'
--      
data EnumSet


data Enumeration

-- |  A tagging interface that all event listener interfaces must extend.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/EventListener.html JavaDoc'
--      
data EventListener

-- |   An abstract wrapper class for an EventListener class which associates a set of additional parameters with the listener.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/EventListenerProxy.html JavaDoc'
--      
data EventListenerProxy

-- |   The root class from which all event state objects shall be derived.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/EventObject.html JavaDoc'
--      
data EventObject


instance Exceptional Util.ConcurrentModificationException


instance Exceptional Util.DuplicateFormatFlagsException


instance Exceptional Util.FormatFlagsConversionMismatchException


instance Exceptional Util.FormatterClosedException


instance Exceptional Util.IllegalFormatCodePointException


instance Exceptional Util.IllegalFormatConversionException


instance Exceptional Util.IllegalFormatException


instance Exceptional Util.IllegalFormatFlagsException


instance Exceptional Util.IllegalFormatPrecisionException


instance Exceptional Util.IllegalFormatWidthException


instance Exceptional Util.IllformedLocaleException


instance Exceptional Util.InputMismatchException


instance Exceptional Util.InvalidPropertiesFormatException


instance Exceptional Util.MissingFormatArgumentException


instance Exceptional Util.MissingFormatWidthException


instance Exceptional Util.MissingResourceException


instance Exceptional Util.NoSuchElementException


instance Exceptional Util.ServiceConfigurationError


instance Exceptional Util.TooManyListenersException


instance Exceptional Util.UnknownFormatConversionException


instance Exceptional Util.UnknownFormatFlagsException


data File


data FileNotFoundException


data FormatFlagsConversionMismatchException

-- |  The Formattable interface must be implemented by any class that needs to perform custom formatting using the 's'
--  conversion specifier of 'https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html Formatter'.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Formattable.html JavaDoc'
--      
data Formattable

-- |   FomattableFlags are passed to the
--   'https://docs.oracle.com/javase/7/docs/api/java/util/Formattable.html#formatTo(java.util.Formatter,%20int,%20int,%20int) Formattable.formatTo()'
--   method and modify the output format for 'https://docs.oracle.com/javase/7/docs/api/java/util/Formattable.html Formattables'.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/FormattableFlags.html JavaDoc'
--      
data FormattableFlags

-- |  An interpreter for printf-style format strings.
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Formatter.html Formatter JavaDoc'
--      
data Formatter


data FormatterBigDecimalLayoutForm


data FormatterClosedException

-- |   GregorianCalendar is a concrete subclass of Calendar and provides the standard calendar system used by most of the world.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/GregorianCalendar.html JavaDoc'
--      
data GregorianCalendar

-- |  Hash table based implementation of the Map interface.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/HashMap.html JavaDoc'
--      
data HashMap

-- |  This class implements the Set interface, backed by a hash table (actually a HashMap instance).
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/HashSet.html JavaDoc'
--      
data HashSet

-- |   This class implements a hash table, which maps keys to values.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Hashtable.html JavaDoc'
--      
data Hashtable

-- |  This class implements the Map interface with a hash table, using reference-equality in place of
--  object-equality when comparing keys (and values).
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/IdentityHashMap.html JavaDoc'
--      
data IdentityHashMap


data IllegalFormatCodePointException


data IllegalFormatConversionException


data IllegalFormatException


data IllegalFormatFlagsException


data IllegalFormatPrecisionException


data IllegalFormatWidthException


data IllformedLocaleException


data InputMismatchException


data InvalidPropertiesFormatException

-- |  An iterator over a collection.
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Iterator.html JavaDoc'
--      
data Iterator

-- |  Hash table and linked list implementation of the Map interface, with predictable iteration order.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashMap.html JavaDoc'
--      
data LinkedHashMap

-- |  Hash table and linked list implementation of the Set interface, with predictable iteration order.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/LinkedHashSet.html JavaDoc'
--      
data LinkedHashSet

-- |  Doubly-linked list implementation of the List and Deque interfaces.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/LinkedList.html JavaDoc'
--      
data LinkedList

-- |  An ordered collection (also known as a sequence).
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/List.html JavaDoc'
--      
data List

-- |   An iterator for lists that allows the programmer to traverse the list in either direction,
--   modify the list during iteration, and obtain the iterator's current position in the list.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/ListIterator.html JavaDoc'
--      
data ListIterator

-- |   ListResourceBundle is an abstract subclass of ResourceBundle that manages resources for a locale in a convenient and easy to use list.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/ListResourceBundle.html JavaDoc'
--      
data ListResourceBundle

-- |  A @Locale@ object represents a specific geographical, political, or cultural region.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Locale.html JavaDoc'
--      
data Locale

-- |   Builder is used to build instances of Locale from values configured by the setters.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Locale.Builder.html JavaDoc'
--      
data LocaleBuilder

-- |  Enum for locale categories. These locale categories are used to get/set the default locale for the
--  specific functionality represented by the category.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Locale.Category.html JavaDoc'
--      
data LocaleCategory


data LongBuffer

-- |  An object that maps keys to values.
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Map.html JavaDoc'
--      
data Map

-- |  A map entry (key-value pair).
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Map.Entry.html JavaDoc'
--      
data MapEntry


data MissingFormatArgumentException


data MissingFormatWidthException


data MissingResourceException

-- |  A SortedMap extended with navigation methods returning the closest matches for given search targets.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/NavigableMap.html NavigableMap JavaDoc'
--      
data NavigableMap

-- |  A SortedSet extended with navigation methods reporting closest matches for given search targets.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/NavigableSet.html JavaDoc'
--      
data NavigableSet


data NoSuchElementException

-- |   This class consists of static utility methods for operating on objects.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Objects.html JavaDoc'
--      
data Objects

-- |  This class represents an observable object, or "data" in the model-view paradigm.
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Observable.html Observable JavaDoc'
--      
data Observable

-- |  A class can implement the Observer interface when it wants to be informed of changes in observable objects.
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Observer.html JavaDoc'
--      
data Observer


data Path


data Permission


data PermissionCollection

-- |  An unbounded priority queue based on a priority heap.
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/PriorityQueue.html PriorityQueue JavaDoc'
--      
data PriorityQueue

-- |   The Properties class represents a persistent set of properties.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Properties.html JavaDoc'
--      
data Properties

-- |   This class is for property permissions.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/PropertyPermission.html JavaDoc'
--      
data PropertyPermission

-- |   PropertyResourceBundle is a concrete subclass of ResourceBundle that manages resources for a locale using a set of static strings from a property file.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/PropertyResourceBundle.html JavaDoc'
--      
data PropertyResourceBundle

-- |  A collection designed for holding elements prior to processing.
--  Queues typically, but do not necessarily, order elements in a FIFO (first-in-first-out) manner.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Queue.html JavaDoc'
--      
data Queue

-- |     A value of this type is used to generate a stream of pseudorandom numbers.
--     The type uses a 48-bit seed, which is modified using a linear congruential formula.
--     (See Donald Knuth, The Art of Computer Programming, Volume 2, Section 3.2.1.)
-- 
--     If two 'Random' values are created with the same seed,
--     and the same sequence of method calls is made for each,
--     they will generate and return identical sequences of numbers.
--     In order to guarantee this property, particular algorithms are
--     specified for the class Random.
-- 
--     Many applications will find the function 'frege.prelude.Math#random'
--     simpler to use.
--      
data Random

-- |  Marker interface used by List implementations to indicate that they support fast (generally constant time) random access.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/RandomAccess.html JavaDoc'
--      
data RandomAccess


data ReadableByteChannel


data Reader

-- |   Resource bundles contain locale-specific objects.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/ResourceBundle.html JavaDoc'
--      
data ResourceBundle

-- |   ResourceBundle_Control defines a set of callback methods that are invoked by the
--   'https://docs.oracle.com/javase/7/docs/api/java/util/ResourceBundle.html
--   #getBundle(java.lang.String,%20java.util.Locale,%20java.lang.ClassLoader,%20java.util.ResourceBundle.Control) ResourceBundle.getBundle'
--   factory methods during the bundle loading process.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/ResourceBundle.Control.html JavaDoc'
--      
data ResourceBundle_Control

-- |  A simple text scanner which can parse primitive types and strings using regular expressions.
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Scanner.html JavaDoc'
--      
data Scanner


instance Serializable (Util.AbstractMapSimpleEntry k v)


instance Serializable (Util.AbstractMapSimpleImmutableEntry k v)


instance Serializable (Util.ArrayDeque e)


instance Serializable (Util.ArrayList e)


instance Serializable (Util.EnumMap k v)


instance Serializable (Util.EnumSet e)


instance Serializable (Util.HashMap k v)


instance Serializable (Util.HashSet e)


instance Serializable (Util.Hashtable k v)


instance Serializable (Util.IdentityHashMap k v)


instance Serializable (Util.LinkedHashMap k v)


instance Serializable (Util.LinkedHashSet e)


instance Serializable (Util.LinkedList e)


instance Serializable (Util.PriorityQueue e)


instance Serializable (Util.Stack e)


instance Serializable (Util.TreeMap k v)


instance Serializable (Util.TreeSet e)


instance Serializable (Util.Vector e)


instance Serializable Util.BitSet


instance Serializable Util.Calendar


instance Serializable Util.Currency


instance Serializable Util.Date


instance Serializable Util.EventObject


instance Serializable Util.FormatterBigDecimalLayoutForm


instance Serializable Util.GregorianCalendar


instance Serializable Util.Locale


instance Serializable Util.LocaleCategory


instance Serializable Util.Properties


instance Serializable Util.PropertyPermission


instance Serializable Util.SimpleTimeZone


instance Serializable Util.TimeZone


instance Serializable Util.UUID


data ServiceConfigurationError

-- |   A simple service-provider loading facility.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/ServiceLoader.html JavaDoc'
--      
data ServiceLoader

-- |   A collection that contains no duplicate elements.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Set.html JavaDoc'
--      
data Set


instance Show Util.Locale

-- |   SimpleTimeZone is a concrete subclass of TimeZone that represents a time zone for use with a Gregorian calendar.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/SimpleTimeZone.html JavaDoc'
--      
data SimpleTimeZone

-- |  A 'https://docs.oracle.com/javase/7/docs/api/java/util/Map.html Map' that further provides a total ordering on its keys.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/SortedMap.html JavaDoc'
--      
data SortedMap

-- |  A Set that further provides a total ordering on its elements.
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/SortedSet.html SortedSet JavaDoc'
--      
data SortedSet

-- |  The Stack class represents a last-in-first-out (LIFO) stack of objects.
--  It extends class Vector with five operations that allow a vector to be treated as a stack.
--  The usual push and pop operations are provided, as well as a method to peek at the top item on the stack,
--  a method to test for whether the stack is empty, and a method to search the stack for an item and
--  discover how far it is from the top.
-- 
--  When a stack is first created, it contains no items.
-- 
--  A more complete and consistent set of LIFO stack operations is provided by the Deque interface and
--  its implementations, which should be used in preference to this class. For example:
-- 
--  > Deque<Integer> stack = new ArrayDeque<Integer>();
-- 
--      
data Stack

-- |   The string tokenizer class allows an application to break a string into tokens.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/StringTokenizer.html JavaDoc'
--      
data StringTokenizer

-- |   TimeZone represents a time zone offset, and also figures out daylight savings.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/TimeZone.html JavaDoc'
--      
data TimeZone

-- |   A facility for threads to schedule tasks for future execution in a background thread.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Timer.html JavaDoc'
--      
data Timer

-- |   A task that can be scheduled for one-time or repeated execution by a Timer.
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/TimerTask.html JavaDoc'
--      
data TimerTask


data TooManyListenersException

-- |  A Red-Black tree based 'https://docs.oracle.com/javase/7/docs/api/java/util/NavigableMap.html NavigableMap' implementation.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html JavaDoc'
--      
data TreeMap

-- |  A 'https://docs.oracle.com/javase/7/docs/api/java/util/NavigableSet.html NavigableSet' implementation based
--  on a 'https://docs.oracle.com/javase/7/docs/api/java/util/TreeMap.html TreeMap'.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/TreeSet.html JavaDoc'
--      
data TreeSet

-- |   A class that represents an immutable universally unique identifier (UUID).
-- 
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/UUID.html JavaDoc'
--      
data UUID


data UnknownFormatConversionException


data UnknownFormatFlagsException

-- |  The Vector class implements a growable array of objects.
-- 
--  More: 'https://docs.oracle.com/javase/7/docs/api/java/util/Vector.html JavaDoc'
--      
data Vector

-- |   Hash table based implementation of the Map interface, with weak keys.
--   More: 'https://docs.oracle.com/javase/7/docs/api/java/util/WeakHashMap.html JavaDoc'
--      
data WeakHashMap



-- |     Mathematical functions from 'http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html java.lang.Math'.
-- 
--     Functions that are already defined elsewhere, like @abs@ or @min@ have been left out.
-- 
--     This module is not good for inclusion in user code, because of the overloaded
--     primitive functions.
--     
--     Better use
--     
--     > import Prelude.Math
--     
--     which also defines the class 'Prelude.Math#Floating' that makes it possibly to use
--     the primitive functions in a type safe way.
--      
module frege.java.lang.Math
-- |  Returns the value of the first argument raised to the power of the second argument.   
(**) :: ω

-- |  Returns the value of the first argument raised to the power of the second argument.   
**a :: Double -> Double -> Double

-- |  Returns the value of the first argument raised to the power of the second argument.   
**b :: Float -> Float -> Double

-- |  Returns the arc cosine of a value; the returned angle is in the range 0.0 through 'pi'.   
acos :: ω

-- |  Returns the arc cosine of a value; the returned angle is in the range 0.0 through 'pi'.   
acosa :: Float -> Double

-- |  Returns the arc cosine of a value; the returned angle is in the range 0.0 through 'pi'.   
acosb :: Double -> Double

-- |  Returns the arc sine of a value; the returned angle is in the range -'pi'/2 through 'pi'/2.   
asin :: ω

-- |  Returns the arc sine of a value; the returned angle is in the range -'pi'/2 through 'pi'/2.   
asina :: Float -> Double

-- |  Returns the arc sine of a value; the returned angle is in the range -'pi'/2 through 'pi'/2.   
asinb :: Double -> Double

-- |  Returns the arc tangent of a value; the returned angle is in the range -'pi'/2 through 'pi'/2.   
atan :: ω

-- |  Returns the angle theta from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta).   
atan2 :: ω

-- |  Returns the angle theta from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta).   
atan2a :: Double -> Double -> Double

-- |  Returns the angle theta from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta).   
atan2b :: Float -> Float -> Double

-- |  Returns the arc tangent of a value; the returned angle is in the range -'pi'/2 through 'pi'/2.   
atana :: Float -> Double

-- |  Returns the arc tangent of a value; the returned angle is in the range -'pi'/2 through 'pi'/2.   
atanb :: Double -> Double

-- |  Returns the cube root of a value.   
cbrt :: ω

-- |  Returns the cube root of a value.   
cbrta :: Double -> Double

-- |  Returns the cube root of a value.   
cbrtb :: Float -> Double

-- |  Returns the smallest (closest to negative infinity) value that is greater than or equal to the argument and is equal to a mathematical integer.   
ceil :: ω

-- |  Returns the smallest (closest to negative infinity) value that is greater than or equal to the argument and is equal to a mathematical integer.   
ceila :: Double -> Double

-- |  Returns the smallest (closest to negative infinity) value that is greater than or equal to the argument and is equal to a mathematical integer.   
ceilb :: Float -> Double

-- |  Returns the first argument with the sign of the second argument.   
copySign :: ω

-- |  Returns the first argument with the sign of the second argument.   
copySigna :: Double -> Double -> Double

-- |  Returns the first argument with the sign of the second argument.   
copySignb :: Float -> Float -> Float

-- |  Returns the trigonometric cosine of an angle.   
cos :: ω

-- |  Returns the trigonometric cosine of an angle.   
cosa :: Double -> Double

-- |  Returns the trigonometric cosine of an angle.   
cosb :: Float -> Double

-- |  Returns the hyperbolic cosine of a floating point value.   
cosh :: ω

-- |  Returns the hyperbolic cosine of a floating point value.   
cosha :: Double -> Double

-- |  Returns the hyperbolic cosine of a floating point value.   
coshb :: Float -> Double

-- |  The 'Double' value that is closer than any other to e, the base of the natural logarithms.   
e :: Double

-- |  Returns Euler's number 'e' raised to the power of a floating-point value.   
exp :: ω

-- |  Returns Euler's number 'e' raised to the power of a floating-point value.   
expa :: Double -> Double

-- |  Returns Euler's number 'e' raised to the power of a floating-point value.   
expb :: Float -> Double

-- |  Returns @e^x -1@.   
expm1 :: ω

-- |  Returns @e^x -1@.   
expm1a :: Double -> Double

-- |  Returns @e^x -1@.   
expm1b :: Float -> Double

-- |   Returns the largest (closest to positive infinity) value that is
--   less than or equal to the argument and is equal to a mathematical integer.
-- 
--   Special cases:
-- 
--     - If the argument value is already equal to a mathematical integer,
--     then the result is the same as the argument.
--     - If the argument is NaN or an infinity or positive zero or
--     negative zero, then the result is the same as the argument.
-- 
--       
floor :: ω

-- |   Returns the largest (closest to positive infinity) value that is
--   less than or equal to the argument and is equal to a mathematical integer.
-- 
--   Special cases:
-- 
--     - If the argument value is already equal to a mathematical integer,
--     then the result is the same as the argument.
--     - If the argument is NaN or an infinity or positive zero or
--     negative zero, then the result is the same as the argument.
-- 
--       
floora :: Double -> Double

-- |   Returns the largest (closest to positive infinity) value that is
--   less than or equal to the argument and is equal to a mathematical integer.
-- 
--   Special cases:
-- 
--     - If the argument value is already equal to a mathematical integer,
--     then the result is the same as the argument.
--     - If the argument is NaN or an infinity or positive zero or
--     negative zero, then the result is the same as the argument.
-- 
--       
floorb :: Float -> Double

-- |  Returns the unbiased exponent used in the representation of a floating point number.   
getExponent :: ω

-- |  Returns the unbiased exponent used in the representation of a floating point number.   
getExponenta :: Double -> Int

-- |  Returns the unbiased exponent used in the representation of a floating point number.   
getExponentb :: Float -> Int

-- |  Returns 'sqrt' @(x² + y²)@ without intermediate overflow or underflow.   
hypot :: ω

-- |  Returns 'sqrt' @(x² + y²)@ without intermediate overflow or underflow.   
hypota :: Double -> Double -> Double

-- |  Returns 'sqrt' @(x² + y²)@ without intermediate overflow or underflow.   
hypotb :: Float -> Float -> Double

-- |  Computes the remainder operation on two arguments as prescribed by the IEEE 754 standard.   
ieeeRemainder :: ω

-- |  Computes the remainder operation on two arguments as prescribed by the IEEE 754 standard.   
ieeeRemaindera :: Double -> Double -> Double

-- |  Computes the remainder operation on two arguments as prescribed by the IEEE 754 standard.   
ieeeRemainderb :: Float -> Float -> Double

-- |  Returns the natural logarithm (base 'e') of a value.   
log :: ω

-- |  Returns the base 10 logarithm of a value.   
log10 :: ω

-- |  Returns the base 10 logarithm of a value.   
log10a :: Double -> Double

-- |  Returns the base 10 logarithm of a value.   
log10b :: Float -> Double

-- |  Returns the natural logarithm of the sum of the argument and 1.   
log1p :: ω

-- |  Returns the natural logarithm of the sum of the argument and 1.   
log1pa :: Double -> Double

-- |  Returns the natural logarithm of the sum of the argument and 1.   
log1pb :: Float -> Double

-- |  Returns the natural logarithm (base 'e') of a value.   
loga :: Double -> Double

-- |  Returns the natural logarithm (base 'e') of a value.   
logb :: Float -> Double

-- |  Returns the floating-point number adjacent to the first argument in the direction of the second argument.   
nextAfter :: ω

-- |  Returns the floating-point number adjacent to the first argument in the direction of the second argument.   
nextAftera :: Double -> Double -> Double

-- |  Returns the floating-point number adjacent to the first argument in the direction of the second argument.   
nextAfterb :: Float -> Float -> Double

-- |  Returns the floating-point value adjacent to the argument in the direction of positive infinity.   
nextUp :: ω

-- |  Returns the floating-point value adjacent to the argument in the direction of positive infinity.   
nextUpa :: Double -> Double

-- |  Returns the floating-point value adjacent to the argument in the direction of positive infinity.   
nextUpb :: Float -> Float

-- |  The 'Double' value that is closer than any other to pi, the ratio of the circumference of a circle to its diameter.   
pi :: Double

-- |  Returns the value of the first argument raised to the power of the second argument.   
pow :: ω

-- |  Returns the value of the first argument raised to the power of the second argument.   
powa :: Double -> Double -> Double

-- |  Returns the value of the first argument raised to the power of the second argument.   
powb :: Float -> Float -> Double

-- |  Returns the 'Double' value that is closest in value to the argument and is equal to a mathematical integer.   
rint :: ω

-- |  Returns the 'Double' value that is closest in value to the argument and is equal to a mathematical integer.   
rinta :: Double -> Double

-- |  Returns the 'Double' value that is closest in value to the argument and is equal to a mathematical integer.   
rintb :: Float -> Double

-- |  Returns the closest 'Long' to the argument, with ties rounding up.   
round :: ω

-- |  Returns the closest 'Long' to the argument, with ties rounding up.   
rounda :: Double -> Long

-- |  Returns the closest 'Long' to the argument, with ties rounding up.   
roundb :: Float -> Long

-- |  > scalb d scaleFactor   
-- 
--  Return @d * 2^scaleFactor@ rounded as if performed by a single correctly rounded floating-point multiply.   
scalb :: ω

-- |  > scalb d scaleFactor   
-- 
--  Return @d * 2^scaleFactor@ rounded as if performed by a single correctly rounded floating-point multiply.   
scalba :: Double -> Int -> Double

-- |  > scalb d scaleFactor   
-- 
--  Return @d * 2^scaleFactor@ rounded as if performed by a single correctly rounded floating-point multiply.   
scalbb :: Float -> Int -> Float

-- |  Returns the signum function of the argument; zero if the argument is zero, 1.0 if the argument is greater than zero, -1.0 if the argument is less than zero.   
signum :: ω

-- |  Returns the signum function of the argument; zero if the argument is zero, 1.0 if the argument is greater than zero, -1.0 if the argument is less than zero.   
signuma :: Double -> Double

-- |  Returns the signum function of the argument; zero if the argument is zero, 1.0 if the argument is greater than zero, -1.0 if the argument is less than zero.   
signumb :: Float -> Float

-- |  Returns the trigonometric sine of an angle.   
sin :: ω

-- |  Returns the trigonometric sine of an angle.   
sina :: Double -> Double

-- |  Returns the trigonometric sine of an angle.   
sinb :: Float -> Double

-- |  Returns the hyperbolic sine of a value.   
sinh :: ω

-- |  Returns the hyperbolic sine of a value.   
sinha :: Double -> Double

-- |  Returns the hyperbolic sine of a value.   
sinhb :: Float -> Double

-- |  Returns the correctly rounded positive square root of a value.   
sqrt :: ω

-- |  Returns the correctly rounded positive square root of a value.   
sqrta :: Double -> Double

-- |  Returns the correctly rounded positive square root of a value.   
sqrtb :: Float -> Double

-- |  Returns the trigonometric tangent of an angle.   
tan :: ω

-- |  Returns the trigonometric tangent of an angle.   
tana :: Double -> Double

-- |  Returns the trigonometric tangent of an angle.   
tanb :: Float -> Double

-- |  Returns the hyperbolic tangent of a floating point value.   
tanh :: ω

-- |  Returns the hyperbolic tangent of a floating point value.   
tanha :: Double -> Double

-- |  Returns the hyperbolic tangent of a floating point value.   
tanhb :: Float -> Double

-- |  Converts an angle measured in radians to an approximately equivalent angle measured in degrees.   
toDegrees :: ω

-- |  Converts an angle measured in radians to an approximately equivalent angle measured in degrees.   
toDegreesa :: Double -> Double

-- |  Converts an angle measured in radians to an approximately equivalent angle measured in degrees.   
toDegreesb :: Float -> Double

-- |  Converts an angle measured in degrees to an approximately equivalent angle measured in radians.   
toRadians :: ω

-- |  Converts an angle measured in degrees to an approximately equivalent angle measured in radians.   
toRadiansa :: Double -> Double

-- |  Converts an angle measured in degrees to an approximately equivalent angle measured in radians.   
toRadiansb :: Float -> Double

-- |  Returns the size of an ulp of the argument.   
ulp :: ω

-- |  Returns the size of an ulp of the argument.   
ulpa :: Double -> Double

-- |  Returns the size of an ulp of the argument.   
ulpb :: Float -> Float



-- |  Java types needed to run processes.   
--  Because the associated classes are in @java.lang@,
--     the stuff here would belong into package @frege.java.Lang@,
--     however, it does not seem justified to have it imported in
--     each and every program.      
module frege.java.lang.Processes
-- |      The type 'Process' provides methods for performing input 
--      from the process, performing output to the process, 
--      waiting for the process to complete, 
--      checking the exit status of the process, 
--      and destroying (killing) the process.
--      
--      An instance of 'Process' can be obtained from the 'Process.exec'
--      or 'ProcessBuilder.start' methods.
--      
data Process

-- |     The 'ProcessBuilder' type is used to create operating system processes.
--     
--     Each 'ProcessBuilder' manages a collection of process attributes. 
--     The 'ProcessBuilder.start' method creates a new 'Process' instance 
--     with those attributes. 
--     The 'ProcessBuilder.start' method can be invoked repeatedly 
--     from the same instance to create new subprocesses with 
--     identical or related attributes.
--     
--     The following attributes are being managed:
--     
--     - a _command_, a list of strings which signifies the external 
--     program file to be invoked and its arguments, if any. 
--     Which string lists represent a valid operating system command is 
--     system-dependent. For example, it is common for each conceptual 
--     argument to be an element in this list, 
--     but there are operating systems where programs are expected 
--     to tokenize command line strings themselves - on such a system a 
--     Java implementation might require commands to contain exactly 
--     two elements.
--     - an _environment_, which is a system-dependent mapping from 
--     variables to values. The initial value is a copy of the 
--     environment of the current process (see 'System.getenv').
--     - a _working directory_. 
--     The default value is the current working directory of 
--     the current process, usually the directory named by the 
--     system property @user.dir@.
--     - a source of _standard input_. 
--     By default, the subprocess reads input from a pipe. 
--     Frege code can access this pipe via the output stream returned by 
--     'Process.getOutputStream'. 
--     However, standard input may be redirected to another source using 
--     'ProcessBuilder.redirectInput'. In this case, 
--     'Process.getOutputStream' will return an output stream, for which 
--     the @write@ methods always throws 'IOException' 
--     and the @close@ method does nothing.
--     - a destination for _standard output_ and _standard error_. 
--     By default, the subprocess writes standard output and 
--     standard error to pipes. Frege code can access these pipes via the 
--     input streams returned by 'Process.getInputStream' 
--     and 'Process.getErrorStream'. 
--     However, standard output and standard error may be redirected to 
--     other destinations using 'ProcessBuilder.redirectOutput'
--     and 'ProcessBuilder.redirectError'. 
--     In this case, 'Process.getInputStream' and/or 'Process.getErrorStream'
--     will return an input stream, 
--     for which the @read@ methods always return @-1@,
--     the @available@ method always returns @0@
--     and the @close@ method does nothing.
--     - a _redirectErrorStream_ property. 
--     Initially, this property is false, meaning that the standard output 
--     and error output of a subprocess are sent to two separate streams, 
--     which can be accessed using the 'Process.getInputStream' 
--     and 'Process.getErrorStream' methods.
--     If the value is set to true, then standard error is merged 
--     with the standard output and always sent to the same destination 
--     (this makes it easier to correlate error messages with the corresponding output);
--     the common destination of standard error and standard output 
--     can be redirected using 'ProcessBuilder.redirectOutput';
--     and any redirection set by the 'ProcessBuilder.redirectError'
--     method is ignored when creating a subprocess.
--     
--     Modifying a process builder's attributes will affect 
--     processes subsequently started by that object's start() method, 
--     but will never affect previously started processes or the Java process itself.
-- 
--     Most error checking is performed by the start() method. 
--     It is possible to modify the state of an object so that start() will fail. 
--     For example, setting the command attribute to an empty list 
--     will not throw an exception unless start() is invoked.
-- 
--     Note that this type is not synchronized. 
--     If multiple threads access a 'ProcessBuilder' instance concurrently, 
--     and at least one of the threads modifies one of the attributes structurally, 
--     it must be synchronized externally.
--      
data ProcessBuilder

-- |     Represents a source of subprocess input or a destination of subprocess output. 
--     Each 'Redirect' is one of the following:
--     - the special value 'Redirect.pipe'
--     - the special value 'Redirect.inherit'
--     - a redirection to read from a file, created by an invocation of 'Redirect.from'
--     - a redirection to write to a file, created by an invocation of 'Redirect.to'
--     - a redirection to append to a file, created by an invocation of 'Redirect.appendTo'
--      
data Redirect

-- |     Convenience function to get an UTF-8 encoded 'BufferedReader' 
--     that is connected to the standard error of a 'Process'.
--      
stderrReader :: Processes.Process -> IO BufferedReader

-- |     Convenience function to get an UTF-8 encoded 'PrintWriter' 
--     that is connected to the standard input of a 'Process'.
--      
stdinWriter :: Processes.Process -> IO PrintWriter

-- |     Convenience function to get an UTF-8 encoded 'BufferedReader' 
--     that is connected to the standard output of a 'Process'.
--      
stdoutReader :: Processes.Process -> IO BufferedReader



-- |  Java types from package java.lang.reflect   
module frege.java.lang.Reflect

instance Exceptional Reflect.InvocationTargetException


data Field


data InvocationTargetException


instance Reflect.ReflectedClass (Class a)

-- |  This type class is used only to add methods to 'Class'   
class ReflectedClass


getDeclaredField :: Reflect.ReflectedClass c => c -> String -> IO Reflect.Field



-- |     Inner classes of javax.swing.GroupLayout
-- -     
module frege.java.swing.GroupLayout

data Alignment


data Group


data ParallelGroup



-- |  Java classes from package @java.util.concurrent@   
module frege.java.util.Concurrent

data ArrayBlockingQueue


data BlockingQueue


instance Exceptional Concurrent.RejectedExecutionException

-- |  The Java 'http://docs.oracle.com/javase/7/docs/api/java/util/concurrent/ExecutorService.html executor service' interface.   
data ExecutorService

-- |  Thrown when a task is submitted to an 'ExecutorService' that was shut down or whose queue is full.   
data RejectedExecutionException



-- |  Java classes from package @java.util.jar@   
module frege.java.util.Jar
-- |  Attributes of a 'Manifest'   
-- 
--  see 'http://docs.oracle.com/javase/7/docs/api/java/util/jar/Attributes.html java doc'   
data Attributes

-- |  Predefined keys for 'Attributes' maps.   
data AttributesName


instance Cloneable Jar.Manifest


data JarEntry


data JarFile

-- |  The Manifest of a 'JarFile'   
-- 
--  see 'http://docs.oracle.com/javase/7/docs/api/java/util/jar/Manifest.html java doc'   
data Manifest


instance Show Jar.AttributesName



-- |     Support for working with regular expressions.
-- 
--     This exposes @java.util.regex.Pattern@ as 'Regex' and 
--     @java.util.regex.MatchResult@ as 'MatchResult'.
-- 
--     This module must have been imported during compilation or certain
--     language features can not be used (see below).
-- 
--     ## Frege language support
-- 
--     ### Regex literals
-- 
--     Regular expression literals have type 'Regex' and are written:
-- 
--     > ´\b(foo|bar)\b´       -- string enclosed in grave accents
--     > '\w+'                 -- string with length > 1 enclosed in apostrophes
-- 
--     The notation with the apostrophes has been introduced because many
--     have a hard time entering a grave accent mark on their terminal. However,
--     it is not possible to write a regular expressions with length 1 this way,
--     because then the literal gets interpreted as 'Char' literal.
--     (One can write something like @\'(?:X)\'@ for a 'Regex' that matches a single @\'X\'@).
--     
--     The advantage of using literals rather than compiling string constants 
--     to patterns at runtime is 
-- 
--     1) they are checked by the Frege
--     compiler, and illegal ones cause compilation to fail
-- 
--     2) at runtime, literals are available as immutable values of type 
--     @java.util.regex.Pattern@, not as strings, as can be seen so often in 
--     human written Java code. Thus the cost of repeated regex compilation
--     is avoided.
-- 
--     3) The regular expression can be written directly, like in Perl or
--     other languages, without taking String escape rules into account. That is,
--     to match a $ sign, one writes
-- 
--     > ´\$´ 
-- 
--     and not 
-- 
--     > "\\$"
-- 
--     like in Java.
-- 
--     The 'Regex' values created from the literals have the following flags enabled:
--     'Regex.canon_eq', 'Regex.unicode_case' and 'Regex.unicode_character_class'.
--     That is, they do their best - as far as Java supports it - to get processing
--     of Unicode strings right.
-- 
--     ### 'Regex' literals in pattern matching
-- 
--     A 'Regex' literal is a valid pattern, like any literal:
-- 
--     > case expr1 of
--     >   ´\w+´  →  expr2
-- 
--     This is equivalent to:
-- 
--     > case expr1 of
--     >   s | s ~ ´\w+´ →  expr2
-- 
--     where _s_ is some fresh variable that doesn't appear in _expr2_.
-- 
--     The match succeeds if the 'String' value resulting from evaluation of _expr1_
--     matches the regular expression given. The match diverges when _expr1_ diverges.
--     In all other cases, the match fails.
-- 
--     Note that in this simple form, the value of _expr1_ is not available in _expr2_.
--     One can use an "at" pattern for this:
-- 
--     > case expr1 of
--     >    string@'\w+'  →  expr2
-- 
--     which gets desugared to
-- 
--     > case expr1 of
--     >   string | string ~ '\w+'  →  expr2
-- 
--     leaving _string_ bound to the value of _expr1_.
--     
--     The following syntax not only checks if the regular expression matches but
--     also binds the 'MatchResult':
--     
--     > case expr1 of
--     >   m~'\w+'  →  expr2
--     
--     It is equivalent to
--     
--     > case expr1 of
--     >   s | Just m ← s =~ '\w+'  →  expr2
--     
--     where _s_ is again a fresh variable not known in _expr2_, but 
--     when the match succeeds _m_ is bound
--     to the 'MatchResult' and can be inspected further in _expr2_.
--     
--     And finally, a pattern like
--     
--     > s@m~'\w+'
--     
--     works like the previous one but in addition binds _s_ to the string value 
--     in question. 
--      
module frege.java.util.Regex
-- |     > s !~ p == !(s ~ p)
--      
(!~) :: String -> Regex -> Bool

-- |  * > string =~ regex
--  * tries to match _string_ against _regex_ and returns
--  * @Just matcher@ if it succeeds, @Nothing@ otherwise.
--       
(=~) :: String -> Regex -> Maybe MatchResult

-- |     > string =~~ regex
--     tries to match _string_ against _regex_ and returns
--     a list of all captured substrings, see 'MatchResult.groups'.
--     
--     Example:
--     
--     > case "today is 2014-02-18" =~~ ´(\d\d\d\d)-(0[1-9]|1[012])-(\d\d)´ of
--     >    [Just date, Just year, Just month, Just day] -> ...
--     >    baddate -> ....
--       
(=~~) :: String -> Regex -> [Maybe String]


instance Exceptional PatternSyntaxException

-- |     This interface contains query methods used to determine the results 
--     of a match against a regular expression.
-- 
--     More: 'https://docs.oracle.com/javase/7/docs/api/java/util/regex/MatchResult.html JavaDoc'
--      
data MatchResult

-- |  Will be thrown when one compiles a 'String' to a 'Regex' using 'regcomp' or 'regforce'   
data PatternSyntaxException

-- |     'Regex' values are based on Java's @java.util.regex.Pattern@ objects,
--     which are compiled representations of regular expressions.
--     
--     We call them 'Regex' and not @Pattern@ in Frege, because the 
--     word "pattern" and the phrase "pattern matching" have a quite
--     different meaning in deconstruction of algebraic data types. 
--     
--     There are 2 ways to obtain a compiled regular expression:
--     1. Use a 'Regex' literal, see the language reference section 2.7.3.
--        All regular expression literals are values of type 'Regex'. 
--        It is not possible to run a program which contains a syntactically
--        invalid 'Regex' literal - 
--        the compiler will flag it already at compile time.
--        Hence, with 'Regex' literals one is immune against 'PatternSyntaxException's.
--     2. Compile a String with 'regcomp' or 'regforce' at run-time.
--        Illegal regular expression will cause 'PatternSyntaxException'
--        to be thrown, which, when not handled appropriately, may crash
--        the program.
--     
--     'Regex' values are immutable.  
--       
data Regex

-- |  this is only used to inject the replace functions into 'String'   
class Replace


instance Replace String

-- |     > findAt string regex offset
--     
--     Like '=~', but matches only the substring of _string_ that starts at _offset_
--     against _regex_.
--     
--     If _offset_ is  negative or not smaller than the length of _string_, the 
--     result is _Nothing_
--      
findAt :: String -> Regex -> Int -> Maybe MatchResult

-- |  compile a 'String' to a 'Regex'   
-- 
--  Returns 'either' a  'PatternSyntaxException' in 'Left' or a 'Regex' in 'Right'.   
-- 
--  
--         The overloaded form has an additional 'Int' argument which is a set of flags.
--         Such a set can be constructed by adding up the individual flag values, for example:
-- 
--         >  Regex.compile "foo|bar" (Regex.canon_eq + Regex.case_insensitive)
-- 
--          
regcomp :: ω

-- |     compile a 'String' to a 'Regex'
--     
--     This will throw 'PatternSyntaxException' when the regular expression is illegal. 
-- 
--     Use this only if you're sure that pattern compilation will not throw
--     an exception, or if you don't care.
--      
regforce :: ω

-- |     compile a 'String' to a 'Regex'
--     
--     This will throw 'PatternSyntaxException' when the regular expression is illegal. 
-- 
--     Use this only if you're sure that pattern compilation will not throw
--     an exception, or if you don't care.
--      
regforcea :: String -> Regex

-- |     compile a 'String' to a 'Regex'
--     
--     This will throw 'PatternSyntaxException' when the regular expression is illegal. 
-- 
--     Use this only if you're sure that pattern compilation will not throw
--     an exception, or if you don't care.
--      
regforceb :: String -> Int -> Regex

-- |         Like 'replaceFirst', but replaces *all* substrings that match the pattern.
--          
replaceAll :: Replace s => s -> Regex -> s -> s

-- |         Replaces the first subsequence of the input sequence that matches
--         the pattern with the given replacement string.
--  
--         This method scans the input sequence from the start
--         looking for a match of the pattern.
--         Characters that are not part of the match are appended directly
--         to the result string; the match is replaced in the result by the
--         replacement string. The replacement string may contain references
--         to captured subsequences.
--  
--         Note that backslashes (\\) and dollar signs ($) in the replacement
--         string may cause the results to be different than if it were
--         being treated as a literal replacement string.
--         Dollar signs may be treated as references to captured subsequences
--         as described above, and backslashes are used to escape
--         literal characters in the replacement string.
--  
--         For example
--         
--         > replaceFirst "zzzdogzzzdogzzz" ´dog´ "cat" == "zzzcatzzzdogzzz"
--          
replaceFirst :: Replace s => s -> Regex -> s -> s

-- |         Like 'String.replaceFirst', but replaces *all* substrings that match the pattern.
--          
substituteAll :: String -> Regex -> String -> String

-- |         Replaces the first subsequence of the input sequence that matches
--         the pattern with the given replacement string.
--  
--         This method scans the input sequence from the start
--         looking for a match of the pattern.
--         Characters that are not part of the match are appended directly
--         to the result string; the match is replaced in the result by the
--         replacement string. The replacement string may contain references
--         to captured subsequences.
--  
--         Note that backslashes (\\) and dollar signs ($) in the replacement
--         string may cause the results to be different than if it were
--         being treated as a literal replacement string.
--         Dollar signs may be treated as references to captured subsequences
--         as described above, and backslashes are used to escape
--         literal characters in the replacement string.
--  
--         For example
--         
--         > "zzzdogzzzdogzzz".replaceFirst  ´dog´ "cat" == "zzzcatzzzdogzzz"
--          
substituteFirst :: String -> Regex -> String -> String

-- |  * >string ~ regex
--  * @true@ if _string_ matches _regex_, @false@ otherwise
--       
(~) :: String -> Regex -> Bool

-- |     > ("string" ~~ ´r..´) == Just "rin"
--     Tries a match and returns @Just x@ where
--     _x_ is the matched substring or @Nothing@ if there was no match.
--      
(~~) :: String -> Regex -> Maybe String

-- |     > "cats and dogs are not concatenated." ~~* ´cat|dog´
--     Matches the string with the regex and returns a list of all matches.
--     The example gives:
--     > ["cat", "dog", "cat"]
--      
(~~*) :: String -> Regex -> [String]

-- |  * > string ~~~ regex
--  * Matches _string_ with _regex_ and returns a function
--  * that can be used to extract the matched part of the string and the
--  * captured substrings.
--  * >   let f = "frege" ~~~ ´(..).(..)´
--  * >   in [ f i | i <- 0..3 ]
--  * yields
--  * >[Just "frege", Just "fr", Just "ge", Nothing]
--      
(~~~) :: String -> Regex -> Int -> Maybe String



-- |  Java classes from package @java.util.zip@   
module frege.java.util.Zip

instance Exceptional Zip.ZipException


data ZipEntry


data ZipException


data ZipFile



-- |  * Support for ad hoc parallelism in Frege through java's ForkJoin mechanism
--       
module frege.lib.ForkJoin
-- |  * [usage] @f $| a@
--  *
--  * Equivalent to @a `par` f a@
--       
($|) :: (a->b) -> a -> b

-- |  * [usage] @a :| as@
-- 
--  * Equivalent to @parOp (:) a as@
--       
(:|) :: a -> [a] -> [a]

-- |     [usage] @mapP f xs@
-- 
--     Like 'map', but applies the function parallel to mapping the rest of the list.
--     It does therefore not work with infinite lists.
--      
mapP :: (b->a) -> [b] -> [a]

-- |  * [usage] @a `par` b@
-- 
--  * Fork evaluation of @a@ and return @b@.
-- 
--       
par :: a -> b -> b

-- |  * [usage] @parOp f a b@
-- 
--  * Equivalent to @a `par` b `par` f a b@
--       
parOp :: (c->b->a) -> c -> b -> a



-- |  Find frege modules    
module frege.lib.Modules

instance Functor Modules.RTree


R :: String -> Modules.RTree a


data RTree


T :: TreeMap.TreeMap String a -> Modules.RTree a


data Y


Y :: f (Modules.Y f) -> Modules.Y f


classAtEnd :: Regex

-- |  the class path this JVM started with, as ['String']   
classPath :: [String]


dirSep :: Regex

-- |     Walk a directory and find Frege modules.
--     
--     The classes in the directory must be loadable with the given
--     'ClassLoader'
--     
--     Ignores 'ClassNotFoundException's and the strange 'Error's
--     that can happen during class loading.  
--          
dirWalk :: ClassLoader -> String -> MutableIO File -> IO [(String,Classtools.FregePackage)]


dollars :: Regex


flat :: Modules.Y Modules.RTree -> [(String,Modules.Y Modules.RTree)]

-- |  load a package and return maybe a tuple of package name and 'FregePackage'   
getX :: ClassLoader -> String -> IO (Maybe (String,Classtools.FregePackage))


main :: [String] -> IO ()


nf :: Modules.Y Modules.RTree -> Modules.Y Modules.RTree


noPacks :: Modules.Y Modules.RTree


out :: Modules.Y a -> a (Modules.Y a)


pack :: Modules.Y Modules.RTree -> ([String],Classtools.FregePackage) -> Modules.Y Modules.RTree

-- |  a pattern that can be used to 'Regex.split' a 'String' by the path separator   
pathRE :: Regex

-- |  the path separator used here   
pathSep :: String


pfind :: [String] -> Modules.Y Modules.RTree -> Maybe (Modules.Y Modules.RTree)


unR :: Modules.Y Modules.RTree -> Maybe String

-- |  walk the class path   
walkCP :: IO [(String,Classtools.FregePackage)]

-- |  walk a given path   
walkPath :: String -> IO [(String,Classtools.FregePackage)]

-- |  Walk a directory or a zip file and search for Frege packages.   
-- 
--  If the argument is neither a directory nor a ZIP/JAR file, an empty list is returned.   
walkThing :: String -> IO [(String,Classtools.FregePackage)]

-- |     Walk a 'ZipFile' and find Frege modules.
--     
--     The classes inside the ZIP/JAR must be loadable with the given
--     'ClassLoader'
--     
--     Ignores 'ClassNotFoundException's and the strange 'Error's
--     that can happen during class loading.
--          
zipWalk :: ClassLoader -> Zip.ZipFile -> IO [(String,Classtools.FregePackage)]



-- |     Courtesy of Philip Wadler.
-- 
--     This is a port of Prof. Philip Wadlers pretty printer library to Frege.
--     For more info see "http://homepages.inf.ed.ac.uk/wadler/papers/prettier/prettier.pdf"
-- 
--       
module frege.lib.PP
-- |  join two documents with intervening space or stack them   
(<+/>) :: PP.DOCUMENT -> PP.DOCUMENT -> PP.DOCUMENT

-- |  two documents with intervening space   
(<+>) :: PP.DOCUMENT -> PP.DOCUMENT -> PP.DOCUMENT

-- |  two documents stacked   
(</>) :: PP.DOCUMENT -> PP.DOCUMENT -> PP.DOCUMENT


(<>) :: PP.DOCUMENT -> PP.DOCUMENT -> PP.DOCUMENT

-- |  join two documents without intervening space or stack them   
(<~/>) :: PP.DOCUMENT -> PP.DOCUMENT -> PP.DOCUMENT


APPEND :: PP.DOCUMENT -> PP.DOCUMENT -> PP.DOCUMENT


data DOCUMENT


data Doc


GROUP :: PP.DOCUMENT -> PP.DOCUMENT -> PP.DOCUMENT


LINE :: PP.DOCUMENT


Line :: Int -> PP.Doc -> PP.Doc


NEST :: Int -> PP.DOCUMENT -> PP.DOCUMENT


NONE :: PP.DOCUMENT


None :: PP.Doc


TEXT :: String -> PP.DOCUMENT


Text :: String -> PP.Doc -> PP.Doc


appendableFromWriter :: Writer -> STMutable RealWorld Appendable


be :: Int -> Int -> [(Int,PP.DOCUMENT)] -> PP.Doc


best :: Int -> Int -> PP.DOCUMENT -> PP.Doc


better :: Int -> Int -> PP.Doc -> Maybe PP.Doc


blanks64 :: String


block :: String -> PP.DOCUMENT -> String -> PP.DOCUMENT


bracket :: String -> PP.DOCUMENT -> String -> PP.DOCUMENT

-- |  fill words of a string   
break :: String -> [PP.DOCUMENT]


fill :: [PP.DOCUMENT] -> PP.DOCUMENT


fits :: Int -> PP.Doc -> Bool


flatten :: PP.DOCUMENT -> PP.DOCUMENT


folddoc :: (PP.DOCUMENT->PP.DOCUMENT->PP.DOCUMENT) -> [PP.DOCUMENT] -> PP.DOCUMENT


group :: PP.DOCUMENT -> PP.DOCUMENT


layout :: PP.Doc -> ST a String


layout' :: PP.Doc -> String


line :: PP.DOCUMENT

-- |  Singleton with element from 'Just' or empty list for 'Nothing'    
listFromMaybe :: Maybe a -> [a]

-- |  turn a string into a document by breaking on space and filling up   
msgdoc :: String -> PP.DOCUMENT


nest :: Int -> PP.DOCUMENT -> PP.DOCUMENT


nil :: PP.DOCUMENT


pretty :: Int -> PP.DOCUMENT -> String


prettyIO :: Writer -> Int -> PP.DOCUMENT -> IO ()

-- |  like 'fill', but with separator between items      
sep :: String -> [PP.DOCUMENT] -> PP.DOCUMENT

-- |  some documents with space inbetween   
spread :: [PP.DOCUMENT] -> PP.DOCUMENT

-- |  some documents stacked   
stack :: [PP.DOCUMENT] -> PP.DOCUMENT


text :: String -> PP.DOCUMENT

-- |  like 'sep', but no space after separator      
tight :: String -> [PP.DOCUMENT] -> PP.DOCUMENT



-- |     Math functions from 
--     'http://docs.oracle.com/javase/7/docs/api/java/lang/Math.html java.lang.Math'.
--     Many of those functions are overloaded for 'Float' and 'Double', so we 
--     introduce a type class 'Floating' to avoid overloading issues.
-- 
--     For example
--     > f x = 2 * sqrt x
--     would give a type error, because the compiler wouldn't know whether to use 
--     > sqrt :: Float  -> Double
--     or
--     > sqrt :: Double -> Double
-- 
--     Note that many functions return 'Double', no matter if the argument was 'Double' or
--     'Float'.
--      
module frege.prelude.Math
-- |  Returns the value of the first argument raised to the power of the second argument.   
(**) :: Math.Floating r => r -> r -> Double


class Floating


instance Math.Floating Double


instance Math.Floating Float

-- |  Returns the arc cosine of a value; the returned angle is in the range 0.0 through 'pi'.   
acos :: Math.Floating r => r -> Double

-- |  Inverse hyperbolic function for 'cosh'   
acosh :: Math.Floating r => r -> Double

-- |  Returns the arc sine of a value; the returned angle is in the range -'pi'/2 through 'pi'/2.   
asin :: Math.Floating r => r -> Double

-- |  Inverse hyperbolic function for 'sinh'   
asinh :: Math.Floating r => r -> Double

-- |  Returns the arc tangent of a value; the returned angle is in the range -'pi'/2 through 'pi'/2.   
atan :: Math.Floating r => r -> Double

-- |  Returns the angle theta from the conversion of rectangular coordinates (x, y) to polar coordinates (r, theta).   
atan2 :: Math.Floating r => r -> r -> Double

-- |  Inverse hyperbolic function for 'tanh'   
atanh :: Math.Floating r => r -> Double

-- |  Returns the cube root of a value.   
cbrt :: Math.Floating r => r -> Double

-- |  Returns the smallest (closest to negative infinity) value that is greater than or equal to the argument and is equal to a mathematical integer.   
ceil :: Math.Floating r => r -> Double

-- |  Returns the first argument with the sign of the second argument.   
copySign :: Math.Floating r => r -> r -> r

-- |  Returns the trigonometric cosine of an angle.   
cos :: Math.Floating r => r -> Double

-- |  Returns the hyperbolic cosine of a floating point value.   
cosh :: Math.Floating r => r -> Double

-- |  The value that is closer than any other to @e@, the base of the natural logarithms.   
e :: Math.Floating r => r

-- |  Returns Euler's number 'e' raised to the power of a floating-point value.    
exp :: Math.Floating r => r -> Double

-- |  Returns @e^x -1@.   
expm1 :: Math.Floating r => r -> Double

-- |       Returns the largest (closest to positive infinity) value that is
--       less than or equal to the argument and is equal to a mathematical integer.
--     
--       Special cases:
--     
--         - If the argument value is already equal to a mathematical integer,
--         then the result is the same as the argument.
--         - If the argument is NaN or an infinity or positive zero or
--         negative zero, then the result is the same as the argument.
-- 
--          
floor :: Math.Floating r => r -> Double

-- |  Returns the unbiased exponent used in the representation of a floating point number.   
getExponent :: Math.Floating r => r -> Int

-- |  Returns 'sqrt' @(x² + y²)@ without intermediate overflow or underflow.   
hypot :: Math.Floating r => r -> r -> Double

-- |  Computes the remainder operation on two arguments as prescribed by the IEEE 754 standard.   
ieeeRemainder :: Math.Floating r => r -> r -> Double

-- |  Returns the natural logarithm (base 'e') of a value.   
log :: Math.Floating r => r -> Double

-- |  Returns the base 10 logarithm of a value.   
log10 :: Math.Floating r => r -> Double

-- |  Returns the natural logarithm of the sum of the argument and 1.   
log1p :: Math.Floating r => r -> Double

-- |  Returns the logarithm of the second argument to the base given by the first argument.    
logBase :: Math.Floating r => r -> r -> Double

-- |  Returns the floating-point number adjacent to the first argument in the direction of the second argument.   
nextAfter :: Math.Floating r => r -> r -> Double

-- |  Returns the floating-point value adjacent to the argument in the direction of positive infinity.   
nextUp :: Math.Floating r => r -> r

-- |  The value that is closer than any other to @pi@, the ratio of the circumference of a circle to its diameter.   
pi :: Math.Floating r => r

-- |  Returns the value of the first argument raised to the power of the second argument.   
pow :: Math.Floating r => r -> r -> Double

-- |  Returns a 'Double' with a positive sign, greater than or equal to 0.0 and less than 1.0.   
random :: () -> IO Double

-- |  Returns the double value that is closest in value to the argument and is equal to a mathematical integer.   
rint :: Math.Floating r => r -> Double

-- |  Returns the closest 'Long' to the argument, with ties rounding up.   
round :: Math.Floating r => r -> Long

-- |  > scalb d scaleFactor   
-- 
--  Return @d * 2^scaleFactor@ rounded as if performed by a single correctly rounded floating-point multiply.   
scalb :: Math.Floating r => r -> Int -> r

-- |  Returns the signum function of the argument; zero if the argument is zero, 1.0 if the argument is greater than zero, -1.0 if the argument is less than zero.   
signum :: Math.Floating r => r -> r

-- |  Returns the trigonometric sine of an angle.   
sin :: Math.Floating r => r -> Double

-- |  Returns the hyperbolic sine of a value.   
sinh :: Math.Floating r => r -> Double

-- |  square   
sqr :: Num a => a -> a

-- |  Returns the correctly rounded positive square root of a value.   
sqrt :: Math.Floating r => r -> Double

-- |  Returns the trigonometric tangent of an angle.   
tan :: Math.Floating r => r -> Double

-- |  Returns the hyperbolic tangent of a floating point value.   
tanh :: Math.Floating r => r -> Double

-- |  Converts an angle measured in radians to an approximately equivalent angle measured in degrees.   
toDegrees :: Math.Floating r => r -> Double

-- |  Converts an angle measured in degrees to an approximately equivalent angle measured in radians.   
toRadians :: Math.Floating r => r -> Double

-- |  Returns the size of an ulp of the argument.   
ulp :: Math.Floating r => r -> r



-- |     Provides functions and instances for the 'Maybe' type.
-- 
--     Compatible with the Haskell 2010 _Data.Maybe_ module.
-- 
--      
module frege.prelude.Maybe

instance Applicative Maybe


instance Eq a => Eq (Maybe a)


instance Functor Maybe


instance ListEmpty Maybe


instance Monad Maybe


instance MonadFail Maybe


instance MonadPlus Maybe


instance Ord a => Ord (Maybe a)

-- |  The 'catMaybes' function takes a list of 'Maybe's and returns a list of all the 'Just' values.   
catMaybes :: ListSource b => b (Maybe a) -> [a]

-- |  @fromMaybe d (Just a)@ returns @a@ and @fromMaybe d Nothing@ returns @d@   
fromMaybe :: a -> Maybe a -> a

-- |  @true@ if and only if the argument is a 'Just' value   
isJust :: Maybe a -> Bool

-- |  @true@ if and only if the argument is 'Nothing'   
-- 
--  This function is preferable over @v == Nothing@ because no 'Eq' constraint is needed.   
isNothing :: Maybe a -> Bool

-- |  give the first element of a list or 'Nothing'   
listToMaybe :: ListSource a => a b -> Maybe b

-- |     The 'mapMaybe' function is a version of 'map' which can throw out elements. 
--     In particular, the functional argument returns something of type 'Maybe' _b_. 
--     If this is 'Nothing', no element is added on to the result list. 
--     If it just 'Just' _b_, then _b_ is included in the result list.
--          
mapMaybe :: (b->Maybe a) -> [b] -> [a]

-- |  convert a 'Maybe' to a single element list or an empty list   
maybeToList :: Maybe a -> [a]

-- |  @unJust Nothing@ is 'undefined' whereas @unJust (Just a)@ is @a@   
unJust :: Maybe a -> a



-- |     Support for Java reflective arrays.
-- 
--      
module frege.prelude.PreludeArrays
-- |     Type class for basic 'JArray' operations. The *element type*
--     must be an instance of this class to support arrays of that type.
--     
--     'ArrayElem' is not derivable, derive sub-class 'ArrayElement' instead.
--     
--     The operations are mostly overloaded on return type and provide the 
--     appropriate @java.lang.Class@ object when needed. 
--     
--     This supports one dimensional arrays, though more dimensions would
--     be possible with some extra effort.
--     
--     Note that 'JArray' cannot be an instance of 'ArrayElem' itself,
--     because it has no fixed @java.lang.Class@ instance.
--      
class ArrayElem

-- |  'ArrayElement' is the class one derives for array elements.   
-- 
--  In addition to the base class 'ArrayElem' it also supports mutable array elements.   
class ArrayElement


instance ArrayElement (a,b)


instance ArrayElement (a,b,c)


instance ArrayElement (a->b)


instance ArrayElement Integer


instance ArrayElement String


instance ArrayElement [a]

-- |  short hand for 'Mutable' @s@ ('JArray' @a@)   
type ArrayOf = Mutable s (JArray a)


instance Eq a => Eq (JArray a)

-- |     The type @JArray X@ corresponds to Java's @J[]@ for any type @X@
--     where @J@ is the corresponding java type of @X@,
--     but note that Java does not really have generic arrays.
--     
--     We can use arrays generically inside Frege, but native code 
--     that expects or returns arrays will not be generic.  
--     
--     The native interface will take every occurrence of
--     
--     > JArray X
--     
--     or
--     
--     > Mutable s (JArray X)
--     
--     in native declarations to denote the corresponding Java array type.
--     But when the type argument is variable, it will be just @Object@.
--     This corresponds to the usage in 
--     'http://docs.oracle.com/javase/7/docs/api/index.html?java/lang/reflect/Array.html the array reflection API'.
-- 
--     Multi-dimensional arrays are not very well supported out of the box.
--     If one needs more than 1 dimensions, the type will get quite complex,
--     as of course arrays are mutable and so one will have multiple levels
--     of 'JArray' nested in 'Mutable' nested in 'JArray' and so forth.
--     Moreover, multi-dimensional arrays cannot be generic at all.
--     
--     Note that there are really 2 different APIs: 
--     
--     1. With the 'JArray.getElemAt', 'JArray.getAt', 'JArray.setAt', 'JArray.setElemAt',
--     'JArray.itemAt' and 'JArray.elemAt' it is possible to work on Java objects with
--     java compile time type @java.lang.Object@ *or* @X[]@ for some java type @X@
--     *or* @java.lang.Object[]@, 
--     but the run time type is always @java.lang.Object[]@. 
--     2. With the 'newArray', 'getElemAt', 'getAt', 'setAt', 
--     'setElemAt', 'itemAt' and 'elemAt' functions of the 'ArrayElem' class
--     for some type @F@ that is an instance of 'ArrayElem', 
--     we can work on Java objects with
--     Java compile time type @X[]@, 
--     where @X@ is the Java type corresponding to @F@,    
--     but the run time type is always @X[]@.    
--     
--     The former ones are usable only in polymorphic functions where the type argument 
--     for 'JArray' is a variable and we don't (want to) have 'ArrayElem' constraints. 
--     They are not good for interfacing native methods that take or return arrays of a certain type.
--     Run time type errors are possible because native methods could put anything there.
--     However, when used in Frege only, the typing is safe.
--     
--     The latter ones are truly type safe, because their Frege type corresponds to the
--     expected Java compile time type, which is also the actual run time type.  
--     
--     Here is a cheat sheet for the different array get and set methods:
--     
--     >             Array type            Argument/    Description
--     >                                   Result
--      
--     > setAt       Mutable (JArray s X)  Maybe X     set null or data element
--     > setElemAt   Mutable (JArray s X)  X           set data element
--     > getAt       Mutable (JArray s X)  Maybe X     get null or data element
--     > getElemAt   Mutable (JArray s X)  X           get data element (unsafe)
--     > itemAt      JArray s X            Maybe X     get null or data element (pure)
--     > elemAt      JArray s X            X           get data element (pure, unsafe)
--     
--     "unsafe" in this context applies only to non-primitive types
--     and means that the function will fail with a @NullPointerException@
--     if the value accessed is a Java @null@.
-- 
--      
data JArray


instance JavaType (JArray Int)


instance ListSource JArray

-- |     Type class for array elements of primitive type.
--     
--     Not thought for public use, as all instances are pre-defined.
--     
--     The default implementation of 'PrimitiveArrayElement.setAt'
--     does not support passing 'Nothing', because there can be no
--     @null@ in primitive arrays.
--      
class PrimitiveArrayElement


instance PrimitiveArrayElement Bool


instance PrimitiveArrayElement Char


instance PrimitiveArrayElement Double


instance PrimitiveArrayElement Float


instance PrimitiveArrayElement Int


instance PrimitiveArrayElement Long

-- |     Memoize a number of results from a function that maps
--     'Int' to the array element.
--     
--     Uses 'JArray.cache' and makes it immutable
--          
arrayCache :: ArrayElem a => (Int->JArray a->a) -> Int -> JArray a

-- |     Left fold an immutable array
--      
arrayFold :: (α -> β -> α) -> α -> JArray β -> α

-- |  Create an immutable array from a finite index/value list.   
-- 
--  Uses 'JArray.fromIndexList' and freezes the resulting array.       
arrayFromIndexList :: ArrayElem α => [(Int,α)] -> JArray α

-- |  Create an immutable array from a finite list whose elements are 'ArrayElem`   
-- 
--  Uses 'JArray.fromList' and freezes the resulting array.   
arrayFromList :: ArrayElem α => [α] -> JArray α

-- |  Create an immutable array from a finite list whose elements are 'Maybe' values.   
-- 
--  Uses 'JArray.fromMaybeList' and freezes the resulting array.   
-- 
--  Note that    
-- 
--  > arrayFromList . toList   
-- 
--  does not guarantee reconstruction of the original array, because @null@s get lost, whereas   
-- 
--  > arrayFromMaybeList . toMaybeList   
-- 
--  does.   
arrayFromMaybeList :: ArrayElem a => [Maybe a] -> JArray a

-- |     Map a function over the elements of an immutable array,
--     and collect the results in another immutable array.
-- 
--     Uses 'JArray.map' and makes result read-only. 
--      
arrayMap :: (ArrayElem α,ArrayElem β) => (α -> β) -> JArray α -> JArray β

-- |  Get non-null element at index from immutable array, see 'JArray.elemAt'   
elemAt :: ArrayElem a => JArray a -> Int -> a

-- |  Create an immutable generic array from a finite index/value list.   
-- 
--  Uses 'JArray.genericFromIndexList' and freezes the resulting array.   
genericArrayFromIndexList :: JavaType α => [(Int,α)] -> JArray α

-- |  Get item at index from mutable array, see 'JArray.getAt'   
getAt :: ArrayElem a => ArrayOf s a -> Int -> ST s (Maybe a)

-- |  Get non null item at index from mutable array, see 'JArray.getElemAt'   
getElemAt :: ArrayElem a => ArrayOf s a -> Int -> ST s a

-- |  Get item at index from immutable array, see 'JArray.itemAt'   
itemAt :: ArrayElem a => JArray a -> Int -> Maybe a

-- |  Modify item at index in mutable array with result of function application.   
modifyAt :: ArrayElem a => (a -> a) -> ArrayOf s a -> Int -> ST s ()

-- |  Modify non null item at index in mutable array with result of function application.   
modifyElemAt :: ArrayElem a => (a -> a) -> ArrayOf s a -> Int -> ST s ()

-- |  Create a one dimensional array with elements of the instantiated type.   
newArray :: ArrayElem a => Int -> STMutable s (JArray a)

-- |  Create an array of mutable items.    
-- 
--  Such an array may never be immutable itself.    
newArrayM :: ArrayElement a => Int -> STMutable s (JArray (Mutable s a))

-- |  Set item or null at index in mutable array, see 'JArray.setAt'   
setAt :: ArrayElem a => ArrayOf s a -> Int -> Maybe a -> ST s ()

-- |  Set item at index in mutable array. see 'JArray.setElemAt'   
setElemAt :: ArrayElem a => ArrayOf s a -> Int -> a -> ST s ()

-- |  Unload an immutable array to a list.   
-- 
--  The non-null elements become 'Just' values, the @null@s translate to 'Nothing'   
toMaybeList :: JArray α -> [Maybe α]



-- |     Copyright © 2011 - 2015, Ingo Wechsung
--  
--     All rights reserved.
--  
--     Redistribution and use in source and binary forms, with or
--     without modification, are permitted provided that the following
--     conditions are met:
-- 
--     -   Redistributions of source code must retain the above copyright
--         notice, this list of conditions and the following disclaimer.
-- 
--     -   Redistributions in binary form must reproduce the above
--         copyright notice, this list of conditions and the following
--         disclaimer in the documentation and/or other materials provided
--         with the distribution. 
--         
--     -   Neither the name of the copyright holder
--         nor the names of its contributors may be used to endorse or
--         promote products derived from this software without specific
--         prior written permission.
--  
--     *THIS SOFTWARE IS PROVIDED BY THE
--     COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS" AND ANY EXPRESS OR
--     IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
--     WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
--     PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER
--     OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
--     SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
--     LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF
--     USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED
--     AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT
--     LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING
--     IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF
--     THE POSSIBILITY OF SUCH DAMAGE.*
--      
-- 
--  *
--  * This package provides basic definitions for the Frege language.
--  *
--  * The _Prelude_ packages are imported explicitly or implicitly during compilation
--  * of any other package.
--  * They define basic data structures, classes and functions.
--  *
--  * The types and constructors for lists, unit type and tuple types are not
--  * defined here: They are provided programmatically by the compiler when it
--  * compiles a package with the name @frege.prelude.PreludeBase@. Nevertheless, they are
--  * considered part of the _Prelude_, thus qualified names like '(,)'
--  * are okay.
--  *
--  * The packages are _implementation specific_ insofar as the compiler may
--  * assume that certain items are defined here in a certain way.
--  * Changes may thus lead
--  * to compiler crashes or java code that will be rejected by the java compiler.
--       
module frege.prelude.PreludeBase
-- |  The Java @!@ operator on booleans   
(!) :: Bool -> Bool

-- |  A head strict variant of (:)   
-- 
--  This will be used in list comprehensions   
(!:) :: a -> [a] -> [a]

-- |  Check for inequality. The default implementation obeys the laws   
-- 
--  > !(a != a)   
-- 
--  > (a != b) == !(a == b)   
-- 
--  > (a == b) != (a != b)   
-- 
--  These laws shall also be obeyed in all implementations.   
(!=) :: Eq eq => eq -> eq -> Bool

-- |  This checks for object identity or inequality of primitive values
--     using Java's @!=@ operator.
--     It evaluates its arguments, so undefined values cannot be compared.      
(!==) :: a -> a -> Bool

-- |     @a $ b@ is the same as @a b@, but because of '$''s low precedence
--     one can write @f $ x+y@ instead of @f (x+y)@. Also, because '$' is right
--     associative, @f $ g $ h y@ is @f (g (h y))@
--      
($) :: (b->a) -> b -> a

-- |  Same as `$` but argument is strict   
($!) :: (b->a) -> b -> a

-- |  The Java @&&@ operator on booleans. Note that since this is a
--     native function, the second argument appears strict to the compiler
--     when in fact it is lazy at the Java level.
--     This can lead to inconsistent results in some cases. For example, the following
--     program correctly prints @false@ in the first line of the output, but then aborts:
--     > main _ = do
--     >    stdout << (false && undefined) << "\n"
--     >    stdout << conj false undefined << "\n"
--     >  where
--     >    conj a b = a && b
-- 
--     Note that the very same behaviour is seen in the following java program
-- 
--     > public class And {
--     >    static boolean undef() {
--     >        if (true) throw new Error("undefined");
--     >        return false;
--     >    }
--     >    static boolean conj(boolean a, boolean b) { return a&&b; }
--     >    public static void main(String[] args) {
--     >        System.out.println(false && undef());
--     >        System.out.println(conj(false, undef()));
--     >    }
--     > }
-- 
--     One could thus say that '&&' behaves exactly like the Java operator including
--     the fact that it cannot be replaced by a function without changing the semantics
--     of a program.
-- 
--     For an alternative see 'und'
--          
(&&) :: Bool -> Bool -> Bool

-- | Unit type
data (())

-- | Unit value
(()) :: ()

-- | 2-tuple
data ((,))

-- | 2-tuple constructor
((,)) :: a -> b -> (a,b)

-- | 3-tuple
data ((,,))

-- | 3-tuple constructor
((,,)) :: a -> b -> c -> (a,b,c)

-- | 4-tuple
data ((,,,))

-- | 4-tuple constructor
((,,,)) :: a -> b -> c -> d -> (a,b,c,d)

-- | 5-tuple
data ((,,,,))

-- | 5-tuple constructor
((,,,,)) :: a -> b -> c -> d -> e -> (a,b,c,d,e)

-- | 6-tuple
data ((,,,,,))

-- | 6-tuple constructor
((,,,,,)) :: a -> b -> c -> d -> e -> f -> (a,b,c,d,e,f)

-- | 7-tuple
data ((,,,,,,))

-- | 7-tuple constructor
((,,,,,,)) :: a -> b -> c -> d -> e -> f -> g -> (a,b,c,d,e,f,g)

-- | 8-tuple
data ((,,,,,,,))

-- | 8-tuple constructor
((,,,,,,,)) :: a -> b -> c -> d -> e -> f -> g -> h -> (a,b,c,d,e,f,g,h)

-- | 9-tuple
data ((,,,,,,,,))

-- | 9-tuple constructor
((,,,,,,,,)) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> (a,b,c,d,e,f,g,h,i)

-- | 10-tuple
data ((,,,,,,,,,))

-- | 10-tuple constructor
((,,,,,,,,,)) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> (a,b,c,d,e,f,g,h,i,j)

-- | 11-tuple
data ((,,,,,,,,,,))

-- | 11-tuple constructor
((,,,,,,,,,,)) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> (a,b,c,d,e,f,g,h,i,j,k)

-- | 12-tuple
data ((,,,,,,,,,,,))

-- | 12-tuple constructor
((,,,,,,,,,,,)) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> (a,b,c,d,e,f,g,h,i,j,k,l)

-- | 13-tuple
data ((,,,,,,,,,,,,))

-- | 13-tuple constructor
((,,,,,,,,,,,,)) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> (a,b,c,d,e,f,g,h,i,j,k,l,m)

-- | 14-tuple
data ((,,,,,,,,,,,,,))

-- | 14-tuple constructor
((,,,,,,,,,,,,,)) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n)

-- | 15-tuple
data ((,,,,,,,,,,,,,,))

-- | 15-tuple constructor
((,,,,,,,,,,,,,,)) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)

-- | 16-tuple
data ((,,,,,,,,,,,,,,,))

-- | 16-tuple constructor
((,,,,,,,,,,,,,,,)) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)

-- | 17-tuple
data ((,,,,,,,,,,,,,,,,))

-- | 17-tuple constructor
((,,,,,,,,,,,,,,,,)) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)

-- | 18-tuple
data ((,,,,,,,,,,,,,,,,,))

-- | 18-tuple constructor
((,,,,,,,,,,,,,,,,,)) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r)

-- | 19-tuple
data ((,,,,,,,,,,,,,,,,,,))

-- | 19-tuple constructor
((,,,,,,,,,,,,,,,,,,)) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s)

-- | 20-tuple
data ((,,,,,,,,,,,,,,,,,,,))

-- | 20-tuple constructor
((,,,,,,,,,,,,,,,,,,,)) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t)

-- | 21-tuple
data ((,,,,,,,,,,,,,,,,,,,,))

-- | 21-tuple constructor
((,,,,,,,,,,,,,,,,,,,,)) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u)

-- | 22-tuple
data ((,,,,,,,,,,,,,,,,,,,,,))

-- | 22-tuple constructor
((,,,,,,,,,,,,,,,,,,,,,)) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v)

-- | 23-tuple
data ((,,,,,,,,,,,,,,,,,,,,,,))

-- | 23-tuple constructor
((,,,,,,,,,,,,,,,,,,,,,,)) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w)

-- | 24-tuple
data ((,,,,,,,,,,,,,,,,,,,,,,,))

-- | 24-tuple constructor
((,,,,,,,,,,,,,,,,,,,,,,,)) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x)

-- | 25-tuple
data ((,,,,,,,,,,,,,,,,,,,,,,,,))

-- | 25-tuple constructor
((,,,,,,,,,,,,,,,,,,,,,,,,)) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y)

-- | 26-tuple
data ((,,,,,,,,,,,,,,,,,,,,,,,,,))

-- | 26-tuple constructor
((,,,,,,,,,,,,,,,,,,,,,,,,,)) :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z)

-- |  Computes the product of two numbers   
(*) :: Num n => n -> n -> n

-- |  Computes the sum of two numbers   
(+) :: Num n => n -> n -> n

-- |  Computes the difference of two numbers   
(-) :: Num n => n -> n -> n

-- | function
data (->)

-- |  the division operator   
(/) :: Real r => r -> r -> r

-- | list construction
(:) :: a -> [a] -> [a]

-- |  Relational @<@ operator. Obeys the following laws:
--         > if a < b && b < c then a < c
--         > a < b == b > a
--              
(<) :: Ord ord => ord -> ord -> Bool

-- |  Relational @<=@ operator. Obeys the following laws:
--         > if a <= b && b <= c then a <= c
--         > a <= b == b >= a
--         > a <= b == !(a > b)
--              
(<=) :: Ord ord => ord -> ord -> Bool

-- |  This operator must be defined in all instances. It compares its operands and
--         returns 'Lt' if the first is lower than the second, 'Gt' if the first is
--         greater than the second and 'Ordering.Eq' otherwise.
-- 
--         The following shall be invariantly true:
--         > case a <=> b of { Eq -> a == b; _ -> a != b }
-- 
--              
(<=>) :: Ord ord => ord -> ord -> Ordering

-- |  Check for equality. This function is required in all instances.   
-- 
--  The basic law of philosophy   
-- 
--  > a == a   
-- 
--  shall be obeyed by all implementations.   
(==) :: Eq eq => eq -> eq -> Bool

-- |  This checks for object identity or equality of primitive values
--     using Java's @==@ operator.
--     It evaluates its arguments, so undefined values cannot be compared.      
(===) :: a -> a -> Bool

-- |  Relational @>@ operator. Obeys the following laws:
--         > if a > b && b > c then a > c
--         > a > b == b < a
--              
(>) :: Ord ord => ord -> ord -> Bool

-- |  Relational @>=@ operator. Obeys the following laws:
--         > if a >= b && b >= c then a >= c
--         > a >= b == b <= a
--         > a >= b == !(a < b)
--              
(>=) :: Ord ord => ord -> ord -> Bool

-- |  In patterns, the \@-operator is used to bind a name to a complex pattern   
-- 
--  > f (x@a:as) = e   
-- 
--  is the same as   
-- 
--  > f arg = case arg of { x -> case x of { a:as -> e }}   
(@) :: b -> a -> ()

-- |     'Bool' values are based on Java's primitive @boolean@ values.
--     Note that @true@ and @false@ are literals, not constructors.
--       
data Bool

-- |  * A class for data types that have a lower and an upper bound.
--  *
--  * Instances of 'Bounded' can be derived automatically for enumeration types.
--       
class Bounded


instance Bounded Bool


instance Bounded Char


instance Bounded Int


instance Bounded Long

-- |  warning: probably catches more exceptions than you want to handle, use (Exception1|Exception2|Result)
--     This is the principal return type for java methods that are expected to
--     throw exceptions.
--     
--     It is strongly recommended to use more specific exception types.
--       
type CatchAll = Either Throwable

-- |  'Char' values are based on Java's primitive @char@ values.   
-- 
--  This type has many native functions based on the methods in @java.lang.Character@.    
-- 
--  Most @is...@ functions work on 'Char'  and 'Int' (codepoint).   
-- 
--  Likewise, most @to...Case@ functions work on codepoints.   
data Char

-- |  * We need to do some reflection from frege code.
--  * For example, when we catch a 'Throwable' thrown from Java code.
--  * we might want to know what it is.
--       
data Class

-- |  Forward declaration of 'frege.java.Lang#ClassNotFoundException'   
data ClassNotFoundException

-- |  'Double' values are Java's primitive @double@ values.   
-- 
-- 
--     According to the Java Language Specification §4.2.3, @double@ values are
--     64-bit-precision binary floating point values. The values and the operations
--     on it behave as specified in the IEEE Standard for Binary Floating-Point Arithmetic.
--          
data Double


data Either

-- |  * Class 'Enum' defines operations on sequentially ordered types.
--  *
--  * A type that is an instance of 'Enum' is also an instance
--  * of 'Ord' (and, in turn, of 'Eq').
--  *
--  * Instances of 'Enum' may be derived for any enumeration type
--  * (types whose constructors have no fields).
--  * If there is no 'hashCode' provided, it will be the same as 'ord'.
--  *
--  * Enumeration types have special syntactic support with the range list:
--  > [a .. b]
--  > [a ..]
--  > [a,b .. c]
--  > [a,b ..]
--       
class Enum


instance Enum Bool


instance Enum Char


instance Enum Int

-- |  * 'Integer' is an instance of 'Enum'
--       
instance Enum Integer


instance Enum Long

-- |   The type class 'Eq' provides operators '==', '!=' and 'hashCode'.
--   
--   All types whose values can be compared for equality should be instances of
--   this class. For algebraic data types instances can be automatically derived
--   if all components are themselves instances of 'Eq'.
--        
class Eq


Eq :: Ordering


instance Eq ()


instance Eq Bool


instance Eq Char


instance Eq Double


instance Eq Float


instance Eq Int


instance Eq Long


instance Eq String


instance Eq a => Eq [a]

-- |  will be replaced by literal @false@   
False :: HaskellBool

-- |  'Float' values are based on Java's primitive @float@ values.   
-- 
-- 
--     According to the Java Language Specification §4.2.3, @float@ values are
--     32-bit-precision binary floating point values. The values and the operations
--     on it behave as specified in the IEEE Standard for Binary Floating-Point Arithmetic.
--      
data Float


Gt :: Ordering

-- |  A subclass of 'Undefined', used by the runtime to signal failed guards   
data GuardFailed

-- |     For compatibility with Haskell, the 'HaskellBool' type defines
--     constructors 'True' and 'False'.
-- 
--     When the identifiers @True@ or @False@ are used in patterns or expressions, 
--     qualified or unqualified, and name resolution detects that they
--     resolve to 'PreludeBase.HaskellBool.True' or 'PreludeBase.HaskellBool.False'
--     they will be replaced by literals @true@ or @false@.
-- 
--     This is, of course, a hack, but I see no other way to bridge the gap between
--     redefinable constructor ids and literals. For example, we couldn't simply
--     define @True@ as another literal keyword, because some Haskell code 
--     might use @Prelude.True@ or could have code like.
--     
--     > import Prelude hiding(True, False)
--     > data TriBool = False | Perhaps | True 
--      
data HaskellBool

-- |  @IO a@ is an abbreviation for 'ST' 'RealWorld' @a@   
type IO = ST RealWorld

-- |     'Int' values are based on Java's primitive @int@ values.
-- 
--     The existence of this type is assumed in numerous places in the compiler.
-- 
--     Like with all @native@ Java types, be they primitive or reference types,
--     Frege holds the raw @int@ in boxed form. However, in certain cases the
--     compiler will optimize the boxing away:
--     - Strict variables or function arguments work with the unboxed value directly.
--     - Functions with a @native@ return type generally return the unboxed value.
--     Polymorphic data structures or functions always work with boxed values.
--     Thus, for example, the function
--     > sum a b c = a + b + c
--     can compute the sum of 3 'Int's, 'Long's, 'Double's or any other values
--     of a type that is an instance of type class 'Num', but it may be somewhat
--     slower than functions specialized for a given type.
-- 
--     According to the Java Language Specification, @int@ values are
--     32 bit wide signed two's complement integers (§4.2). Java operations on @int@ do
--     not indicate overflow or underflow in any way (§4.2.2). Instead, just the low 32 bits of
--     every result are retained.
--       
data Int

-- |  * 'Integer' is
--  * a type for integer numbers of unlimited size,
--  * It has instances for 'Eq', 'Ord', 'frege.prelude.PreludeText#Show' and 'Integral'.
-- 
--  * This is derived from @java.math.BigInteger@.
--       
data Integer

-- |  Class 'Integral' provides division and remainder operations for integral numbers.   
class Integral


instance Integral Int

-- |  * 'Integer' is an instance of 'Integral'
--       
instance Integral Integer


instance Integral Long


data InterruptedException


Just :: a -> Maybe a


Left :: a -> (a | b)

-- |  * 'Long' values are based on Java's primitive @long@ values.
--  *
--  * According to the Java Language Specification, @long@ values are
--    64 bit wide signed two's complement integers (§4.2). Java operations on @long@ do
--    not indicate overflow or underflow in any way (§4.2.2). Instead, just the low 64 bits of
--    every result are retained.
--       
data Long


Lt :: Ordering


data Maybe

-- |  A subclass of 'Undefined', used by the runtime to signal failed pattern matches   
data NoMatch


Nothing :: Maybe a

-- |  The 'Num' class provides the operators ('+'), ('-') and ('*') as well as
--     some functions that are common for all numeric types.
--          
class Num


instance Num Int


instance Num Long

-- |  @java.lang.NumberFormatException@ needed for string conversion operations   
-- 
--  declared *@protected@* to avoid name conflicts with 'frege.java.Lang#NumberFormatException'    
data NumberFormatException

-- |     The Java Object type
--          
data Object

-- |   The 'Ord' class provides relational operators as well as the functions 'max' and 'min'.
--   The default implementation defines them all in terms of the _compare_ operator '<=>'.
-- 
--   Making some type an instance of 'Ord' makes it automatically an instance of 'Eq' if it
--   is not one already and if it has an implementation for 'hashCode'. 
--   The operators '==' and '!=' will be defined in terms of '<=>'.
-- 
--   Instances of 'Ord' can be derived automatically for algebraic data types when
--   all elements of the type are themselves instances of 'Ord' and when the type is
--   an instance of 'Eq'.
--       
class Ord


instance Ord Bool


instance Ord Char


instance Ord Double


instance Ord Float


instance Ord Int

-- |  * 'Integer' is an instance of 'Ord'
--       
instance Ord Integer


instance Ord Long


instance Ord String

-- |  'Ordering' encodes the results of comparisons, see also  '<=>'   
data Ordering

-- |  * The 'Real' class provides the division operator ('/').
--       
class Real


instance Real Double


instance Real Float

-- |  * This abstract data type identifies the global state (disk, network, you name it).
--  * Values of type 'ST' 'RealWorld' @a@ are likely to perform input/output, manipulate
--  * global data and so on.
--       
data RealWorld


Right :: b -> (a | b)

-- |  * @(ST s a)@ is an abstract data type and is
--  * a computation that encapsulates side effects in state thread @s@
--  * and returns a value of type @a@.
-- 
--  * The type @s@ can be understood as a compiler generated unique index for state threads.
--  * Every state thread is independent of each other and keeps track of mutable variables
--  * created in it. For detailed information, read the paper _Lazy Functional State Threads_.
-- 
--  * Every mutable native data type shall be wrapped in a 'frege.prelude.PreludeIO#Mutable' 
--  * with phantom type parameter @s@.
--  * that tells to what state thread the value belongs. 
--  * For example, the @new@ method of
--  * the java class @java.util.Date@ could be accessed like this:
-- 
--  > data Date s = native java.util.Date where
--  >     native new :: Long -> ST s (Mutable s Date)
-- 
--  * Inside ST actions, Date values can be created and manipulated with
--  * impure native methods at will. However, such a value can never escape
--  * its ST thread.
-- 
--  * Because @ST s@ is an instance of 'frege.prelude.PreludeMonad#Monad', ST actions can be combined, which
--  * ensures sequenced execution. For example, we could add another method
--  * to the Date type that converts the date to a string:
--  * >     native toString :: Mutable s Date -> ST s String
--  * and a computation which yields the current time in string form:
--  * > epoch = do
--  * >    date <- Date.new 0L
--  * >    return date.toString
--  * This looks almost like java already! @epoch@ has type @ST s String@ and we can run
--  * the computation with @epoch.run@ (see 'ST.run' below), 
--  * which gives us a nice, pure, immutable,
--  * functional, correct 'String' value.
-- 
--  * The 'IO' type is just an alias for 'ST' 'RealWorld', and can be thought of as
--  * indexing a unique global state thread.
--  * Values of type 'IO' @a@ are also called  _IO actions_.
-- 
--  * Any ST value can also be used in the IO thread.
-- 
--  * This guarantees that
--  * - any computation with side effect is sequenced through the ST-Monad
--  * - any function whose return type is not @IO something@ does not have side effects,
--  *   as long as no impure native function or value is deliberately declared to be pure.
--       
data ST

-- |     'String' values are based on Java\'s @java.lang.String@ objects.
--     'String' is an alias for 'StringJ' 'Char'
--          
type String = StringJ Char

-- |     For technical reasons, the native string type is defined with a phantom type,
--     which allows us to treat strings like character lists.
--     
--     The following rules apply:
--     - There must be no polymorphic non empty string. Trying to extract elements from it
--       with 'String.charAt' would fail with an exception at runtime.
--     - Every function with return type ('StringJ' a) must either take one or more arguments
--       of the same type which it manipulates, or it must return the empty string. In the former
--       case, the elements of the result string must all be computed from the 
--       elements of the argument strings.    
--          
data StringJ

-- |  Frege wrapper for java Throwables.   
data Throwable

-- |  will be replaced by literal @true@   
True :: HaskellBool

-- |  An unchecked subclass of @java.lang.RuntimeException@ for the Frege Runtime   
-- 
--  An instance of 'Undefined' will be thrown if 'undefined' or ('error' msg) is evaluated.     
data Undefined

-- | empty list
([]) :: [a]

-- | list type
data ([])

-- |  @ x ^ n @  raise _x_ to the _n_-th power   
-- 
--  The exponent must be positive.    
(^) :: (Integral integ,Num a) => a -> integ -> a

-- |  * @a ^^ b@ is true if either _a_ or _b_ is true, but not both.
--  * > a ^^ b = if a then not b else b
--       
(^^) :: Bool -> Bool -> Bool

-- |  Computes the absolute value   
abs :: Num n => n -> n

-- |  @asTypeOf a b@ is _a_  with the type of _b_.   
-- 
--  This is a type restricted version of 'const'.   
asTypeOf :: a -> a -> a

-- |  * @comparing f@ applies a projection function on both sides of '<=>'.
--  * Example usage:
--  * > sortBy (comparing snd) [(1, "z"), (2, "b")] == [(2, "b"), (1, "z")]
--       
ascending :: Ord a => (b->a) -> b -> b -> Ordering


atoi :: String -> Int

-- |  every integral number can be converted to a big 'Integer'   
big :: Integral integ => integ -> Integer

-- | This is used by code generation when a conditional expression
-- appears in a lazy context, i.e.
-- > (42, if foo then bar else baz)
-- @bool a b c@ evaluates to @a@ if @c@ is @true@, otherwise to @b@.
--      
bool :: a -> a -> Bool -> a


chr :: Int -> Char


compare :: Ord ord => ord -> ord -> Ordering

-- |  * @comparing f@ applies a projection function on both sides of '<=>'.
--  * Example usage:
--  * > sortBy (comparing snd) [(1, "z"), (2, "b")] == [(2, "b"), (1, "z")]
--       
comparing :: Ord a => (b->a) -> b -> b -> Ordering

-- |  @const a@ is a function that returns _a_ regardless of its argument.   
const :: b -> a -> b

-- |  * Determines the constructor of a value.
--  * This is used like
--  * >constructor arg
--  * where @arg@ is any frege value.
--  *
--  * Returns 0 for function types, product types and native types or
--  * the _constructor number_ for constructed types. The _constructor number_
--  * is a small integer associated with every constructed value. It indicates
--  * the data constructor a value was constructed with.
--  *
--  * The compiler assigns constructor numbers starting from 0 to the constructors
--  * defined in a @data@ definition in the order of their appearance.
--  *
--  * Examples
--  * >constructor [] == 0
--  * >constructor (a:as) == 1
--  * >constructor "string"  == 0    // native value
--  *
--  * This function is strict in its argument, i.e.
--  * >constructor undefined == undefined
--  *
--  * *Implementation specific:* This function is used in derived instances
--  * of 'Eq' and 'Ord'.
--       
constructor :: a -> Int

-- |  make a 'String' from a single 'Char'   
ctos :: Char -> String

-- |  @curry f@ passes the next two arguments as 2-tuple to _f_   
curry :: ((c,b)->a) -> c -> b -> a

-- |  * @descending f@ applies a projection function on both sides of '<=>', but flips arguments.
--  * Example usage:
--  * > sortBy (descending fst) [(1, "z"), (2, "b")] == [(2, "b"), (1, "z")]
--       
descending :: Ord a => (b->a) -> b -> b -> Ordering

-- |  integer division   
div :: Integral integ => integ -> integ -> integ


divMod :: Integral integ => integ -> integ -> (integ,integ)

-- |  apply first function to value in 'Left' or second function to value in 'Right'   
either :: (a->c) -> (b->c) -> (a | b) -> c

-- |  used in translating @[n..]   
enumFrom :: Enum e => e -> [e]

-- |  used in translating @[n,n'..]   
enumFromThen :: Enum e => e -> e -> [e]

-- |  used in translating @[n,n'..m]   
enumFromThenTo :: Enum e => e -> e -> e -> [e]

-- |  used in translating @[n..m]   
enumFromTo :: Enum e => e -> e -> [e]

-- |  Construct an undefined value with an informative message.   
-- 
--  When evaluated, an 'Undefined' exception will be thrown.   
error :: String -> u


even :: Integral integ => integ -> Bool

-- |  Exchange first and second argument of a function, i.e.   
-- 
--  > flip f a b = f b a   
flip :: (a->b->c) -> b -> a -> c

-- |      * @T.from i@ maps the 'Int' value @i@ to a value of @T@, such that
--      >   ord (T.from i) == i
--      * unless there is no value @e@ of @T@ so that @ord e == i@. In the
--      * latter case, the result is 'undefined'.
--           
from :: Enum e => Int -> e

-- |  convert a 'Double' to any 'Real' value   
fromDouble :: Real r => Double -> r

-- |  converts an 'Int' value to the instantiated type   
fromInt :: Num n => Int -> n

-- |  converts an 'Integer' value to the instantiated type   
fromInteger :: Num n => Integer -> n

-- |  every 'Num' can be made from an 'Integral'   
fromIntegral :: (Integral integ,Num b) => integ -> b

-- |  return the first element of a 2-tuple   
fst :: (a,b) -> a

-- |         'gcd' @x y@ is the non-negative factor of both @x@ and @y@ of which
--         every common factor of @x@ and @y@ is also a factor; for example
--         'gcd' @4 2 = 2@, @'gcd' (-4) 6 = 2@, @'gcd' 0 4@ = @4@. @'gcd' 0 0@ = @0@.
--         (That is, the common divisor that is \"greatest\" in the divisibility
--         preordering.)
--     
--         Note: Since for signed fixed-width integer types, 'abs' 'minBound' < @0@,
--         the result may be negative if one of the arguments is 'minBound' (and
--         necessarily is if the other is @0@ or 'minBound') for such types.
--              
gcd :: Integral integ => integ -> integ -> integ

-- |  worker function for 'Integral.gcd', needs not pollute the namespace   
gcdHelper :: Integral integ => integ -> integ -> integ

-- |  Compute a hash code.    
-- 
--  The following rules shall hold in all instances:   
-- 
--  > a == b ==> hashCode a == hashCode b   
-- 
--  > hashCode a != hashCode b ==> a != b   
-- 
--  In addition, unequal values should produce unequal hash codes more likely than not.   
-- 
-- 
--         The hash code in derived instances for algebraic data types is computed as follows:
--         > hashCode v = case v of
--         >    Con_1 f_1 ... f_k -> fold mkhash 1 [1, hashCode f_1, ..., hashCode f_k ]
--         >    ...
--         >    Con_n f_1 ... f_k -> fold mkhash 1 [n, hashCode f_1, ..., hashCode f_k ]
--         >   where mkhash a b = (31 * a) + b
--         Here, the @Con_i@ with @i>0@ are the constructors, and in each clause
--         the @f_j@ with @j >= 0@ are bound to the fields of the constructor under
--         consideration.
--          
hashCode :: Eq eq => eq -> Int


id :: a -> a

-- |  Floating point number types may have special values for _infinity_
--         and _negative infinity_. @isFinite n@ yields @true@ if @n@ is an infinite
--         value and @false@ in all other cases.
-- 
--         The default implementation always returns @false@ so that implementors of
--         instances for types without special values for infinity need not care.
-- 
--         See also 'isNumber'.
--          
isInfinite :: Num n => n -> Bool

-- |  Floating point number types may have a special values for
--         _not a number_ (NaN). For example, @0d / 0d@ is NaN.
--         @isNaN n@ yields @true@ if @n@ is the special value that indicates that
--         @n@ is not a number and @false@ in all other cases.
-- 
--         The default implementation always returns @false@ so that implementors of
--         instances for types without such a special values need not care.
-- 
--         See also 'isNumber'.
--          
isNaN :: Num n => n -> Bool

-- |  Returns @true@ if @n@ is neither infinite (see 'isInfinite') nor NaN (see 'isNaN').
-- 
--         Note that certain properties for functions on numbers are true only under the assumption
--         that the argument values are numbers.
-- 
--         The default implementation is
--         > isNumber n = !(isInfinite n) && !(isNaN n)
--         so that the function should always compute
--         the right answer as long as 'isInfinite' and 'isNaN' do.
--          
isNumber :: Num n => n -> Bool

-- | warning: will soon be replaced with bool
-- This is used by code generation when a conditional expression
-- appears in a lazy context, i.e.
-- > (42, if foo then bar else baz)
-- @lazyif a b c@ evaluates to @b@ if @a@ is @true@, otherwise to @c@.
--      
lazyif :: Bool -> a -> a -> a

-- |  'lcm' @x y@ is the smallest positive integer that both @x@ and @y@ divide.   
lcm :: Integral integ => integ -> integ -> integ

-- |  > max a b = if a > b then a else b   
max :: Ord ord => ord -> ord -> ord

-- |  the upper bound   
maxBound :: Bounded b => b

-- |     The 'maybe' function takes a default value, a function, and a 'Maybe' value. 
--     If the 'Maybe' value is 'Nothing', the function returns the default value. 
--     Otherwise, it applies the function to the value inside the 'Just' and returns the result.
--          
maybe :: a -> (b->a) -> Maybe b -> a

-- |  > min a b = if a < b then a else b   
min :: Ord ord => ord -> ord -> ord

-- |  the lower bound   
minBound :: Bounded b => b

-- |  This modulo operator works so that   
-- 
--  > forAll arbitrary (\a -> forAll arbitrary (\b -> (a `div` b) * b + (a `mod` b) = a))   
-- 
--  In addition, it is the case that   
-- 
--  > forAll arbitrary (\a -> forAll arbitrary (\b -> @(a `quot` b) == (a `div` b) || (a `quot` b) == (a `div` b)-1))   
mod :: Integral integ => integ -> integ -> integ

-- |  Negates a number n such that if n is a number   
-- 
--  > n + negate n == 0   
negate :: Num n => n -> n

-- |     @not b@ is true if _b_ is false, otherwise true. Uses java's '!' operator.
--       
not :: Bool -> Bool


odd :: Integral integ => integ -> Bool

-- |  Like '||', but second argument is lazy.
--     The @`oder`@ operator has the same precedence and arity as '||'.
--     The definition is
--     > a `oder`  b = if a then true  else b
--     This should really be named _or_, but Haskell 2010 uses this already for lists.
--     Hence we use the german word _oder_.
--          
oder :: Bool -> Bool -> Bool

-- |  > g `on` f    
-- 
--  Apply a projection function @f@ on both operands of @g@   
-- 
--  > comparing f = (<=>) `on` f   
on :: (a->a->c) -> (b->a) -> b -> b -> c

-- |  the number 1 in the instantiated type   
one :: Num n => n

-- |  @ord e@ returns the ordinal number associated with the value @e@. For
--      * enumeration types, 'ord' is the same as 'constructor', for 'Int', it is the
--      * identity function.
--      * Some types, like 'Long', cannot map all their values to 'Int', in such cases
--      * the result of applying 'ord' may be meaningless.
--           
ord :: Enum e => e -> Int

-- | This is a constant with the value @true@.
-- It is most often used as the last alternative in pattern guards:
-- 
-- > foo n | n >= 0    = ...
-- >       | otherwise = ...
--      
otherwise :: Bool

-- |  helper for 'Integral.^'   
powf :: (Integral integ,Num a) => a -> integ -> a

-- |  helper for 'Integral.^'   
powg :: (Integral integ,Num a) => a -> integ -> a -> a

-- |  @pred e@ is the predecessor of @e@ or 'undefined' if there is no predecessor.   
pred :: Enum e => e -> e

-- |  warning: use @stdout.print@ instead   
-- 
--  print a 'String' to the standard output stream   
printStr :: String -> IO ()

-- |  warning: use @stdout.println@ instead   
-- 
--  print a 'String' to the standard output stream and append a new line.   
printStrLn :: String -> IO ()


quot :: Integral integ => integ -> integ -> integ

-- |  Haskell compatibility   
quotRem :: Integral integ => integ -> integ -> (integ,integ)

-- |  The remainder á la Java operator @%@ - @a `rem` b@ has same sign as @a@   
-- 
--  > forAll arbitrary (\a -> forAll arbitrary (\b -> (a `quot` b) * b + (a `rem` b) = a   
-- 
--  This behaviour is the same as in Haskell   
rem :: Integral integ => integ -> integ -> integ

-- |  @a `seq` b@ evaluates _a_ before it returns _b_   
-- 
--  This is a right associative operator with precedence 15.   
seq :: a -> b -> b

-- |  @sign n@ is -1 if n<0, 1 if n>0 and 0 otherwise   
sign :: Num n => n -> Int

-- |  return the second element of a 2-tuple   
snd :: (b,a) -> a

-- |  Constructs a strict 10-tuple. See remarks for 'strictTuple2'.   
strictTuple10 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> (a,b,c,d,e,f,g,h,i,j)

-- |  Constructs a strict 11-tuple. See remarks for 'strictTuple2'.   
strictTuple11 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> (a,b,c,d,e,f,g,h,i,j,k)

-- |  Constructs a strict 12-tuple. See remarks for 'strictTuple2'.   
strictTuple12 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> (a,b,c,d,e,f,g,h,i,j,k,l)

-- |  Constructs a strict 13-tuple. See remarks for 'strictTuple2'.   
strictTuple13 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> (a,b,c,d,e,f,g,h,i,j,k,l,m)

-- |  Constructs a strict 14-tuple. See remarks for 'strictTuple2'.   
strictTuple14 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n)

-- |  Constructs a strict 15-tuple. See remarks for 'strictTuple2'.   
strictTuple15 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o)

-- |  Constructs a strict 16-tuple. See remarks for 'strictTuple2'.   
strictTuple16 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p)

-- |  Constructs a strict 17-tuple. See remarks for 'strictTuple2'.   
strictTuple17 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q)

-- |  Constructs a strict 18-tuple. See remarks for 'strictTuple2'.   
strictTuple18 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r)

-- |  Constructs a strict 19-tuple. See remarks for 'strictTuple2'.   
strictTuple19 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s)

-- |  * Constructs a strict tuple.
-- 
--  * The difference to '(,)' is that both argument values
--  * will be evaluated before the tuple is constructed. Thus:
--  * >fst (42; undefined) == undefined
--  * >fst (42, undefined) == 42
--  * *Implementation specific:* The compiler will rewrite @(a;b)@ as
--  * @(PreludeBase.strictTuple2 a b)@.
--       
strictTuple2 :: a -> b -> (a,b)

-- |  Constructs a strict 20-tuple. See remarks for 'strictTuple2'.   
strictTuple20 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t)

-- |  Constructs a strict 21-tuple. See remarks for 'strictTuple2'.   
strictTuple21 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u)

-- |  Constructs a strict 22-tuple. See remarks for 'strictTuple2'.   
strictTuple22 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v)

-- |  Constructs a strict 23-tuple. See remarks for 'strictTuple2'.   
strictTuple23 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w)

-- |  Constructs a strict 24-tuple. See remarks for 'strictTuple2'.   
strictTuple24 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x)

-- |  Constructs a strict 25-tuple. See remarks for 'strictTuple2'.   
strictTuple25 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y)

-- |  Constructs a strict 26-tuple. See remarks for 'strictTuple2'.   
strictTuple26 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> j -> k -> l -> m -> n -> o -> p -> q -> r -> s -> t -> u -> v -> w -> x -> y -> z -> (a,b,c,d,e,f,g,h,i,j,k,l,m,n,o,p,q,r,s,t,u,v,w,x,y,z)

-- |  Constructs a strict 3-tuple. See remarks for 'strictTuple2'.   
strictTuple3 :: a -> b -> c -> (a,b,c)

-- |  Constructs a strict 4-tuple. See remarks for 'strictTuple2'.   
strictTuple4 :: a -> b -> c -> d -> (a,b,c,d)

-- |  Constructs a strict 5-tuple. See remarks for 'strictTuple2'.   
strictTuple5 :: a -> b -> c -> d -> e -> (a,b,c,d,e)

-- |  Constructs a strict 6-tuple. See remarks for 'strictTuple2'.   
strictTuple6 :: a -> b -> c -> d -> e -> f -> (a,b,c,d,e,f)

-- |  Constructs a strict 7-tuple. See remarks for 'strictTuple2'.   
strictTuple7 :: a -> b -> c -> d -> e -> f -> g -> (a,b,c,d,e,f,g)

-- |  Constructs a strict 8-tuple. See remarks for 'strictTuple2'.   
strictTuple8 :: a -> b -> c -> d -> e -> f -> g -> h -> (a,b,c,d,e,f,g,h)

-- |  Constructs a strict 9-tuple. See remarks for 'strictTuple2'.   
strictTuple9 :: a -> b -> c -> d -> e -> f -> g -> h -> i -> (a,b,c,d,e,f,g,h,i)

-- |     @strtail s n@ returns a new string that is a substring of string _s_.
--     The substring begins with the character at the specified index
--     and extends to the end of _s_.
-- 
--     This uses the native method @substring@ of class @java.lang.String@. It
--     will throw an @IndexOutOfBoundsException@ if _n_ is negative or larger than
--     the length of _s_.
--      
strtail :: StringJ a -> Int -> StringJ a

-- |      @substr s start end@ returns the sub string of @s@ that starts
--      with the character at position @start@
--      and extends to the character at position @end-1@.
-- 
--     This uses the native method @substring@ of class @java.lang.String@. It
--     will throw an @IndexOutOfBoundsException@ if @start@ is negative or larger than
--     @end@ or if @end@ is greater than the length of @s@.
--       
substr :: StringJ a -> Int -> Int -> StringJ a

-- |  use @(subtract a)@ instead of @\\b -> b-a@ in sections   
subtract :: Num n => n -> n -> n

-- |  @succ e@ is the successor of @e@ or 'undefined' if there is no such successor.   
succ :: Enum e => e -> e

-- |  Constructs an undefined value from a java exception and throws it.   
throw :: Throwable -> a

-- |  every integral number can be converted to a big 'Integer'   
toInteger :: Integral integ => integ -> Integer

-- |  warning: use @stderr.print@ instead           
-- 
--  print a 'String' to the standard error stream   
traceStr :: String -> IO ()

-- |  warning: use @stderr.println@ instead   
-- 
--  print a 'String' to the standard error stream and append a new line.   
traceStrLn :: String -> IO ()

-- |  Passes the elements of a 2-tuple as arguments to a function.   
uncurry :: (b->c->a) -> (b,c) -> a

-- |  Like '&&', but second argument is lazy.
--     The @`und`@ operator has the same precedence and arity as '&&'.
--     The definition is
--     > a `und` b = if a then b     else false
--     This should really be named _and_, but Haskell 2010 uses this already for lists.
--     Hence we use the german word _und_.
--          
und :: Bool -> Bool -> Bool

-- |  This is the standard undefined value.   
undefined :: u

-- |  * @using f@ applies a projection function _f_ on both sides of '=='.
--  * Example usage:
--  * > uniqBy (using fst) [(1, 1), (2, 2), (2, 3), (3,4), (2,5)]
--       
using :: Eq a => (b->a) -> b -> b -> Bool

-- |  the number 0 in the instantiated type   
zero :: Num n => n

-- |     The Java @||@ operator on booleans.
--     
--     Note that since this is a
--     native function, the second argument appears strict to the compiler
--     when in fact it is lazy at the Java level.
--     
--     This can lead to inconsistent results in cases where the wrong strictness of
--     the second argument propagates to arguments of the function that contains 
--     an application of '||'. (The documentation for '&&' has an example.)
--     
--     See 'oder' for an alternative
--          
(||) :: Bool -> Bool -> Bool



-- |     This package provides classes and functions that deal with the lesser pure
--     parts of Frege - Exceptions, Threads, mutable data.
--     
--     This package is _implementation specific_ insofar as the compiler may
--     assume that certain items are defined here in a certain way.
--     Changes may thus lead to compiler crashes or java code that 
--     will be rejected by the java compiler.
--     
--     In particular, derived 'Exceptional' instances will reference
--     type class 'Exceptional'.
--     
--       
module frege.prelude.PreludeIO
-- |  * For a data type declared like
--  * > data D = native Javatype
--  * where @Javatype@ implements the @java.lang.Cloneable@ interface,
--  * one can get implementations for 'Freezable.freeze'
--  * and 'Freezable.thaw' by just stating
--  * > instance Cloneable D
--  * The 'freeze' and 'thaw' operations are implemented in terms of 'clone'.
--  *
--  * Note: Cloning does *not* produce safe copies if the cloned object
--  * contains references to mutable objects. In such cases, sort of a deep cloning
--  * would be required.
--       
class Cloneable


data Exception

-- |     Function 'catch' requires that the argument of a handler function
--     is an instance of 'Exceptional'. 
--     
--     This is derivable for @pure@ @native@ data types.
--          
class Exceptional


instance Exceptional Exception


instance Exceptional GuardFailed


instance Exceptional NoMatch


instance Exceptional Undefined

-- |  * Type class for mutable values that support making read-only copies.
--  * To be implemented with care.
--       
class Freezable

-- |  They type of 'IO' actions that return a mutable value of type _d_   
-- 
--  This is an abbreviation for @ST RealWorld (Mutable RealWorld d)@    
type IOMutable = ST RealWorld (Mutable RealWorld d)

-- |  Haskell compatibility   
type IORef = Mutable RealWorld (Ref a)

-- |     Make the @java.lang.Class@ object corresponding to the instantiated type available.
--     
--     An instance for this type class is needed for the element type 
--     of 'frege.prelude.PreludeArrays#JArray's 
--     (which are based on 
--     'http://docs.oracle.com/javase/7/docs/api/java/lang/reflect/Array.html reflective true Java arrays')
--     one needs to create.
--     
--     A subclass of this is 'Exceptional' which
--     adds no additional functionality and behaves
--     basically just as a marker interface for exceptions.
--          
--     'JavaType' instances are derivable for all data types.
--          
class JavaType

-- |     'Mutable' is a wrapper for native data types. 
--     A value of type @Mutable s x@ is really an @x@, but it is tied to the 'ST' thread s,
--     from which it cannot escape.
--     
--     The compiler will enforce the following rules:
--     
--     1. When type checking @x.m@ and @(x::Mutable s T)@, @m@ will be searched in the namespace @T@
--     2. An impure native method must only take and return @Mutable s T@, unless @T@ is
--        itself *@pure@* (of course, all algebraic data types are pure)
--     3. A pure type @T@ must not appear as @Mutable s T@ in native functions.
--     4. Pure native functions may not return @Mutable s t@ for any @t@.
--     5. Pure native functions must not normally get arguments of type @Mutable s T@. (see below)
--     6. In a type of the form @ST x (Mutable y d)@, it will be enforced that _x_ is the same
--        type as _y_. Furthermore, all phantom types of all 'Mutable' types must be the same
--        in a type signature.
--     
--     To understand the motivation for rule 5, observe that the 'Mutable.Mutable' 
--     data constructor cannot be applied in Frege code, hence the only possibility 
--     to obtain a value of type @Mutable s t@  is through a native function. 
--     But by rule 4 above, this could only happen in the 'ST' or 'IO' monad, 
--     from whence those values cannot escape. The 'ST' monad is a context where
--     the sequence of actions matters. If we allowed passing mutable data to pure
--     functions, their results would depend on whether 'ST' actions modified the 
--     value before the result is actually evaluated.
--     
--     Although in a strict sense, no pure function should get mutable data, rule 5 is only
--     enforced for native pure functions, as normal frege functions couldn't do anything
--     with the native value, except passing them on to native functions eventually.
--     
--     There will be means to get a read-only copy ('freeze') of a mutable value through
--     class 'Freezable'.
--     
--     There is also the possibility that, although a value is mutable, 
--     there are certain properties that cannot change (such as the length of an array). 
--     It will be possible to bypass rule 5 in such cases.
--     
--     To summarize:
--     
--     - Mutable data live in the 'ST' or 'IO' monad, from which they cannot escape.
--     - They can be passed only to other 'ST' actions that operate in the same state thread,
--       as indicated by the phantom type, that is either a type variable or 'RealWorld'.
--     - Read only copies of mutable values and mutable copies of read-only values can be obtained.        
--     - Rule 5 can be bypassed in exceptional cases.
--     
--          
data Mutable

-- |  They type for mostly mutable values that are tied to the 'IO' monad.   
-- 
-- 
--     For java types that are *mutable only* so that they always would occur 
--     wrapped into 'MutableIO', the convention is to
--     declare them as
--     
--     > data Thing = mutable native org.mut.impure.Thing
--     
--     and just write @Thing@ everywhere.
--     The type checker will check the rules for native functions  
--     _as if_ @Thing@ was 'MutableIO' @Thing@.
--     
--     However, normal type unification does not take the mutable status into account, so
--     @Mutable a m@ will never unify with @Thing@. 
--          
type MutableIO = Mutable RealWorld

-- |  A mutable reference, suitable for use in the 'ST' monad.   
data Ref

-- |  They type of 'ST' actions that return a mutable value of type _d_   
-- 
--  This is an abbreviation for @ST s (Mutable s d)@    
type STMutable = ST s (Mutable s d)

-- |  * For a data type declared like
--  * > data D = native Javatype
--  * where @Javatype@ implements the @java.io.Serializable@ interface,
--  * one can get implementations for 'freeze'
--  * and 'thaw' by just stating
--  * > instance Serializable D
--  * The 'freeze' and 'thaw' operations are implemented in terms of 'copySerializable',
--  * which serializes its argument to a byte array and creates a new copy by
--  * deserializing it from the byte array.
--       
class Serializable

-- |     The construct
--     
--     > action `catch` handler
--     
--     is a 'ST' action with the same type as _action_.
--     
--     If _action_ yields a result, this will be the result of the overall action.
--     However, if, during execution of _action_ the JVM raises an exception _e_ with 
--     java type @E@, and @E@ is a subtype of java type @H@, and @H@ is the 
--     java type associated with the argument of _handler_, the return value will be:
--     
--     > handler e
--     
--     Otherwise, if the type of _e_ does not allow to pass it to _handler_ it will
--     be propagated upwards and @a `catch` b@ will not return to its caller.
--     
--     Because 'catch' is left associative, it is possible to catch different exceptions,
--     like in:
--     
--     > action `catch` handler1 `catch` handler2
--     
--     Care must be taken to check for the *most specific* exception first. In the example above,
--     if the exception handled by _handler1_ is *less specific* than the one handled by _handler2_,
--     then _handler2_ will never get a chance to execute. 
--     
--     Another way to put this is to say that if @E1@ and @E2@ are distinct exception types
--     handled in a chain of 'catch'es, and @E1@ is (from the point of view of Java!) a
--     subtype of @E2@, then the handler for @E1@ must appear further left than the handler for
--     @E2@. If it is a super type of @E2@, however, its handler must appear further right.
--     And finally, if the types do not stand in a sub-type relationship, the order of the 
--     handlers is immaterial.
--     
--     *Note* If _action_ is of the form:
--     
--     > doSomething arg
--     
--     then, depending on the strictness of _doSomething_ the argument _arg_ may be evaluated
--     *before* the action is returned. Exceptions (i.e. undefined values) 
--     that occur in the construction of the action do *not* count as 
--     exceptions thrown during execution of it, and hence cannot be catched.
--     
--     Example:
--     
--     > println (head []) `catch`  ....
--     
--     will not catch the exception that will be thrown when println evaluates  
--     
--     For a remedy, see 'try'.         
--          
catch :: JavaType c => ST b a -> (c->ST b a) -> ST b a

-- |     The 'catchAll' function runs a 'ST' action and returns 
--     either the result or the exception thrown.
--      
catchAll :: ST α β -> ST α (Exception | β)

-- |      *  @clone v@ must be a native method that works like @java.lang.Object#clone@.
--           
clone :: Cloneable f => f -> f

-- |      *  @copySerializable v@ is supposed to be a native function that is
--      *  implemented by @frege.runtime.Runtime.copySerializable@ at the instantiated type.
--           
copySerializable :: Serializable f => f -> f

-- |  nowarn: argument of type (ST s a)   
-- 
--  Runtime method for implementation of 'catch'   
doCatch :: Class b -> ST s a -> (b -> ST s a) -> ST s a

-- |  nowarn: argument of type (ST s a)   
-- 
-- 
--     The construct
--     
--     > action `finally` always
--     
--     returns the same value as _action_, when executed.
--     
--     However, no matter if _action_ produces a value or diverges 
--     (for example, by throwing an exception), in any case will _always_ be executed,
--     and its return value dismissed.
--     
--     Note that 'finally' only returns to its caller if _action_ would have done so.
--     
--     'finally' has the same fixity as 'catch', hence it is possible to have
--     
--     > action `catch` handler1 `catch` handler2 `finally` always
--     
--          
finally :: IO a -> IO b -> IO a

-- |      * "Freeze" a mutable native value. The result is supposed to be immutable
--      * or at least not reachable from other parts of the code, especially from java code.
--      *
--      * The most prominent way to freeze a value is by 'clone'-ing it, if that is supported.
--      * But note that sometimes a deep copy would be needed, and that @clone@ does not do that.
--           
freeze :: Freezable f => f -> f

-- |  The @java.lang.Class@ object of the instantiated type   
javaClass :: JavaType e => Class e

-- |  modify the referenced value with a function   
modifyIORef :: Mutable b (Ref a) -> (a->a) -> ST b ()

-- |  Obtain a read only native value (temporarily) typed as 'Mutable'   
-- 
--  
--     For example, this could be needed when running a native 'ST' method
--     that uses the value as read-only, but we can't declare it, like:
-- 
--     > private native copyOf java.util.Arrays.copyOf 
--     >               :: ArrayOf s HashMap -> Int -> ST s (ArrayOf s HashMap)
--      
mutable :: b -> Mutable a b

-- |  create a reference that is initially set to the argument value    
newIORef :: a -> STMutable s (Ref a)

-- |  get the value the reference is pointing to   
readIORef :: Mutable s (Ref a) -> ST s a

-- |  Apply a pure function to a mutable value that pretends to be read-only.   
-- 
--  The function must not rely on anything that could change in the mutable data!   
readonly :: (m -> b) -> Mutable s m -> ST s b

-- |      * The inverse of 'freeze' creates a value (an object) which can be passed
--      * to impure functions without compromising the frozen object passed as argument.
-- 
--      * One possibility to thaw an object is by cloning it.
-- 
--      * If 'thaw' is not implemented correctly, bad things may happen.
-- 
--           
thaw :: Freezable f => f -> f

-- |  Deliberately throw an exception in the 'IO' monad.   
throwIO :: Throwable -> IO a

-- |  Deliberately throw an exception in the 'ST' monad.   
throwST :: Throwable -> ST s a

-- |     Make sure that exceptions thrown during construction of an action can be catched.
--     See 'catch' for an explanation.
--     
--     Example:
--     
--     > try println (head []) `catch` (\u::Undefined -> println u.catched)
--     
--     should print:
--     
--     > frege.runtime.Undefined: Prelude.head []
--     
--     'try' does work for unary functions only. 
--     To be safe with functions taking more actions, use:
--     
--     > return a >>= (\a -> return b >>= (\b -> f a b))
--          
try :: Monad c => (b->c a) -> b -> c a

-- |  assign another value to the reference    
writeIORef :: Mutable s (Ref a) -> a -> ST s ()



-- |     This package provides common list functions for the Frege language.
--     
--     It contains all functions described in section 9.1 of the 
--     _Haskell 2010 Language Report_, 
--     except for 'Data.List#lookup' and 'Data.List#!!'. 
--     These functions have been moved 
--     to @frege.data.List@ (the equivalent of Haskell's @Data.List@).
--     
--     In addition to the common list functions, three type classes capture common
--     properties of types that are like ordinary lists:
--     ['ListEmpty'] provides 'null' to test for empty containers and 'empty' to create one.
--     ['ListSemigroup'] introduces the '++' operator.
--     ['ListMonoid'] is the union of the previous two.
--     ['ListView'] provides 'length', and introduces 'uncons', a safe 
--     operation to split a list-view into 'head' and 'tail'.
--     ['ListSource'] is the type class for types that can be converted to lists ('toList'). 
--     There are instances for 'String', 'Maybe', 'Either' and arrays. 
--     
--     This module is _implementation specific_ insofar as the compiler may
--     assume that certain items are defined here in a certain way.
--     Changes may thus lead to compiler crashes or java code that 
--     will be rejected by the java compiler.
--     
--     In particular, desugared list comprehensions will reference 'ListSource.toList'.
--     
--     This package is implicitly imported.
--       
module frege.prelude.PreludeList
-- |  concatenate two lists, strings or whatever   
-- 
--   > empty ++ x == x && x ++ empty == x   
(++) :: ListSemigroup α => α β -> α β -> α β

-- |     A class for containers/collections that have an empty value.
--          
class ListEmpty

-- |  A class for types that support the (++) operator.   
class ListMonoid


instance ListMonoid StringJ


instance ListMonoid []

-- |  A class for types that support 'concat'   
class ListSemigroup

-- |     A class of things we can make a list from
--      
class ListSource


instance ListSource (Either α)


instance ListSource Maybe


instance ListSource []

-- |     A class for things we can view as a list
-- 
--     Such data types are instances of 'ListMonoid' 
--     and support 'head', 'tail', 'length' and concatenation ('++')
--     
--     This class provides no means to construct a list. 
-- 
--      
class ListView

-- |  'String' viewed as list of 'Char's.   
-- 
--  List functions on 'String's can get quite expensive when the JVM implements @substring@ via copying.   
-- 
--  Consider 'frege.data.Iterators#StringIterator' for an alternative   
instance ListView StringJ


instance ListView []


instance Ord a => Ord [a]

-- |     @all p xs@ tells if all elements of _xs_ have property _p_.
--     This is equivalent to 
--     > fold (&&) true (map p xs) 
--     except that
--     'all' stops at the first element that hasn't property _p_.
-- 
--     Note that, according to the identity above, @all p []@ is always @true@.
--          
all :: (a->Bool) -> [a] -> Bool

-- |     'and' returns the conjunction of a Boolean list. 
--     For the result to be *true*, the list must be finite; *false*,
--     however, results from a *false* value at a finite index of a finite or infinite list.
--          
and :: [Bool] -> Bool

-- |     @any p xs@ tells if any element of _xs_ has property _p_.
--     This is equivalent to 
--     > fold (||) false (map p xs)
--     except that
--     'any' stops at the first element that has property _p_.
-- 
--     Note that, according to the identity above,  @any p []@ is always @false@.
--          
any :: (a->Bool) -> [a] -> Bool

-- |     'break', applied to a predicate /p/ and a list /xs/, 
--     returns a tuple where the first element is the longest prefix
--     (possibly empty) of /xs/ elements that do *not* satisfy /p/ 
--     and the second element is the remainder of the list.
-- 
--     @break p@ is equivalent to @span (not • p)@.
--      
break :: (a->Bool) -> [a] -> ([a],[a])

-- |  @chunked n xs@ makes a list of chunks of _xs_ with size _n_   
-- 
--  _n_ must be positive, otherwise an infinite list of @[]@ is returned.   
-- 
--  The following should hold:   
-- 
--  > n > 0 ==> concat (chunked n xs) == xs   
chunked :: Int -> [a] -> [[a]]

-- |     'concat' concatenates the subitems of the argument which is a list of list
--     or a list of strings.
--     
--     It is ok if the argument is an infinite list or any of the sublists is infinite.
--     In either case, the result will also be infinite.
--          
concat :: (ListEmpty b,ListSemigroup b) => [b a] -> b a

-- |     Map a function over a list and concatenate the list or string results.
--          
concatMap :: (ListEmpty a,ListSemigroup a) => (c->a b) -> [c] -> a b

-- |     @cycle xs@ builds a value that is an infinite repetition of _xs_, which must not be empty.
--          
cycle :: [α] -> [α]

-- |  drop a number of initial elements   
drop :: ListView α => Int -> α β -> α β

-- |     @dropWhile p xs@ drops leading elements from _xs_ that satisfy the predicate _p_.
-- 
--     The following holds for all lists _xs_
--     > takeWhile p xs ++ dropWhile p xs == xs
--          
dropWhile :: (a->Bool) -> [a] -> [a]

-- |     @e `elem` xs@ is true if and only if at least one of the elements of _xs_ equals _e_.
--          
elem :: Eq a => a -> [a] -> Bool

-- |  the empty container   
empty :: ListEmpty α => α β

-- |     @filter p xs@ returns the list of elements _x_ from _xs_ where (_p x_) holds.
-- 
--     'filter' will not stop to evaluate its argument list until the first/next
--     element with the property asked for is found. For example
-- 
--     > filter (==true) (repeat false)
-- 
--     will loop forever, whereas
-- 
--     > filter even [1..] 
-- 
--     will faithfully deliver the list of positive integers that are divisible by 2,
--     one by one.
--          
filter :: (a->Bool) -> [a] -> [a]

-- |     'fold', applied to a binary operator, a starting value (typically the
--     left identity of the operator), and a list, reduces the list using
--     the binary operator, from left to right:
--     > fold f z [x1, x2, ..., xn] = (((z `f` x1) `f` x2) `f` ...) `f` xn
--     'fold' runs in constant stack space, but consumes the entire list before
--     returning a result, so it must not be applied to infinite lists.
-- 
--     This function is known as @foldl'@ in Haskell where there is a bias in favour
--     of using 'foldr'.
-- 
--     In the environment of the JVM stack space is precious, hence one should prefer 'fold'
--     when one has the choice.
-- 
--     'fold' is strict in the accumulator, hence in
--     every recursion the intermediate result is evaluated, thus preventing build up of
--     possibly huge thunks that result in stack overflows on evaluation.
--          
fold :: (b->a->b) -> b -> [a] -> b

-- |   warning: It is strongly advised to use 'fold' instead - beware of stack overflow!
-- 
--     'foldl', applied to a binary operator, a starting value (typically the
--     left identity of the operator), and a list, reduces the list using
--     the binary operator, from left to right:
-- 
--     > fold f z [x1, x2, ..., xn] = (((z `f` x1) `f` x2) `f` ...) `f` xn
-- 
--     Because the operator is applied lazily, 'foldl' typically builds up
--     large thunks which, when finally evaluated, may overflow the stack space.
--     Therefore, the use of 'fold' instead of 'foldl' is strongly suggested.
-- 
--     This function exists merely for compatibility with Haskell.
-- 
--      
foldl :: (b->a->b) -> b -> [a] -> b

-- |     'foldl1' is a variant of 'fold' that has no starting value argument
--     and thus must be applied to nonempty lists only.
--          
foldl1 :: (a->a->a) -> [a] -> a

-- |     Fold over a list from right to left.
--     > foldr f a (x1:x2:x3:[])
--     is the same as
--     > x1 `f` (x2 `f` (x3 `f` a))
--     Note that, if _f_ is strict in the second argument,
--     @foldr f@ will need stack space proportional
--     to the length of the list.
--     But if _f_ is lazy in it's second argument, 'foldr' works on infinite lists.
-- 
--     If _f_ is commutative, the list finite and laziness not an issue,
--     'fold' may be the better choice since it runs with constant stack space.
--     Otherwise, if _f_ is not commutative, 'foldrs' will trade time and heap space for
--     stack space by 'fold'ing the 'flip'ped _f_ over the 'reverse'd list.
--          
foldr :: (a->b->b) -> b -> [a] -> b

-- |  'foldr1' is a variant of 'foldr' that has no starting argument, and thus must be applied to a non-empty list    
foldr1 :: (a->a->a) -> [a] -> a

-- |     This function may be used in place of
--     > foldr f z xs
--     if _f_ is strict in its right operand and _xs_ is a finite list,
--     in cases where 'foldr' exceeds the stack size, which is usually quite limited in
--     the JVM.
-- 
--     'foldrs' will need extra CPU cycles and maybe (temporary) heap space for
--     'reverse'-ing its list argument, before 'fold'ing the 'flip'ped _f_ over it.
-- 
--     If _f_ is commutative, you may simply use 'fold' instead.
-- 
--     The following property holds for all finite lists _xs_:
--     > foldr f z xs == foldrs f z xs
--          
foldrs :: (b->a->a) -> a -> [b] -> a

-- |  The first element of a list-view, or 'undefined' if 'empty'   
head :: ListView α => α β -> β

-- |  Returns all but the last element from a list.   
-- 
--  The following property holds for all non-empty finite lists /xs/:   
-- 
--  > init xs ++ [last xs] == xs   
init :: [a] -> [a]

-- |     @intersperse a xs@ inserts _a_ between every two elements of _xs_
--     > intersperse 0 (1..3) == [1,0,2,0,3]
--          
intersperse :: a -> [a] -> [a]

-- |     @iterate f a@ builds the infinite list @[a, f a, f (f a), ...]@
--          
iterate :: (a->a) -> a -> [a]

-- |  Returns the last element of a list by taking the 'head' of the 'reverse'd list.   
-- 
--  See also 'init'   
last :: [a] -> a

-- |  computes the length of the container in a type dependent way   
length :: ListView α => α β -> Int

-- |     @map f xs@ applies _f_ to each element of _xs_ and builds a new list from the results.
-- 
--     Usage of 'map' is safe on infinite lists, it delivers the result list one by
--     one as it is demanded.
--          
map :: (b->a) -> [b] -> [a]

-- |  The maximal value of a non empty list, same as ('foldl1' 'max')    
maximum :: Ord a => [a] -> a

-- |  The minimal value of a non empty list, same as ('foldl1' 'min')    
minimum :: Ord a => [a] -> a

-- |  opposite of 'elem'   
notElem :: Eq a => a -> [a] -> Bool

-- |  *true* if and only if the container is 'empty'   
null :: ListEmpty α => α β -> Bool

-- |     'or' returns the disjunction of a Boolean list. 
--     For the result to be *false*, the list must be finite; *true*,
--     however, results from a *true* value at a finite index of a finite or infinite list.
--          
or :: [Bool] -> Bool

-- |     convert a list of characters to a string
--     > packed ['a', 'b', 'c' ] == "abc"
--     Not very efficient, may be replaced by a java function that does it with a
--     string buffer later.
--          
packed :: [Char] -> String

-- |  The product of the numbers in a list, same as ('fold' ('*') 'one')   
product :: Num a => [a] -> a

-- |     @repeat a@ builds an infinite list where all elements are _a_.
--          
repeat :: a -> [a]


replicate :: Int -> a -> [a]

-- |     reverses a list
--          
reverse :: [a] -> [a]

-- |     'scanl' is similar to 'fold' but returns a list of successive
--     reduced values from the left:
--     > scanl f z [x1, x2, ...] = [z, z `f` x1, (z `f` x1) `f` x2, ... ]
--     The following property holds for all finite lists _xs_:
--     > last (scanl f z xs) == fold f z xs
--     In contrast to 'fold', 'scanl' can operate on infinite lists.
--           
scanl :: (a->b->a) -> a -> [b] -> [a]

-- |     'scanl1' is similar to 'scanl', but takes the 'head' of the list as
--     starting element and is thus only applicable to non-empty lists.
--     > scanl1 f [x1, x2, ...] = [x1, x1 `f` x2, (x1 `f` x2) `f` ...]
--          
scanl1 :: (a->a->a) -> [a] -> [a]

-- |  'scanr' is the right-to-left dual of 'scanl'.   
-- 
--  Note that   
-- 
--  > head (scanr f z xs) == foldr f z xs.   
scanr :: (α -> β -> β) -> β -> [α] -> [β]

-- |  'scanr1' is a variant of 'scanr' that has no starting value argument.   
scanr1 :: (a->a->a) -> [a] -> [a]

-- |     @span p xs@ returns a tuple whose first element is the longest prefix of _xs_
--     elements that satisfy _p_ and whose second element is the remainder of the list.
-- 
--     > span p xs == (takeWhile p xs, dropWhile p xs)
--          
span :: (a->Bool) -> [a] -> ([a],[a])

-- |     @splitAt n xs@ returns a tuple where first element is _xs_ prefix of length _n_ 
--     and the second element is the
--     remainder of the list.
--      
splitAt :: ListView a => Int -> a b -> (a b,a b)

-- |     @strhead s n@ returns the initial portion of s with at most n characters.
--     if s.'length' is lower than n, only so much characters are returned.
--          
strhead :: StringJ a -> Int -> StringJ a

-- |  The sum of the numbers in a list, same as ('fold' ('+') 'zero')   
sum :: Num a => [a] -> a

-- |  The tail of a list-view, or 'undefined' if 'empty'   
tail :: ListView α => α β -> α β

-- |  take a number of initial elements   
take :: ListView α => Int -> α β -> α β

-- |     @takeWhile p xs@ takes leading elements from /xs/ while they satisfy the predicate /p/.
-- 
--     Example:
--     > takeWhile (<7) [1,2,3,9,4] == [1,2,3]
--          
takeWhile :: (a->Bool) -> [a] -> [a]

-- |  converts the value to a list   
toList :: ListSource α => α β -> [β]

-- |  split the input stream in head and tail   
uncons :: ListView α => α β -> Maybe (β,α β)

-- |  Eagerly converts a 'String' to a list.   
unpacked :: String -> [Char]

-- |     'unzip' turns a list of tuples into a tuple of lists.
--     It is the opposite of 'zip' and the following holds for genuine lists
--     > (curry zip @ unzip) xs == xs
--     But note that
--     > (unzip @ curry zip) (as, bs) == (as,bs)
--     will only hold if @length as == length bs@
--          
unzip :: [(b,a)] -> ([b],[a])

-- |  'unzip3' unzips a list of triples and returns a triple of lists.   
unzip3 :: [(c,b,a)] -> ([c],[b],[a])

-- |     @zip as bs@ builds a list of tuples of corresponding elements of /as/ and /bs/.
--     Trailing elements of the longer list are ignored.
--     > zip (1,2,3) "ab" = [(1, "a"), (2, "b")]
--          
zip :: [b] -> [a] -> [(b,a)]

-- |  'zip3' zips 3 lists in the same way as 'zip' does it.   
zip3 :: [c] -> [b] -> [a] -> [(c,b,a)]

-- |     @zipWith f xs ys@ zips two lists with function _f_ instead of the standard '(,)' that
--     is used by 'zip'
--          
zipWith :: (b->c->a) -> [b] -> [c] -> [a]

-- |  'zipWith3' _f_ zips 3 lists with function _f_ instead of the standard '(,,)' that is used by 'zip3'   
zipWith3 :: (a->b->d->c) -> [a] -> [b] -> [d] -> [c]



-- |     This package provides the 'Monad' class and related classes and functions.
--     
--     The class hierarchy is derived from the (Haskell) proposal *The Other Prelude*
--     but the traditional method names have been kept.
--     
--     The functions in this library use the following naming conventions:
--     - A postfix "M"" always stands for a function in the Kleisli category: The monad type constructor _m_ is
--       added to function results (modulo currying) and nowhere else. So, for example,
--     > filter ::               (a -> Bool)   -> [a] -> [a]
--     > filterM :: (Monad m) => (a -> m Bool) -> [a] -> m [a]
--     - A postfix "_" changes the result type from (_m a_) to (_m ()_). Thus, for example:
--     > sequence  :: Monad m => [m a] -> m [a]
--     > sequence_ :: Monad m => [m a] -> m ()
--     - A prefix "m" generalizes an existing function to a monadic form. Thus, for example:
--     > sum :: Num a => [a] -> a
--     > msum :: MonadPlus m => [m a] -> m a    
--     
--     This package is _implementation specific_ insofar as the compiler may
--     assume that certain items are defined here in a certain way.
--     Changes may thus lead to compiler crashes or java code that 
--     will be rejected by the java compiler.
--     
--     In particular, desugared *@do@* expressions will reference 'Monad', '>>=' and '>>'.
--     
--     This package is implicitly imported and besides the additional stuff covers most of what
--     one would get by importing _Control.Monad_ and _Control.Applicative_ in Haskell.
--       
module frege.prelude.PreludeMonad
-- |  Sequence actions, discarding the value of the first argument.   
(*>) :: Applicative p => p a -> p b -> p b

-- |  An infix synonym for 'fmap'. Left associative with precedence 4.   
(<$>) :: Functor f => (a -> b) -> f a -> f b

-- |  Sequence actions, discarding the value of the second argument.   
(<*) :: Applicative p => p a -> p b -> p a


(<*>) :: Apply f => f (a->b) -> f a -> f b


(<+>) :: MonadAlt f => f a -> f a -> f a

-- |  Right-to-left Kleisli composition of monads. ('>=>'), with the arguments flipped   
(<=<) :: Bind d => (c->d b) -> (a->d c) -> a -> d b


(<|>) :: Alt f => f a -> f a -> f a

-- |  '=<<' is the same as '>>=' with the arguments flipped       
(=<<) :: Bind b => (a->b c) -> b a -> b c

-- |  left to right Kleisli composition of monads   
(>=>) :: Bind d => (a->d b) -> (b->d c) -> a -> d c

-- |         Sequentially compose two actions, discarding any value produced by the first, 
--         this works like sequencing operators (such as the semicolon) in imperative languages.
--              
(>>) :: Monad m => m a -> m b -> m b

-- |  Sequentially compose two actions, passing any value produced by the first as an argument to the second.   
(>>=) :: Bind f => f a -> (a -> f b) -> f b


class Alt

-- |     A functor with application, providing operations to
-- 
--     - embed pure expressions ('pure'), and
--     - sequence computations and combine their results ('<*>').
-- 
--     A minimal complete definition must include implementations of these
--     functions satisfying the following laws:
-- 
--     [_identity_]
--         @pure id <*> v = v@
-- 
--     [_composition_]
--         @pure (•) <*> u <*> v <*> w = u <*> (v <*> w)@
-- 
--     [_homomorphism_]
--         @pure f <*> pure x = pure (f x)@
-- 
--     [_interchange_]
--         @u <*> pure y = pure ($ y) <*> u@
--   
--     The other methods have the following default definitions, which may
--     be overridden with equivalent specialized implementations:
-- 
--     >  u *> v = pure (const id)  <*> u <*> v
--     >  u <* v = pure const <*> u <*> v
-- 
--     As a consequence of these laws, the 'Functor' instance for @f@ will satisfy
--     > fmap f x = pure f <*> x
-- 
-- 
--     If @f@ is also a 'Monad', it should satisfy 
--     > (<*>) = ap 
--     (which implies that 'pure' and '<*>' satisfy the
--     applicative functor laws).
--     
--     Minimal complete definition: 'pure' and '<*>'.
--          
class Applicative


instance Applicative (-> a)


class Apply


class Bind

-- |     The 'Functor' class is used for types that can be mapped over. 
--     Instances of 'Functor' should satisfy the following laws:
--     > fmap id == id
--     > fmap (f . g) == fmap f . fmap g
--          
class Functor


instance Functor (a)


instance Functor (a,b)


instance Functor []

-- |     The 'Monad' class defines the basic operations over a _monad_, 
--     a concept from a branch of mathematics known as _category theory_. 
--     From the perspective of a Frege programmer, however, it is best to think
--     of a monad as an _abstract datatype_ of actions. 
-- 
--     Frege’s *@do@* expressions provide a convenient syntax for writing monadic expressions.
-- 
--     Instances of Monad should satisfy the following laws:
-- 
--     > return a >>= k == k a
--     > m >>= return == m
--     > m >>= (\x -> k x >>= h) == (m >>= k) >>= h
-- 
--     Since instances of 'Monad' are also instances of 'Functor', 
--     they additionally shall satisfy the law:
-- 
--     > fmap f xs == xs >>= return • f
--     
--     which is also the default implementation of 'fmap'.
--     
--     The instances of 'Monad' for lists, 'Maybe' and 'ST' defined in the Prelude
--     satisfy these laws.
--     
--     Minimal complete definition: '>>=' and ('pure' or 'return')
--     
--          
class Monad


instance Monad (-> a)


instance Monad (Either left)


instance Monad (ST s)


instance Monad []


class MonadAlt

-- |     The 'MonadFail' class augments 'Monad' by adding the 'fail' operation.
--     This operation is not part of the mathematical definition of a monad.
--          
class MonadFail


instance MonadFail (Either String)


instance MonadFail (ST s)


instance MonadFail []


class MonadOr

-- |     A 'Monad' that also supports choice and failure
--     and observes the following laws:
--     > mzero `mplus`  v = v
--     > v `mplus` mzero  = v
--     > (a `mplus` b) `mplus` c = a `mplus` (b `mplus` c)
--     > (a `mplus` b) >>= f = (a >>= f) `mplus` (b >>= f)
--          
class MonadPlus


instance MonadPlus []

-- |     A 'Monad' with a left identity.
--          
class MonadZero


class Plus


type Reader = ->

-- |     In many situations, the 'liftM' operations can be replaced by uses of
--     'ap', which promotes function application. 
-- 
--     >       return f `ap` x1 `ap` ... `ap` xn
-- 
--     is equivalent to 
-- 
--     >       liftMn f x1 x2 ... xn
--      
ap :: Monad α => α (γ->β) -> α γ -> α β


apply :: Apply p => p (a->b) -> p a -> p b

-- |  Fail with a message.    
fail :: MonadFail m => String -> m a

-- |  'filterM' generalizes the list-based 'filter' function.   
filterM :: Monad a => (b->a Bool) -> [b] -> a [b]

-- |  Map a function over a 'Functor'   
fmap :: Functor f => (a -> b) -> f a -> f b

-- |  @foldM f a xs@ folds a monadic function _f_ over the list _xs_.   
foldM :: Monad a => (b->c->a b) -> b -> [c] -> a b

-- |  @foldM_@ is the same as 'foldM', but discards the result   
foldM_ :: Monad b => (c->a->b c) -> c -> [a] -> b ()

-- |  @for listSource f@ is a Java-friendly alias for @forM_@ that works on any list source   
for :: (Monad m,ListSource listSource) => listSource e -> (e -> m a) -> m ()

-- |  @forM xs f@ = @mapM_ f xs@    
forM :: Monad b => [a] -> (a->b c) -> b [c]


forM_ :: Monad a => [b] -> (b->a c) -> a ()

-- |  nowarn: deep recursion possible   
-- 
--  repeat action forever   
forever :: Monad a => a c -> a b

-- |   @guard b@ is @return ()@ if @b@ is *@true@*, and 'mzero' otherwise.   
guard :: MonadZero a => Bool -> a ()

-- |         The 'join' function is the conventional monad *join* operator. 
--         It is used to remove one level of monadic structure, projecting its bound argument into the outer level.
--              
join :: Monad m => m (m a) -> m a


liftA :: Applicative f => (a -> b) -> f a -> f b


liftA2 :: Applicative f => (a -> b -> c) -> f a -> f b -> f c


liftA3 :: Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d


liftA4 :: Applicative f => (a -> b -> c -> d -> e) -> f a -> f b -> f c -> f d -> f e


liftA5 :: Applicative f => (a -> b -> c -> d -> e -> g) -> f a -> f b -> f c -> f d -> f e -> f g

-- |  Promote a function to a monad.   
liftM :: Monad m => (a -> b) -> m a -> m b

-- |  Promote a function to a monad, scanning the monadic arguments from left to right.  For example,   
-- 
--  >    liftM2 (+) [0,1] [0,2] = [0,2,1,3]   
-- 
--  >    liftM2 (+) (Just 1) Nothing = Nothing   
liftM2 :: Monad b => (d->c->a) -> b d -> b c -> b a

-- |  Promote a function to a monad, scanning the monadic arguments from left to right (cf. 'liftM2').   
liftM3 :: Monad d => (c->a->b->e) -> d c -> d a -> d b -> d e

-- |  Promote a function to a monad, scanning the monadic arguments from left to right (cf. 'liftM2').   
liftM4 :: Monad a => (e->f->c->d->b) -> a e -> a f -> a c -> a d -> a b

-- |  Promote a function to a monad, scanning the monadic arguments from left to right (cf. 'liftM2').   
liftM5 :: Monad g => (a->b->d->e->c->f) -> g a -> g b -> g d -> g e -> g c -> g f

-- |     The 'mapAndUnzipM' function maps its first argument over a list, returning
--     the result as a pair of lists. This function is mainly used with complicated
--     data structures or a state-transforming monad.
--          
mapAndUnzipM :: Monad a => (b->a (d,c)) -> [b] -> a ([d],[c])

-- |  @mapM f@ is equivalent to @sequence • map f@   
mapM :: Monad b => (c->b a) -> [c] -> b [a]

-- |  @mapM_ f@ is equivalent to @sequence_ • map f@   
mapM_ :: Monad b => (c->b a) -> [c] -> b ()


mapReader :: (a -> b) -> (r -> a) -> r -> b

-- |  an associative operation   
mplus :: MonadPlus mp => mp a -> mp a -> mp a

-- |  'msum' generalizes the list-based 'concat' function.   
msum :: MonadPlus a => [a b] -> a b

-- |  This value should satisfy _left zero_:    
-- 
--  > mzero >>= f = mzero   
mzero :: MonadZero mz => mz a


orElse :: MonadOr mo => mo a -> mo a -> mo a

-- |  Lift a value   
pure :: Applicative p => a -> p a


pzero :: Plus f => f a

-- |  @replicateM n act@ performs the action @n@ times, gathering the results.   
replicateM :: Monad m => Int -> m a -> m [a]

-- |  Like 'replicateM', but discards the result.   
replicateM_ :: Monad m => Int -> m a -> m ()

-- |         Inject a value into the 'Monad'. This is the same as 'pure'.
--              
return :: Monad m => a -> m a


runReader :: (r -> a) -> r -> a

-- |     Turn a list of monadic values @[m a]@ into a monadic value with a list @m [a]@
--     > sequence [Just 1, Just 3, Just 2] = Just [1,2,3]
--     This version of 'sequence' runs in constant stack space,
--     but needs heap space proportional to the size of the input list.
--          
sequence :: Monad b => [b a] -> b [a]

-- |  fold ('>>') over a list of monadic values for side effects      
sequence_ :: Monad a => [a b] -> a ()

-- |  Version of 'filterM' that works on small lists with length < 1000 only.   
-- 
--  Beware of stack overflow, and use 'filterM', when in doubt.   
shortFilterM :: Monad a => (b->a Bool) -> [b] -> a [b]

-- |  'shortFoldM' is suitable only for lists with a length way below 1000.   
-- 
--  Beware of stack overflow and use 'foldM' instead.   
shortFoldM :: Monad b => (c->a->b c) -> c -> [a] -> b c

-- |     A version of 'sequence' that uses the stack and may overflow
--     with longer lists. 
--     
--     A length of about 500 should be ok in most cases.
--          
shortSequence :: Monad a => [a b] -> a [b]

-- |  opposite of 'when'      
unless :: Monad a => Bool -> a () -> a ()

-- |  discard or ignore result of evaluation, such as the return value of an 'IO' action.   
void :: Functor a => a b -> a ()

-- |     @when condition monadic@ returns /action/ of type @Monad m => m ()@
--     if /condition/ is true, otherwise 'return' '()'.
--      
when :: Monad a => Bool -> a () -> a ()


withReader :: (e -> r) -> (r -> a) -> e -> a

-- |  The 'zipWithM' function generalizes 'zipWith' to arbitrary monads.   
zipWithM :: Monad c => (a->b->c d) -> [a] -> [b] -> c [d]

-- |  'zipWithM_' is the extension of 'zipWithM' which ignores the final result.   
zipWithM_ :: Monad d => (b->a->d c) -> [b] -> [a] -> d ()



-- |     Classes and Instances to convert values to 'String's ('show') and 'String's to values
--     ("read").
-- 
--     There are a few differences to Haskell, notably
-- 
--     - "Read" cannot be derived and supports only simple types
--      
module frege.prelude.PreludeText

instance (Show a,Show b) => Show (a | b)


instance (Show a,Show b) => Show (a,b)


instance (Show a,Show b,Show c) => Show (a,b,c)

-- |  Haskell compatibility   
type ReadS = StringJ Char -> [(a,StringJ Char)]

-- |  * Class 'Show' provides operations to convert values to 'String's.
-- 
--  * This class can be derived for all algebraic data types whose constituents
--  * are themselves instances of 'Show'.
--       
class Show


instance Show ()


instance Show Bool


instance Show Byte


instance Show Char


instance Show Double


instance Show Float


instance Show Int


instance Show Integer


instance Show Long


instance Show Ordering


instance Show Regex


instance Show Short


instance Show String


instance Show Throwable


instance Show a => Show (Maybe a)


instance Show a => Show [a]

-- |  Haskell compatibility   
type ShowS = StringJ Char -> StringJ Char

-- |  strip trailing spaces, tabs, newline and carriage return characters from a string   
chomp :: String -> String

-- |      'display' computes an alternate string representation of a value and is
--      used in the 'Char' and 'String' instances of 'Show' to produce an unquoted string.
-- 
--      The default implementation is to do the same as 'show'.
--           
display :: Show show => show -> String

-- |   @joined sep xs@ concatenates all strings in /xs/,
--   and inserts /sep/ between any two elements of /xs/.
-- 
--   If /xs/ is empty, the result is an empty string. If /sep/ is an empty string,
--   then the result is just the concatenation of the strings in /xs/.
-- 
--   Example:
--   > joined ", " ["aaa", "bbb", "ccc"] == "aaa, bbb, ccc"
--       
joined :: String -> [String] -> String

-- |  The line separator suitable for the platform the program is running on.   
lineSeparator :: String

-- |  splits a 'String' on end-of-line  and returns a list of 'String's   
-- 
--  The last line may or may not be terminated by newline.   
-- 
--  End-of-line is signaled by a number of carriage returns followed by a new line.   
-- 
--  This should work for UNIX and Windows.   
lines :: String -> [String]

-- |     convert a list of characters to a string
--     > packed ['a', 'b', 'c' ] == "abc"
--          
packed :: [Char] -> String

-- |  Computes the string representation of a value.   
-- 
--  Every instance must implement 'show'.   
show :: Show show => show -> String

-- |  Haskell compatibility   
showChar :: Char -> String -> String

-- |         'showChars' addresses the problem of 'show'ing infinite values.
--         Because 'show' has type 'String' and 'String' is atomic, this would
--         try to create a string with infinite length, and hence is doomed to fail.
--         
--         The default definition is
--         
--         > showChars = String.toList . show
--         
--         This is ok for all finite values. But instances for recursive types
--         should implement it in a way that produces a lazy list of characters.
--         
--         Here is an example for the list instance:
--         
--         > showChars [] = ['[', ']']
--         > showChars xs = '[' : ( tail [ c | x <- xs, c <- ',' : showChars x ] ++ [']'] )
--         
--          
showChars :: Show show => show -> [Char]

-- |  Haskell compatibility   
showList :: Show show => [show] -> String -> String

-- |  Haskell compatibility   
showParen :: Bool -> (String -> String) -> String -> String

-- |  Haskell compatibility   
showString :: String -> String -> String

-- |  Haskell compatibility   
shows :: Show a => a -> String -> String

-- |  Haskell compatibility   
showsPrec :: Show show => Int -> show -> String -> String

-- |      * 'showsub' is used for 'show'ing elements of a value of an algebraic data type
--      * in derived instances of 'Show'.
--      *
--      * The generated code in derived instances for types that are not
--      * enumerations is
--      * > showsub x = "(" ++ show x ++ ")"
--      * so that values are enclosed in parentheses.
--      * Certain types like records, lists, tuples and many primitive types do not need
--      * extra parentheses, and thus 'showsub' is the same as 'show', which is also the
--      * default implementation.
--      *
--      * In short,
--      * - in derived instances, 'showsub' will do the right thing.
--      * - in all other instances, 'showsub' will do the same as 'show' if not
--      *   implemented differently.
--      *
--      * Example:
--      * > derive Show ( Maybe b)
--      * implements the following:
--      * > show Nothing = "Nothing"
--      * > show (Just x) = "Just " ++ x.showsub
--      * > showsub x = "(" ++ show x ++ ")"
--      * so that
--      * > show (Just (Just 42)) == "Just (Just 42)"
--      *
--           
showsub :: Show show => show -> String

-- |  'unlines' is an inverse operation to 'lines'.   
-- 
--   It joins lines, after appending a terminating newline to each.   
unlines :: [String] -> String

-- |  'unwords' is an inverse operation to 'words'.   
-- 
--  It joins words with separating spaces.   
unwords :: [String] -> String

-- |  splits a 'String' on non empty sequences of spaces  and returns a list of 'String's   
words :: String -> [String]



-- | 
module frege.run.Func1


-- | 
module frege.run.Func10


-- | 
module frege.run.Func11


-- | 
module frege.run.Func12


-- | 
module frege.run.Func13


-- | 
module frege.run.Func14


-- | 
module frege.run.Func15


-- | 
module frege.run.Func16


-- | 
module frege.run.Func17


-- | 
module frege.run.Func18


-- | 
module frege.run.Func19


-- | 
module frege.run.Func2


-- | 
module frege.run.Func20


-- | 
module frege.run.Func21


-- | 
module frege.run.Func22


-- | 
module frege.run.Func23


-- | 
module frege.run.Func24


-- | 
module frege.run.Func25


-- | 
module frege.run.Func26


-- | 
module frege.run.Func3


-- | 
module frege.run.Func4


-- | 
module frege.run.Func5


-- | 
module frege.run.Func6


-- | 
module frege.run.Func7


-- | 
module frege.run.Func8


-- | 
module frege.run.Func9


-- | 
module frege.run.Function


-- | 
module frege.run.Lazy


-- | 
module frege.run.Thunk


-- |     This package provides compatible definitions for Haskell 2010's
--     System.Environment but mostly they do not translate to a Java
--     environment.
-- 
--     getEnv can be made to work once it is wired into how main is
--     executed (it's currently a stub and will be updated after Ingo
--     has completed a rewrite of main / runMain).
-- 
--     getProgName really has no equivalent in the Java world since
--     it is based on the UNIX idea of an executable name or the
--     symbolic link to an executable. For now it arbitrarily returns
--     an empty string (returning "java" or "java.exe" would be just
--     as (in)accurate).
-- 
--     getEnv is specified to fail with System.IO.Error.isDoesNotExistError
--     if no such environment variable exists, but Frege uses Java
--     exceptions so instead we throw an IllegalArgumentException.
--     Using the underlying (Java) System.getenv is recommended
--     since that returns Maybe String instead
-- -     
module frege.system.Environment

getArgs :: IO [String]


getEnv :: String -> IO String


getProgName :: IO String



-- |     This package provides compatible definitions for Haskell 2010's
--     System.Exit by delegating to Java's System.exit function.
-- 
--     Note that we do not raise an error for attempting to exitWith an
--     ExitFailure 0 value (like GHC's System.Exit library does). That
--     seems a rather arbitrary / unnecessary restriction although we
--     could throw an IllegalArgumentException for it (which still would
--     not be entirely compatible with Haskell anyway).
-- -     
module frege.system.Exit

instance Eq Exit.ExitCode

-- |  we rely default Eq, Ord, Show implementations - there is no Read yet   
data ExitCode


ExitFailure :: Int -> Exit.ExitCode


ExitSuccess :: Exit.ExitCode


instance Ord Exit.ExitCode


instance Show Exit.ExitCode

-- |  exitFail is arbitrarily 1 to indicate a failing exit   
exitFailure :: IO a


exitSuccess :: IO a


exitWith :: Exit.ExitCode -> IO a



-- |     This module deals with the common task of pseudo-random number generation.
--     
--     It is possible to generate repeatable results, 
--     by starting with a specified initial random number,
--     or to get different results on each run by using a generator that
--     gets seeded in a system-dependend random way, or by supplying a seed
--     from some other source.
--     
--     In Frege, the underlying mechanism for actually generating random
--     numbers is provided by 'J.Random'. Consequently,
--     one cannot expect that a random generator seeded with a certain value
--     will generate the same sequence of random numbers as its 
--     Haskell counterpart.
--       
--      
module frege.system.Random

class Random


instance Random.Random Bool


instance Random.Random Double


instance Random.Random Float


instance Random.Random Int


instance Random.Random Integer


instance Random.Random Long

-- |     The 'StdGen' instance of 'RandomGen' delegates random number generation
--     to an instance of 'J.Random'.
--          
instance Random.RandomGen Random.StdGen

-- |  The class 'RandomGen' provides a common interface to random number generators.   
class RandomGen

-- |  Standard random number generator   
data StdGen

-- |         Gives the full range of the random generator, which must not depend
--         on the state of the generator, but only on its type.
--         
--         The default definition is ('Int.minBound', 'Int.maxBound')
--          
genRange :: Random.RandomGen g => g -> (Int,Int)

-- |  The global random generator.   
getStdGen :: IO Random.StdGen


getStdRandom :: (Random.StdGen->(b,a)) -> IO b

-- |  Make an initial generator based on an 'Int' seed.   
mkStdGen :: Int -> Random.StdGen

-- |     Applies 'split' to the current global random generator, 
--     updates it with one of the results, and returns the other.
--          
newStdGen :: IO Random.StdGen

-- |         The next operation returns an Int that is uniformly distributed 
--         in the range returned by genRange (including both end points), 
--         and a new generator. 
--          
next :: Random.RandomGen g => g -> (Int,g)

-- |  Returns an uniformly distributed 'Bool' and a new generator.   
nextBool :: Random.RandomGen g => g -> (Bool,g)

-- |  Returns a random 'Double' _d_ with @0<=d<1@ and a new generator.   
nextDouble :: Random.RandomGen g => g -> (Double,g)

-- |  Returns an uniformly distributed 'Long' and a new generator.   
nextLong :: Random.RandomGen g => g -> (Long,g)

-- |  a random value   
random :: (Random.Random r,Random.RandomGen g) => g -> (r,g)

-- |  a random value from the global generator   
randomIO :: Random.Random r => IO r

-- |  a random value in the given bounds   
randomR :: (Random.Random r,Random.RandomGen g) => (r,r) -> g -> (r,g)

-- |  a random value in the given bounds from the global generator   
randomRIO :: Random.Random r => (r,r) -> IO r

-- |  a list of random values in the given bound   
randomRs :: (Random.Random r,Random.RandomGen g) => (r,r) -> g -> [r]

-- |  a list of random values               
randoms :: (Random.Random r,Random.RandomGen g) => g -> [r]

-- |  set the global random number generator   
setStdGen :: Random.StdGen -> IO ()

-- |         The split operation allows one to obtain two distinct random number generators. 
--         This is very useful in functional programs (for example, 
--         when passing a random number generator down to recursive calls), 
--         but very little work has been done on statistically robust implementations. 
--          
split :: Random.RandomGen g => g -> (g,g)



-- |  Public interface for the quick check modules   
module frege.test.QuickCheck
-- |  Conjunction: @p1 .&&. p2@ passes if both @p1@ and @p2@ pass.   
(.&&.) :: (QuickCheckProperty.Testable prop1,QuickCheckProperty.Testable prop2) => prop1 -> prop2 -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |     Nondeterministic choice: @p1 .&. p2@ picks randomly one of
--     @p1@ and @p2@ to test. If you test the property 100 times it
--     makes 100 random choices.
--          
(.&.) :: (QuickCheckProperty.Testable prop1,QuickCheckProperty.Testable prop2) => prop1 -> prop2 -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  Disjunction: @p1 .||. p2@ passes unless @p1@ and @p2@ simultaneously fail.   
(.||.) :: (QuickCheckProperty.Testable prop1,QuickCheckProperty.Testable prop2) => prop1 -> prop2 -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |     Implication for properties: The resulting property holds if
--     the first argument is @false@ (in which case the test case is discarded),
--     or if the given property holds.      
(==>) :: QuickCheckProperty.Testable prop => Bool -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


(><) :: (QuickCheckGen.Gen a -> QuickCheckGen.Gen a) -> (QuickCheckGen.Gen a -> QuickCheckGen.Gen a) -> QuickCheckGen.Gen a -> QuickCheckGen.Gen a


type AnException = Exception


instance Applicative_Gen

-- |  class Arbitrary   
-- 
--  Random generation and shrinking of values.   
-- 
--  Minimal complete definition: 'arbitrary'   
class Arbitrary


instance Arbitrary_()


instance Arbitrary_(,)


instance Arbitrary_(,,)


instance Arbitrary_(,,,)


instance Arbitrary_(,,,,)


instance Arbitrary_->


instance Arbitrary_Blind


instance Arbitrary_Bool


instance Arbitrary_Byte


instance Arbitrary_Char


instance Arbitrary_Double


instance Arbitrary_Either


instance Arbitrary_Fixed


instance Arbitrary_Float


instance Arbitrary_Int


instance Arbitrary_Integer


instance Arbitrary_JArray


instance Arbitrary_Long


instance Arbitrary_Maybe


instance Arbitrary_NonEmptyList


instance Arbitrary_NonNegative


instance Arbitrary_NonZero


instance Arbitrary_OrderedList


instance Arbitrary_Ordering


instance Arbitrary_Positive


instance Arbitrary_Short


instance Arbitrary_Shrink2


instance Arbitrary_Smart


instance Arbitrary_String


instance Arbitrary_TreeMap


instance Arbitrary_[]

-- | -----------------------------------------------------------------------   
data Args

-- |  @Blind x@: as x, but x does not have to be in the 'Show' class.   
data Blind


instance Bounded_Ordering

-- |  Different kinds of callbacks   
data Callback


data CallbackKind

-- |  CoArbitrary   
-- 
--  Used for random generation of functions.   
class CoArbitrary


instance CoArbitrary_()


instance CoArbitrary_(,)


instance CoArbitrary_(,,)


instance CoArbitrary_(,,,)


instance CoArbitrary_(,,,,)


instance CoArbitrary_->


instance CoArbitrary_Bool


instance CoArbitrary_Char


instance CoArbitrary_Double


instance CoArbitrary_Either


instance CoArbitrary_Float


instance CoArbitrary_Int


instance CoArbitrary_Integer


instance CoArbitrary_Long


instance CoArbitrary_Maybe


instance CoArbitrary_Ordering


instance CoArbitrary_String


instance CoArbitrary_TreeMap


instance CoArbitrary_[]


instance Eq_Blind


instance Eq_Fixed


instance Eq_NonEmptyList


instance Eq_NonNegative


instance Eq_NonZero


instance Eq_OrderedList


instance Eq_Positive


instance Eq_Shrink2

-- |  @Fixed x@: as x, but will not be shrunk.   
data Fixed


instance Functor_Gen


instance Functor_Rose

-- |  Generator type   
data Gen


type Handle = PrintWriter


instance Monad_Gen


instance Monad_Rose

-- |   @NonEmpty xs@: guarantees that xs is non-empty.   
data NonEmptyList

-- |  @NonNegative x@: guarantees that @x >= 0@.   
data NonNegative

-- |  @NonZero x@: guarantees that @x != 0@.   
data NonZero


instance Ord_Blind


instance Ord_Fixed


instance Ord_NonEmptyList


instance Ord_NonNegative


instance Ord_NonZero


instance Ord_OrderedList


instance Ord_Positive


instance Ord_Shrink2

-- |  @Ordered xs@: guarantees that xs is ordered.   
data OrderedList


data Output

-- |  @Positive x@: guarantees that @x > 0@.   
data Positive

-- | -----------------------------------------------------------------------   
data Prop

-- |  The things  quick check is testing   
type Property = QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  Result represents the test result   
data Result


data Rose


instance Show_Args


instance Show_Blind


instance Show_Fixed


instance Show_NonEmptyList


instance Show_NonNegative


instance Show_NonZero


instance Show_OrderedList


instance Show_Positive


instance Show_Result


instance Show_Shrink2


instance Show_Smart


instance Show_StdGen


instance Show_Str

-- |  @Shrink2 x@: allows 2 shrinking steps at the same time when shrinking x   
data Shrink2

-- |   @Smart _ x@: tries a different order when shrinking.   
data Smart

-- | -----------------------------------------------------------------------   
data Str


data Terminal

-- |  The class of things which can be tested, i.e. turned into a property.   
class Testable


instance Testable_->


instance Testable_Bool


instance Testable_Gen


instance Testable_Prop


instance Testable_Result

-- |  A generator for values of the given type.   
arbitrary :: QuickCheckArbitrary.Arbitrary a => QuickCheckGen.Gen a


arbitraryBoundedEnum :: (Bounded a,Enum a) => QuickCheckGen.Gen a


arbitraryBoundedIntegral :: (Bounded a,Integral a) => QuickCheckGen.Gen a

-- |  Generates an element of a bounded type. The element is chosen from the entire range of the type.   
arbitraryBoundedRandom :: (Bounded a,Random.Random a) => QuickCheckGen.Gen a


arbitrarySizedBoundedIntegral :: (Bounded a,Integral a) => QuickCheckGen.Gen a

-- |     Generates a fractional number. The number can be positive or negative
--     and its maximum absolute value depends on the size parameter.
--          
arbitrarySizedFloating :: Math.Floating a => QuickCheckGen.Gen a

-- |     Generates an integral number. The number can be positive or negative
--     and its maximum absolute value depends on the size parameter.
--          
arbitrarySizedIntegral :: Num a => QuickCheckGen.Gen a


bold :: String -> String

-- |   Adds a callback   
callback :: QuickCheckProperty.Testable prop => QuickCheckProperty.Callback -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


callbackPostFinalFailure :: QuickCheckState.State -> QuickCheckProperty.Result -> IO ()


callbackPostTest :: QuickCheckState.State -> QuickCheckProperty.Result -> IO ()

-- |  Generates a random element in the given inclusive range.   
choose :: Random.Random a => (a,a) -> QuickCheckGen.Gen a

-- |  Conditionally labels test case.   
classify :: QuickCheckProperty.Testable prop => Bool -> String -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |     Used to generate a function of type @a -> c@. The implementation
--     should use the first argument to perturb the random generator
--     given as the second argument. The returned generator
--     is then used to generate the function result.
--     
--     You can often use 'variant' and '><' to implement
--     'coarbitrary'.      
coarbitrary :: QuickCheckArbitrary.CoArbitrary a => a -> QuickCheckGen.Gen c -> QuickCheckGen.Gen c

-- |  A 'coarbitrary' implementation for enums.   
coarbitraryEnum :: Enum a => a -> QuickCheckGen.Gen b -> QuickCheckGen.Gen b


coarbitraryIntegral :: Integral a => a -> QuickCheckGen.Gen b -> QuickCheckGen.Gen b

-- |  'coarbitrary' helper for lazy people :-).   
coarbitraryShow :: Show a => a -> QuickCheckGen.Gen b -> QuickCheckGen.Gen b

-- |  Labels a property with a value:   
-- 
--  > collect x = label (show x)   
collect :: (Show a,QuickCheckProperty.Testable prop) => a -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  Take the conjunction of several properties.   
conjoin :: QuickCheckProperty.Testable prop => [prop] -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  Checks that at least the given proportion of the test cases belong to the given class.   
cover :: QuickCheckProperty.Testable prop => Bool -> Int -> String -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


discard :: a

-- |  Take the disjunction of several properties.   
disjoin :: QuickCheckProperty.Testable prop => [prop] -> QuickCheckGen.Gen QuickCheckProperty.Prop


doneTesting :: QuickCheckState.State -> (Random.StdGen -> Int -> QuickCheckProperty.Prop) -> IO QuickCheckTest.Result

-- |  Generates one of the given values. The input list must be non-empty.   
elements :: [a] -> QuickCheckGen.Gen a


exception :: String -> Exception -> QuickCheckProperty.Result


exhaustive :: QuickCheckProperty.Testable prop => prop -> Bool

-- |  Modifies a property so that it is expected to fail for some test cases.   
expectFailure :: QuickCheckProperty.Testable prop => prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


failed :: QuickCheckProperty.Result


flush :: QuickCheckText.Terminal -> IO ()

-- |     Explicit universal quantification: uses an explicitly given
--     test case generator.
--          
forAll :: (Show a,QuickCheckProperty.Testable prop) => QuickCheckGen.Gen a -> (a -> prop) -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  Like 'forAll', but tries to shrink the argument for failing test cases.   
forAllShrink :: (Show a,QuickCheckProperty.Testable prop) => QuickCheckGen.Gen a -> (a -> [a]) -> (a -> prop) -> QuickCheckGen.Gen QuickCheckProperty.Prop


formatException :: String -> Exception -> String

-- | -----------------------------------------------------------------------   
foundFailure :: QuickCheckState.State -> QuickCheckProperty.Result -> [QuickCheckProperty.Rose QuickCheckProperty.Result] -> IO Int

-- |  Chooses one of the given generators, with a weighted random distribution.
--     The input list must be non-empty.
--          
frequency :: [(Int,QuickCheckGen.Gen a)] -> QuickCheckGen.Gen a


get :: QuickCheckText.Output -> IO String


giveUp :: QuickCheckState.State -> (Random.StdGen -> Int -> QuickCheckProperty.Prop) -> IO QuickCheckTest.Result

-- |     Takes a list of elements of increasing size, and chooses
--     among an initial segment of the list. The size of this initial
--     segment increases with the size parameter.
--     The input list must be non-empty.      
growingElements :: [a] -> QuickCheckGen.Gen a


hFlush :: Flushable -> IO ()

-- |  print a 'String'   
hPutStr :: PrintWriter -> String -> IO ()


handle :: PrintWriter -> String -> IO ()


ioRose :: IO (QuickCheckProperty.Rose QuickCheckProperty.Result) -> QuickCheckProperty.Rose QuickCheckProperty.Result


isDigit :: ω


isDiscard :: Exception -> Bool


isInterrupt :: Exception -> Bool


isLower :: ω


isOneLine :: String -> Bool


isSpace :: ω

-- |  isSuccess checks if the test run result was a success   
isSuccess :: QuickCheckTest.Result -> Bool


isUpper :: ω


joinRose :: QuickCheckProperty.Rose (QuickCheckProperty.Rose a) -> QuickCheckProperty.Rose a


kurz :: Int -> String -> String

-- |  Attaches a label to a property.    
-- 
--  This is used for reporting test case distribution.   
label :: QuickCheckProperty.Testable prop => String -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


liftBool :: Bool -> QuickCheckProperty.Result

-- |  Generates a list of random length.    
-- 
--  The maximum length depends on the size parameter.   
listOf :: QuickCheckGen.Gen a -> QuickCheckGen.Gen [a]

-- |  Generates a non-empty list of random length.    
-- 
--  The maximum length depends on the size parameter.   
listOf1 :: QuickCheckGen.Gen a -> QuickCheckGen.Gen [a]


localMin :: QuickCheckState.State -> QuickCheckProperty.Result -> [QuickCheckProperty.Rose QuickCheckProperty.Result] -> IO Int


localMin' :: QuickCheckState.State -> QuickCheckProperty.Result -> [QuickCheckProperty.Rose QuickCheckProperty.Result] -> IO Int


localMinFound :: QuickCheckState.State -> QuickCheckProperty.Result -> IO Int


mapProp :: QuickCheckProperty.Testable prop => (QuickCheckProperty.Prop -> QuickCheckProperty.Prop) -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


mapResult :: QuickCheckProperty.Testable prop => (QuickCheckProperty.Result -> QuickCheckProperty.Result) -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


mapRoseResult :: QuickCheckProperty.Testable prop => (QuickCheckProperty.Rose QuickCheckProperty.Result -> QuickCheckProperty.Rose QuickCheckProperty.Result) -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  Changes the maximum test case size for a property.   
mapSize :: QuickCheckProperty.Testable prop => (Int -> Int) -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


mapTotalResult :: QuickCheckProperty.Testable prop => (QuickCheckProperty.Result -> QuickCheckProperty.Result) -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |     Do I/O inside a property. This can obviously lead to unrepeatable
--     testcases, so use with care.      
morallyDubiousIOProperty :: QuickCheckProperty.Testable prop => IO prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


newTerminal :: QuickCheckText.Output -> QuickCheckText.Output -> IO QuickCheckText.Terminal

-- |  Disables shrinking for a property altogether.   
noShrinking :: QuickCheckProperty.Testable prop => prop -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- | -----------------------------------------------------------------------   
number :: Int -> String -> String


onRose :: (a -> [QuickCheckProperty.Rose a] -> QuickCheckProperty.Rose a) -> QuickCheckProperty.Rose a -> QuickCheckProperty.Rose a

-- |  Modifies a property so that it only will be tested once.   
once :: QuickCheckProperty.Testable prop => prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


oneLine :: String -> String

-- |  Randomly uses one of the given generators. The input list must be non-empty.   
oneof :: [QuickCheckGen.Gen a] -> QuickCheckGen.Gen a

-- |   Generates an ordered list of a given length.   
orderedList :: (Ord a,QuickCheckArbitrary.Arbitrary a) => QuickCheckGen.Gen [a]


output :: (String -> IO ()) -> IO QuickCheckText.Output


postpone :: QuickCheckText.Terminal -> IO () -> IO ()

-- |  Prints a message to the terminal as part of the counterexample.   
printTestCase :: QuickCheckProperty.Testable prop => String -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  Promotes a monadic generator to a generator of monadic values.   
promote :: Monad m => m (QuickCheckGen.Gen a) -> QuickCheckGen.Gen (m a)


property :: QuickCheckProperty.Testable prop => prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


protect :: (Exception -> a) -> IO a -> IO a


protectResult :: IO QuickCheckProperty.Result -> IO QuickCheckProperty.Result

-- |  Wrap all the Results in a rose tree in exception handlers.   
protectResults :: QuickCheckProperty.Rose QuickCheckProperty.Result -> QuickCheckProperty.Rose QuickCheckProperty.Result

-- |  Wrap a rose tree in an exception handler.   
protectRose :: IO (QuickCheckProperty.Rose QuickCheckProperty.Result) -> IO (QuickCheckProperty.Rose QuickCheckProperty.Result)


put :: QuickCheckText.Output -> String -> IO ()


putLine :: QuickCheckText.Terminal -> String -> IO ()


putPart :: QuickCheckText.Terminal -> String -> IO ()


putTemp :: QuickCheckText.Terminal -> String -> IO ()

-- |  Tests a property and prints the results to 'stdout'.   
quickCheck :: QuickCheckProperty.Testable prop => prop -> IO ()

-- |  Tests a property, produces a test result, and prints the results to 'stdout'.   
quickCheckResult :: QuickCheckProperty.Testable prop => prop -> IO QuickCheckTest.Result

-- |  Tests a property, using test arguments, and prints the results to 'stdout'.   
quickCheckWith :: QuickCheckProperty.Testable prop => QuickCheckTest.Args -> prop -> IO ()

-- |  Tests a property, using test arguments, produces a test result, and prints the results to 'stdout'.   
quickCheckWithResult :: QuickCheckProperty.Testable prop => QuickCheckTest.Args -> prop -> IO QuickCheckTest.Result


ranges :: (Show a,Integral a) => a -> a -> QuickCheckText.Str


reduceRose :: QuickCheckProperty.Rose QuickCheckProperty.Result -> IO (QuickCheckProperty.Rose QuickCheckProperty.Result)


rejected :: QuickCheckProperty.Result

-- |     Overrides the size parameter. Returns a generator which uses
--     the given size instead of the runtime-size parameter.
--      
resize :: Int -> QuickCheckGen.Gen a -> QuickCheckGen.Gen a


result :: QuickCheckProperty.Result


runATest :: QuickCheckState.State -> (Random.StdGen -> Int -> QuickCheckProperty.Prop) -> IO QuickCheckTest.Result


safely :: QuickCheckState.State -> IO () -> IO ()

-- |  Generates some example values and prints them to 'stdout'.   
sample :: Show a => QuickCheckGen.Gen a -> IO ()

-- |  Generates some example values.   
sample' :: QuickCheckGen.Gen a -> IO [a]


showErr :: Show a => a -> String

-- |     Produces a (possibly) empty list of all the possible
--     immediate shrinks of the given value.      
shrink :: QuickCheckArbitrary.Arbitrary a => a -> [a]

-- |  Shrink a fraction.   
shrinkFloating :: Math.Floating a => a -> [a]

-- |  Shrink an integral number.   
shrinkIntegral :: Integral a => a -> [a]


shrinkList :: (a -> [a]) -> [a] -> [[a]]

-- |  Returns no shrinking alternatives.   
shrinkNothing :: a -> [a]

-- |     Shrinks the argument to property if it fails. Shrinking is done
--     automatically for most types. This is only needed when you want to
--     override the default behavior.      
shrinking :: QuickCheckProperty.Testable prop => (a -> [a]) -> a -> (a -> prop) -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  Used to construct generators that depend on the size parameter.   
sized :: (Int -> QuickCheckGen.Gen a) -> QuickCheckGen.Gen a

-- |  stdArgs are the default test arguments used   
stdArgs :: QuickCheckTest.Args


succeeded :: QuickCheckProperty.Result


success :: QuickCheckState.State -> IO ()

-- |  Generates a value that satisfies a predicate.   
suchThat :: QuickCheckGen.Gen a -> (a -> Bool) -> QuickCheckGen.Gen a

-- |  Tries to generate a value that satisfies a predicate.   
suchThatMaybe :: QuickCheckGen.Gen a -> (a -> Bool) -> QuickCheckGen.Gen (Maybe a)


summary :: QuickCheckState.State -> [(String,Int)]


terminalOutput :: QuickCheckText.Terminal -> IO String

-- | -----------------------------------------------------------------------   
test :: QuickCheckState.State -> (Random.StdGen -> Int -> QuickCheckProperty.Prop) -> IO QuickCheckTest.Result

-- |  The lowercase equivalent of the character, if any; otherwise, the character itself.   
toLower :: ω

-- | -----------------------------------------------------------------------   
tryEvaluate :: a -> IO (Exception | a)


tryEvaluateIO :: IO a -> IO (Exception | a)


variant :: Integral n => n -> QuickCheckGen.Gen a -> QuickCheckGen.Gen a

-- | -----------------------------------------------------------------------   
-- 
--  Generates a list of a given length.   
vector :: QuickCheckArbitrary.Arbitrary a => Int -> QuickCheckGen.Gen [a]

-- |  Generates a list of the given length.   
vectorOf :: Int -> QuickCheckGen.Gen a -> QuickCheckGen.Gen [a]

-- |      Prints out the generated testcase every time the property is tested,
--     like "verboseCheck" from QuickCheck 1.
--     Only variables quantified over _inside_ the 'verbose' are printed.      
verbose :: QuickCheckProperty.Testable prop => prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


verboseCheck :: QuickCheckProperty.Testable prop => prop -> IO ()


verboseCheckResult :: QuickCheckProperty.Testable prop => prop -> IO QuickCheckTest.Result


verboseCheckWith :: QuickCheckProperty.Testable prop => QuickCheckTest.Args -> prop -> IO ()


verboseCheckWithResult :: QuickCheckProperty.Testable prop => QuickCheckTest.Args -> prop -> IO QuickCheckTest.Result

-- |  Performs an 'IO' action after the last failure of a property.   
whenFail :: QuickCheckProperty.Testable prop => IO () -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


whenFail' :: QuickCheckProperty.Testable prop => IO () -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


withBuffering :: IO a -> IO a


withNullTerminal :: (QuickCheckText.Terminal -> IO a) -> IO a


withStdioTerminal :: (QuickCheckText.Terminal -> IO a) -> IO a


within :: QuickCheckProperty.Testable prop => Int -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop



-- | 
module frege.test.QuickCheckArbitrary

instance (ArrayElem a,QuickCheckArbitrary.Arbitrary a) => QuickCheckArbitrary.Arbitrary (JArray a)


instance (Ord k,QuickCheckArbitrary.Arbitrary k,QuickCheckArbitrary.Arbitrary v) => QuickCheckArbitrary.Arbitrary (TreeMap.TreeMap k v)


instance (Ord k,QuickCheckArbitrary.CoArbitrary k,QuickCheckArbitrary.CoArbitrary v) => QuickCheckArbitrary.CoArbitrary (TreeMap.TreeMap k v)


instance (QuickCheckArbitrary.Arbitrary a,QuickCheckArbitrary.Arbitrary b) => QuickCheckArbitrary.Arbitrary (a | b)


instance (QuickCheckArbitrary.Arbitrary a,QuickCheckArbitrary.Arbitrary b) => QuickCheckArbitrary.Arbitrary (a,b)


instance (QuickCheckArbitrary.Arbitrary a,QuickCheckArbitrary.Arbitrary b,QuickCheckArbitrary.Arbitrary c) => QuickCheckArbitrary.Arbitrary (a,b,c)


instance (QuickCheckArbitrary.Arbitrary a,QuickCheckArbitrary.Arbitrary b,QuickCheckArbitrary.Arbitrary c,QuickCheckArbitrary.Arbitrary d) => QuickCheckArbitrary.Arbitrary (a,b,c,d)


instance (QuickCheckArbitrary.Arbitrary a,QuickCheckArbitrary.Arbitrary b,QuickCheckArbitrary.Arbitrary c,QuickCheckArbitrary.Arbitrary d,QuickCheckArbitrary.Arbitrary e) => QuickCheckArbitrary.Arbitrary (a,b,c,d,e)


instance (QuickCheckArbitrary.Arbitrary a,QuickCheckArbitrary.CoArbitrary b) => QuickCheckArbitrary.CoArbitrary (a->b)


instance (QuickCheckArbitrary.CoArbitrary a,QuickCheckArbitrary.Arbitrary b) => QuickCheckArbitrary.Arbitrary (a->b)


instance (QuickCheckArbitrary.CoArbitrary a,QuickCheckArbitrary.CoArbitrary b) => QuickCheckArbitrary.CoArbitrary (a | b)


instance (QuickCheckArbitrary.CoArbitrary a,QuickCheckArbitrary.CoArbitrary b) => QuickCheckArbitrary.CoArbitrary (a,b)


instance (QuickCheckArbitrary.CoArbitrary a,QuickCheckArbitrary.CoArbitrary b,QuickCheckArbitrary.CoArbitrary c) => QuickCheckArbitrary.CoArbitrary (a,b,c)


instance (QuickCheckArbitrary.CoArbitrary a,QuickCheckArbitrary.CoArbitrary b,QuickCheckArbitrary.CoArbitrary c,QuickCheckArbitrary.CoArbitrary d) => QuickCheckArbitrary.CoArbitrary (a,b,c,d)


instance (QuickCheckArbitrary.CoArbitrary a,QuickCheckArbitrary.CoArbitrary b,QuickCheckArbitrary.CoArbitrary c,QuickCheckArbitrary.CoArbitrary d,QuickCheckArbitrary.CoArbitrary e) => QuickCheckArbitrary.CoArbitrary (a,b,c,d,e)


(><) :: (QuickCheckGen.Gen a -> QuickCheckGen.Gen a) -> (QuickCheckGen.Gen a -> QuickCheckGen.Gen a) -> QuickCheckGen.Gen a -> QuickCheckGen.Gen a

-- |  class Arbitrary   
-- 
--  Random generation and shrinking of values.   
-- 
--  Minimal complete definition: 'arbitrary'   
class Arbitrary


instance Bounded Ordering

-- |  CoArbitrary   
-- 
--  Used for random generation of functions.   
class CoArbitrary


instance QuickCheckArbitrary.Arbitrary ()


instance QuickCheckArbitrary.Arbitrary Bool


instance QuickCheckArbitrary.Arbitrary Byte


instance QuickCheckArbitrary.Arbitrary Char


instance QuickCheckArbitrary.Arbitrary Double


instance QuickCheckArbitrary.Arbitrary Float


instance QuickCheckArbitrary.Arbitrary Int


instance QuickCheckArbitrary.Arbitrary Integer


instance QuickCheckArbitrary.Arbitrary Long


instance QuickCheckArbitrary.Arbitrary Ordering


instance QuickCheckArbitrary.Arbitrary Short


instance QuickCheckArbitrary.Arbitrary String


instance QuickCheckArbitrary.Arbitrary a => QuickCheckArbitrary.Arbitrary (Maybe a)


instance QuickCheckArbitrary.Arbitrary a => QuickCheckArbitrary.Arbitrary [a]


instance QuickCheckArbitrary.CoArbitrary ()


instance QuickCheckArbitrary.CoArbitrary Bool


instance QuickCheckArbitrary.CoArbitrary Char


instance QuickCheckArbitrary.CoArbitrary Double


instance QuickCheckArbitrary.CoArbitrary Float


instance QuickCheckArbitrary.CoArbitrary Int


instance QuickCheckArbitrary.CoArbitrary Integer


instance QuickCheckArbitrary.CoArbitrary Long


instance QuickCheckArbitrary.CoArbitrary Ordering


instance QuickCheckArbitrary.CoArbitrary String


instance QuickCheckArbitrary.CoArbitrary a => QuickCheckArbitrary.CoArbitrary (Maybe a)


instance QuickCheckArbitrary.CoArbitrary a => QuickCheckArbitrary.CoArbitrary [a]

-- |  A generator for values of the given type.   
arbitrary :: QuickCheckArbitrary.Arbitrary a => QuickCheckGen.Gen a


arbitraryBoundedEnum :: (Bounded a,Enum a) => QuickCheckGen.Gen a


arbitraryBoundedIntegral :: (Bounded a,Integral a) => QuickCheckGen.Gen a

-- |  Generates an element of a bounded type. The element is chosen from the entire range of the type.   
arbitraryBoundedRandom :: (Bounded a,Random.Random a) => QuickCheckGen.Gen a


arbitrarySizedBoundedIntegral :: (Bounded a,Integral a) => QuickCheckGen.Gen a

-- |     Generates a fractional number. The number can be positive or negative
--     and its maximum absolute value depends on the size parameter.
--          
arbitrarySizedFloating :: Math.Floating a => QuickCheckGen.Gen a

-- |     Generates an integral number. The number can be positive or negative
--     and its maximum absolute value depends on the size parameter.
--          
arbitrarySizedIntegral :: Num a => QuickCheckGen.Gen a

-- |     Used to generate a function of type @a -> c@. The implementation
--     should use the first argument to perturb the random generator
--     given as the second argument. The returned generator
--     is then used to generate the function result.
--     
--     You can often use 'variant' and '><' to implement
--     'coarbitrary'.      
coarbitrary :: QuickCheckArbitrary.CoArbitrary a => a -> QuickCheckGen.Gen c -> QuickCheckGen.Gen c

-- |  A 'coarbitrary' implementation for enums.   
coarbitraryEnum :: Enum a => a -> QuickCheckGen.Gen b -> QuickCheckGen.Gen b


coarbitraryIntegral :: Integral a => a -> QuickCheckGen.Gen b -> QuickCheckGen.Gen b

-- |  'coarbitrary' helper for lazy people :-).   
coarbitraryShow :: Show a => a -> QuickCheckGen.Gen b -> QuickCheckGen.Gen b


isDigit :: ω


isLower :: ω


isSpace :: ω


isUpper :: ω

-- |   Generates an ordered list of a given length.   
orderedList :: (Ord a,QuickCheckArbitrary.Arbitrary a) => QuickCheckGen.Gen [a]

-- |     Produces a (possibly) empty list of all the possible
--     immediate shrinks of the given value.      
shrink :: QuickCheckArbitrary.Arbitrary a => a -> [a]

-- |  Shrink a fraction.   
shrinkFloating :: Math.Floating a => a -> [a]

-- |  Shrink an integral number.   
shrinkIntegral :: Integral a => a -> [a]


shrinkList :: (a -> [a]) -> [a] -> [[a]]

-- |  Returns no shrinking alternatives.   
shrinkNothing :: a -> [a]

-- |  The lowercase equivalent of the character, if any; otherwise, the character itself.   
toLower :: ω

-- | -----------------------------------------------------------------------   
-- 
--  Generates a list of a given length.   
vector :: QuickCheckArbitrary.Arbitrary a => Int -> QuickCheckGen.Gen [a]



-- | 
module frege.test.QuickCheckException

type AnException = Exception


discard :: a


isDiscard :: Exception -> Bool


isInterrupt :: Exception -> Bool

-- | -----------------------------------------------------------------------   
tryEvaluate :: a -> IO (Exception | a)


tryEvaluateIO :: IO a -> IO (Exception | a)



-- |  Test case generation.   
module frege.test.QuickCheckGen

instance Applicative QuickCheckGen.Gen


instance Functor QuickCheckGen.Gen

-- |  Generator type   
data Gen


MkGen :: (Random.StdGen -> Int -> a) -> QuickCheckGen.Gen a


instance Monad QuickCheckGen.Gen

-- |  Generates a random element in the given inclusive range.   
choose :: Random.Random a => (a,a) -> QuickCheckGen.Gen a

-- |  Generates one of the given values. The input list must be non-empty.   
elements :: [a] -> QuickCheckGen.Gen a

-- |  Chooses one of the given generators, with a weighted random distribution.
--     The input list must be non-empty.
--          
frequency :: [(Int,QuickCheckGen.Gen a)] -> QuickCheckGen.Gen a

-- |     Takes a list of elements of increasing size, and chooses
--     among an initial segment of the list. The size of this initial
--     segment increases with the size parameter.
--     The input list must be non-empty.      
growingElements :: [a] -> QuickCheckGen.Gen a

-- |  Generates a list of random length.    
-- 
--  The maximum length depends on the size parameter.   
listOf :: QuickCheckGen.Gen a -> QuickCheckGen.Gen [a]

-- |  Generates a non-empty list of random length.    
-- 
--  The maximum length depends on the size parameter.   
listOf1 :: QuickCheckGen.Gen a -> QuickCheckGen.Gen [a]

-- |  Randomly uses one of the given generators. The input list must be non-empty.   
oneof :: [QuickCheckGen.Gen a] -> QuickCheckGen.Gen a

-- |  Promotes a monadic generator to a generator of monadic values.   
promote :: Monad m => m (QuickCheckGen.Gen a) -> QuickCheckGen.Gen (m a)

-- |     Overrides the size parameter. Returns a generator which uses
--     the given size instead of the runtime-size parameter.
--      
resize :: Int -> QuickCheckGen.Gen a -> QuickCheckGen.Gen a

-- |  Generates some example values and prints them to 'stdout'.   
sample :: Show a => QuickCheckGen.Gen a -> IO ()

-- |  Generates some example values.   
sample' :: QuickCheckGen.Gen a -> IO [a]

-- |  Used to construct generators that depend on the size parameter.   
sized :: (Int -> QuickCheckGen.Gen a) -> QuickCheckGen.Gen a

-- |  Generates a value that satisfies a predicate.   
suchThat :: QuickCheckGen.Gen a -> (a -> Bool) -> QuickCheckGen.Gen a

-- |  Tries to generate a value that satisfies a predicate.   
suchThatMaybe :: QuickCheckGen.Gen a -> (a -> Bool) -> QuickCheckGen.Gen (Maybe a)


variant :: Integral n => n -> QuickCheckGen.Gen a -> QuickCheckGen.Gen a

-- |  Generates a list of the given length.   
vectorOf :: Int -> QuickCheckGen.Gen a -> QuickCheckGen.Gen [a]



-- |      Modifiers for test data.
--     
--      These types do things such as restricting the kind of test data that can be generated.
--      They can be pattern-matched on in properties as a stylistic
--      alternative to using explicit quantification.
--     
--      Examples:
--     
--      > -- Functions cannot be shown (but see "Test.QuickCheck.Function")
--      > prop_TakeDropWhile (Blind p) (xs :: [A]) =
--      >  takeWhile p xs ++ dropWhile p xs == xs
--      
--      > prop_TakeDrop ('NonNegative' n) (xs :: ['A']) =
--      >  take n xs ++ drop n xs == xs
--      
--     
--      > -- cycle does not work for empty lists
--      > prop_Cycle ('NonNegative' n) ('NonEmpty' (xs :: ['A'])) =
--      >  take n (cycle xs) == take n (xs ++ cycle xs)
--      
--     
--      > -- Instead of 'forAll' 'orderedList'
--      > prop_Sort ('Ordered' (xs :: ['OrdA'])) =
--      >   sort xs == xs
-- 
--      
module frege.test.QuickCheckModifiers

instance (Num a,Ord a,QuickCheckArbitrary.Arbitrary a) => QuickCheckArbitrary.Arbitrary (QuickCheckModifiers.NonNegative a)


instance (Num a,Ord a,QuickCheckArbitrary.Arbitrary a) => QuickCheckArbitrary.Arbitrary (QuickCheckModifiers.NonZero a)


instance (Num a,Ord a,QuickCheckArbitrary.Arbitrary a) => QuickCheckArbitrary.Arbitrary (QuickCheckModifiers.Positive a)


instance (Ord a,QuickCheckArbitrary.Arbitrary a) => QuickCheckArbitrary.Arbitrary (QuickCheckModifiers.OrderedList a)

-- |  @Blind x@: as x, but x does not have to be in the 'Show' class.   
data Blind


Blind :: a -> QuickCheckModifiers.Blind a


instance Eq a => Eq (QuickCheckModifiers.Blind a)


instance Eq a => Eq (QuickCheckModifiers.Fixed a)


instance Eq a => Eq (QuickCheckModifiers.NonEmptyList a)


instance Eq a => Eq (QuickCheckModifiers.NonNegative a)


instance Eq a => Eq (QuickCheckModifiers.NonZero a)


instance Eq a => Eq (QuickCheckModifiers.OrderedList a)


instance Eq a => Eq (QuickCheckModifiers.Positive a)


instance Eq a => Eq (QuickCheckModifiers.Shrink2 a)

-- |  @Fixed x@: as x, but will not be shrunk.   
data Fixed


Fixed :: a -> QuickCheckModifiers.Fixed a


NonEmpty :: [a] -> QuickCheckModifiers.NonEmptyList a

-- |   @NonEmpty xs@: guarantees that xs is non-empty.   
data NonEmptyList

-- |  @NonNegative x@: guarantees that @x >= 0@.   
data NonNegative


NonNegative :: a -> QuickCheckModifiers.NonNegative a

-- |  @NonZero x@: guarantees that @x != 0@.   
data NonZero


NonZero :: a -> QuickCheckModifiers.NonZero a


instance Ord a => Ord (QuickCheckModifiers.Blind a)


instance Ord a => Ord (QuickCheckModifiers.Fixed a)


instance Ord a => Ord (QuickCheckModifiers.NonEmptyList a)


instance Ord a => Ord (QuickCheckModifiers.NonNegative a)


instance Ord a => Ord (QuickCheckModifiers.NonZero a)


instance Ord a => Ord (QuickCheckModifiers.OrderedList a)


instance Ord a => Ord (QuickCheckModifiers.Positive a)


instance Ord a => Ord (QuickCheckModifiers.Shrink2 a)


Ordered :: [a] -> QuickCheckModifiers.OrderedList a

-- |  @Ordered xs@: guarantees that xs is ordered.   
data OrderedList

-- |  @Positive x@: guarantees that @x > 0@.   
data Positive


Positive :: a -> QuickCheckModifiers.Positive a


instance QuickCheckArbitrary.Arbitrary a => QuickCheckArbitrary.Arbitrary (QuickCheckModifiers.Blind a)


instance QuickCheckArbitrary.Arbitrary a => QuickCheckArbitrary.Arbitrary (QuickCheckModifiers.Fixed a)


instance QuickCheckArbitrary.Arbitrary a => QuickCheckArbitrary.Arbitrary (QuickCheckModifiers.NonEmptyList a)


instance QuickCheckArbitrary.Arbitrary a => QuickCheckArbitrary.Arbitrary (QuickCheckModifiers.Shrink2 a)


instance QuickCheckArbitrary.Arbitrary a => QuickCheckArbitrary.Arbitrary (QuickCheckModifiers.Smart a)


instance Show (QuickCheckModifiers.Blind a)


instance Show a => Show (QuickCheckModifiers.Fixed a)


instance Show a => Show (QuickCheckModifiers.NonEmptyList a)


instance Show a => Show (QuickCheckModifiers.NonNegative a)


instance Show a => Show (QuickCheckModifiers.NonZero a)


instance Show a => Show (QuickCheckModifiers.OrderedList a)


instance Show a => Show (QuickCheckModifiers.Positive a)


instance Show a => Show (QuickCheckModifiers.Shrink2 a)


instance Show a => Show (QuickCheckModifiers.Smart a)

-- |  @Shrink2 x@: allows 2 shrinking steps at the same time when shrinking x   
data Shrink2


Shrink2 :: a -> QuickCheckModifiers.Shrink2 a

-- |   @Smart _ x@: tries a different order when shrinking.   
data Smart


Smart :: Int -> a -> QuickCheckModifiers.Smart a



-- | 
module frege.test.QuickCheckProperty

instance (QuickCheckArbitrary.Arbitrary a,Show a,QuickCheckProperty.Testable prop) => QuickCheckProperty.Testable (a->prop)

-- |  Conjunction: @p1 .&&. p2@ passes if both @p1@ and @p2@ pass.   
(.&&.) :: (QuickCheckProperty.Testable prop1,QuickCheckProperty.Testable prop2) => prop1 -> prop2 -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |     Nondeterministic choice: @p1 .&. p2@ picks randomly one of
--     @p1@ and @p2@ to test. If you test the property 100 times it
--     makes 100 random choices.
--          
(.&.) :: (QuickCheckProperty.Testable prop1,QuickCheckProperty.Testable prop2) => prop1 -> prop2 -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  Disjunction: @p1 .||. p2@ passes unless @p1@ and @p2@ simultaneously fail.   
(.||.) :: (QuickCheckProperty.Testable prop1,QuickCheckProperty.Testable prop2) => prop1 -> prop2 -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |     Implication for properties: The resulting property holds if
--     the first argument is @false@ (in which case the test case is discarded),
--     or if the given property holds.      
(==>) :: QuickCheckProperty.Testable prop => Bool -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  Different kinds of callbacks   
data Callback


data CallbackKind

-- |  Affected by the 'verbose' combinator   
Counterexample :: QuickCheckProperty.CallbackKind


instance Functor QuickCheckProperty.Rose


IORose :: IO (QuickCheckProperty.Rose a) -> QuickCheckProperty.Rose a


MkProp :: QuickCheckProperty.Rose QuickCheckProperty.Result -> QuickCheckProperty.Prop


MkResult :: Maybe Bool -> Bool -> String -> Bool -> Bool -> [(String,Int)] -> [QuickCheckProperty.Callback] -> QuickCheckProperty.Result


MkRose :: a -> [QuickCheckProperty.Rose a] -> QuickCheckProperty.Rose a


instance Monad QuickCheckProperty.Rose

-- |  Not affected by the 'verbose' combinator   
NotCounterexample :: QuickCheckProperty.CallbackKind

-- |  Called with the final failing test-case   
PostFinalFailure :: QuickCheckProperty.CallbackKind -> (QuickCheckState.State -> QuickCheckProperty.Result -> IO ()) -> QuickCheckProperty.Callback

-- |  Called just after a test   
PostTest :: QuickCheckProperty.CallbackKind -> (QuickCheckState.State -> QuickCheckProperty.Result -> IO ()) -> QuickCheckProperty.Callback

-- | -----------------------------------------------------------------------   
data Prop

-- |  The things  quick check is testing   
type Property = QuickCheckGen.Gen QuickCheckProperty.Prop


instance QuickCheckProperty.Testable Bool


instance QuickCheckProperty.Testable QuickCheckProperty.Prop


instance QuickCheckProperty.Testable QuickCheckProperty.Result


instance QuickCheckProperty.Testable prop => QuickCheckProperty.Testable (QuickCheckGen.Gen prop)


data Result


data Rose

-- |  The class of things which can be tested, i.e. turned into a property.   
class Testable

-- |   Adds a callback   
callback :: QuickCheckProperty.Testable prop => QuickCheckProperty.Callback -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  Conditionally labels test case.   
classify :: QuickCheckProperty.Testable prop => Bool -> String -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  Labels a property with a value:   
-- 
--  > collect x = label (show x)   
collect :: (Show a,QuickCheckProperty.Testable prop) => a -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  Take the conjunction of several properties.   
conjoin :: QuickCheckProperty.Testable prop => [prop] -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  Checks that at least the given proportion of the test cases belong to the given class.   
cover :: QuickCheckProperty.Testable prop => Bool -> Int -> String -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  Take the disjunction of several properties.   
disjoin :: QuickCheckProperty.Testable prop => [prop] -> QuickCheckGen.Gen QuickCheckProperty.Prop


exception :: String -> Exception -> QuickCheckProperty.Result


exhaustive :: QuickCheckProperty.Testable prop => prop -> Bool

-- |  Modifies a property so that it is expected to fail for some test cases.   
expectFailure :: QuickCheckProperty.Testable prop => prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


failed :: QuickCheckProperty.Result

-- |     Explicit universal quantification: uses an explicitly given
--     test case generator.
--          
forAll :: (Show a,QuickCheckProperty.Testable prop) => QuickCheckGen.Gen a -> (a -> prop) -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  Like 'forAll', but tries to shrink the argument for failing test cases.   
forAllShrink :: (Show a,QuickCheckProperty.Testable prop) => QuickCheckGen.Gen a -> (a -> [a]) -> (a -> prop) -> QuickCheckGen.Gen QuickCheckProperty.Prop


formatException :: String -> Exception -> String


ioRose :: IO (QuickCheckProperty.Rose QuickCheckProperty.Result) -> QuickCheckProperty.Rose QuickCheckProperty.Result


joinRose :: QuickCheckProperty.Rose (QuickCheckProperty.Rose a) -> QuickCheckProperty.Rose a

-- |  Attaches a label to a property.    
-- 
--  This is used for reporting test case distribution.   
label :: QuickCheckProperty.Testable prop => String -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


liftBool :: Bool -> QuickCheckProperty.Result


mapProp :: QuickCheckProperty.Testable prop => (QuickCheckProperty.Prop -> QuickCheckProperty.Prop) -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


mapResult :: QuickCheckProperty.Testable prop => (QuickCheckProperty.Result -> QuickCheckProperty.Result) -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


mapRoseResult :: QuickCheckProperty.Testable prop => (QuickCheckProperty.Rose QuickCheckProperty.Result -> QuickCheckProperty.Rose QuickCheckProperty.Result) -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  Changes the maximum test case size for a property.   
mapSize :: QuickCheckProperty.Testable prop => (Int -> Int) -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


mapTotalResult :: QuickCheckProperty.Testable prop => (QuickCheckProperty.Result -> QuickCheckProperty.Result) -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |     Do I/O inside a property. This can obviously lead to unrepeatable
--     testcases, so use with care.      
morallyDubiousIOProperty :: QuickCheckProperty.Testable prop => IO prop -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  Disables shrinking for a property altogether.   
noShrinking :: QuickCheckProperty.Testable prop => prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


onRose :: (a -> [QuickCheckProperty.Rose a] -> QuickCheckProperty.Rose a) -> QuickCheckProperty.Rose a -> QuickCheckProperty.Rose a

-- |  Modifies a property so that it only will be tested once.   
once :: QuickCheckProperty.Testable prop => prop -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  Prints a message to the terminal as part of the counterexample.   
printTestCase :: QuickCheckProperty.Testable prop => String -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


property :: QuickCheckProperty.Testable prop => prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


protect :: (Exception -> a) -> IO a -> IO a


protectResult :: IO QuickCheckProperty.Result -> IO QuickCheckProperty.Result

-- |  Wrap all the Results in a rose tree in exception handlers.   
protectResults :: QuickCheckProperty.Rose QuickCheckProperty.Result -> QuickCheckProperty.Rose QuickCheckProperty.Result

-- |  Wrap a rose tree in an exception handler.   
protectRose :: IO (QuickCheckProperty.Rose QuickCheckProperty.Result) -> IO (QuickCheckProperty.Rose QuickCheckProperty.Result)


reduceRose :: QuickCheckProperty.Rose QuickCheckProperty.Result -> IO (QuickCheckProperty.Rose QuickCheckProperty.Result)


rejected :: QuickCheckProperty.Result


result :: QuickCheckProperty.Result

-- |     Shrinks the argument to property if it fails. Shrinking is done
--     automatically for most types. This is only needed when you want to
--     override the default behavior.      
shrinking :: QuickCheckProperty.Testable prop => (a -> [a]) -> a -> (a -> prop) -> QuickCheckGen.Gen QuickCheckProperty.Prop


succeeded :: QuickCheckProperty.Result

-- |      Prints out the generated testcase every time the property is tested,
--     like "verboseCheck" from QuickCheck 1.
--     Only variables quantified over _inside_ the 'verbose' are printed.      
verbose :: QuickCheckProperty.Testable prop => prop -> QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  Performs an 'IO' action after the last failure of a property.   
whenFail :: QuickCheckProperty.Testable prop => IO () -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


whenFail' :: QuickCheckProperty.Testable prop => IO () -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop


within :: QuickCheckProperty.Testable prop => Int -> prop -> QuickCheckGen.Gen QuickCheckProperty.Prop



-- | 
module frege.test.QuickCheckState

MkState :: QuickCheckText.Terminal -> Int -> Int -> (Int -> Int -> Int) -> Int -> Int -> Int -> [[(String,Int)]] -> Bool -> Random.StdGen -> Int -> Int -> Int -> QuickCheckState.State


data State



-- | 
module frege.test.QuickCheckTest
-- | -----------------------------------------------------------------------   
data Args


Args :: Maybe (Random.StdGen,Int) -> Int -> Int -> Int -> Bool -> QuickCheckTest.Args


Failure :: Int -> Int -> Random.StdGen -> Int -> String -> Bool -> [(String,Int)] -> String -> QuickCheckTest.Result


GaveUp :: Int -> [(String,Int)] -> String -> QuickCheckTest.Result


NoExpectedFailure :: Int -> [(String,Int)] -> String -> QuickCheckTest.Result

-- |  Result represents the test result   
data Result


instance Show QuickCheckTest.Args


instance Show QuickCheckTest.Result


instance Show Random.StdGen

-- |  a successful test run   
Success :: Int -> [(String,Int)] -> String -> QuickCheckTest.Result


callbackPostFinalFailure :: QuickCheckState.State -> QuickCheckProperty.Result -> IO ()


callbackPostTest :: QuickCheckState.State -> QuickCheckProperty.Result -> IO ()


doneTesting :: QuickCheckState.State -> (Random.StdGen -> Int -> QuickCheckProperty.Prop) -> IO QuickCheckTest.Result

-- | -----------------------------------------------------------------------   
foundFailure :: QuickCheckState.State -> QuickCheckProperty.Result -> [QuickCheckProperty.Rose QuickCheckProperty.Result] -> IO Int


giveUp :: QuickCheckState.State -> (Random.StdGen -> Int -> QuickCheckProperty.Prop) -> IO QuickCheckTest.Result

-- |  isSuccess checks if the test run result was a success   
isSuccess :: QuickCheckTest.Result -> Bool


localMin :: QuickCheckState.State -> QuickCheckProperty.Result -> [QuickCheckProperty.Rose QuickCheckProperty.Result] -> IO Int


localMin' :: QuickCheckState.State -> QuickCheckProperty.Result -> [QuickCheckProperty.Rose QuickCheckProperty.Result] -> IO Int


localMinFound :: QuickCheckState.State -> QuickCheckProperty.Result -> IO Int

-- |  Tests a property and prints the results to 'stdout'.   
quickCheck :: QuickCheckProperty.Testable prop => prop -> IO ()

-- |  Tests a property, produces a test result, and prints the results to 'stdout'.   
quickCheckResult :: QuickCheckProperty.Testable prop => prop -> IO QuickCheckTest.Result

-- |  Tests a property, using test arguments, and prints the results to 'stdout'.   
quickCheckWith :: QuickCheckProperty.Testable prop => QuickCheckTest.Args -> prop -> IO ()

-- |  Tests a property, using test arguments, produces a test result, and prints the results to 'stdout'.   
quickCheckWithResult :: QuickCheckProperty.Testable prop => QuickCheckTest.Args -> prop -> IO QuickCheckTest.Result


runATest :: QuickCheckState.State -> (Random.StdGen -> Int -> QuickCheckProperty.Prop) -> IO QuickCheckTest.Result


safely :: QuickCheckState.State -> IO () -> IO ()

-- |  stdArgs are the default test arguments used   
stdArgs :: QuickCheckTest.Args


success :: QuickCheckState.State -> IO ()


summary :: QuickCheckState.State -> [(String,Int)]

-- | -----------------------------------------------------------------------   
test :: QuickCheckState.State -> (Random.StdGen -> Int -> QuickCheckProperty.Prop) -> IO QuickCheckTest.Result


verboseCheck :: QuickCheckProperty.Testable prop => prop -> IO ()


verboseCheckResult :: QuickCheckProperty.Testable prop => prop -> IO QuickCheckTest.Result


verboseCheckWith :: QuickCheckProperty.Testable prop => QuickCheckTest.Args -> prop -> IO ()


verboseCheckWithResult :: QuickCheckProperty.Testable prop => QuickCheckTest.Args -> prop -> IO QuickCheckTest.Result



-- | 
module frege.test.QuickCheckText

type Handle = PrintWriter


MkStr :: String -> QuickCheckText.Str


MkTerminal :: IORef (IO ()) -> QuickCheckText.Output -> QuickCheckText.Output -> QuickCheckText.Terminal


data Output


Output :: (String -> IO ()) -> IORef String -> QuickCheckText.Output


instance Show QuickCheckText.Str

-- | -----------------------------------------------------------------------   
data Str


data Terminal


bold :: String -> String


flush :: QuickCheckText.Terminal -> IO ()


get :: QuickCheckText.Output -> IO String


hFlush :: Flushable -> IO ()

-- |  print a 'String'   
hPutStr :: PrintWriter -> String -> IO ()


handle :: PrintWriter -> String -> IO ()


isOneLine :: String -> Bool


kurz :: Int -> String -> String


newTerminal :: QuickCheckText.Output -> QuickCheckText.Output -> IO QuickCheckText.Terminal

-- | -----------------------------------------------------------------------   
number :: Int -> String -> String


oneLine :: String -> String


output :: (String -> IO ()) -> IO QuickCheckText.Output


postpone :: QuickCheckText.Terminal -> IO () -> IO ()


put :: QuickCheckText.Output -> String -> IO ()


putLine :: QuickCheckText.Terminal -> String -> IO ()


putPart :: QuickCheckText.Terminal -> String -> IO ()


putTemp :: QuickCheckText.Terminal -> String -> IO ()


ranges :: (Show a,Integral a) => a -> a -> QuickCheckText.Str


showErr :: Show a => a -> String


terminalOutput :: QuickCheckText.Terminal -> IO String


withBuffering :: IO a -> IO a


withNullTerminal :: (QuickCheckText.Terminal -> IO a) -> IO a


withStdioTerminal :: (QuickCheckText.Terminal -> IO a) -> IO a



-- |  * This program reads java class files that are the result
--  * of compiling a frege package and writes
--  * a documentation of that package. All public classes, instances,
--  * data types, type aliases and functions are listed along with
--  * programmer supplied documentation from _doc_ comments.
--  *
--  * Usage:
--  * >java frege.tools.Doc [-d docpath] your.frege.Package ...
--  * This creates or updates the documentation files for the
--  * packages named on the command line. A documentation file for package
--  * @a.b.C@ will be written in file @docpath/a/b/C.html@, where @docpath@
--  * must be an existing directory.
--  *
--  * If the @-d@  flag is not given, the current directory is assumed for
--  * @docpath@.
--  *
--  * The generated HTML will contain links to the documentation files of imported
--  * packages, which are assumed to exist in the same @docpath@.
--       
module frege.tools.Doc

DOpt :: Bool -> String -> [String] -> [String] -> Doc.DocOpts


data Date


data DocOpts


continueImport :: State.StateT Global.Global IO ()


continueNamespaces :: Classtools.FregePackage -> State.StateT Global.Global IO ()


docArch :: Global.Global -> MutableIO File -> IO [Global.Global]


docDir :: Global.Global -> MutableIO File -> [String] -> IO [Global.Global]


docDirEntry :: Global.Global -> MutableIO File -> [String] -> String -> IO [Global.Global]


docThing :: Global.Global -> String -> IO [Global.Global]


main :: [String] -> IO ()


mkLinks :: NSNames.NSName -> Packs.Pack -> State.State Global.Global ()


options :: Doc.DocOpts


scanOpts :: Doc.DocOpts -> [String] -> IO (Maybe (Doc.DocOpts,[String]))


stime :: Long -> String


usage :: IO ()

-- |  make 1 documentation file   
work :: String -> State.StateT Global.Global IO ()



-- |  Inspect a frege documentation directory and make files that enable framed HTML view.   
module frege.tools.MakeDocIndex
-- |  compute the path of a file in a certain directory   
fileIn :: String -> String -> IO String

-- |  walk a directory and get all HTML files   
findHtml :: String -> IO [(String,String)]

-- |  make link to frame   
frameElem :: String -> String

-- |  regular expression to detect "\*.html" files   
htmlAtEnd :: Regex

-- |  tell if this is the name of a meta file   
isMeta :: String -> Bool

-- |  make link from a relative path and a HTML file name   
linkElem :: String -> String -> String

-- |     We will make the following files:
--     
--     @fregedoc.html@ defines 3 frames: left upper, left lower and right.
--     
--     @prefix-frame.html@ contains a list of the module prefixes,
--     which are shown in the left upper frame. Each entry causes the
--     left lower frame to display the modules with that prefix.
--     
--     For each module prefix a file that lists the actual modules. 
--     This one is displayed in the left lower frame, and clicking on
--     one of the names causes the module documentation to appear
--     in the right frame.
--     For example, @frame-frege.prelude.html@ would contain @PreludeBase@, 
--     @PreludeMonad@ and so on.
--     
--     There will be a pseudo module prefix "@All Modules@" and a 
--     corresponding @frame-All-Modules.html@ that contains links to all the
--     modules.
--      
main :: [String] -> IO Bool


makeFrame :: String -> String -> [(String,String)] -> IO ()

-- |  make the @prefix-frame.html@ file   
makePrefixFrame :: String -> [String] -> IO ()

-- |  file name of a module prefix   
prefixFrame :: String -> String

-- |  display name of a module prefix   
prefixName :: String -> String

-- |  Print the top file with the frameset   
printFregeDoc :: String -> IO ()

-- |  regular expression to split path names on 'File.separator'   
separatorRE :: Regex

-- |  drop ".html" from the end of a name   
unHtml :: String -> String

-- |  wrap in html tags, i.e. @<xx>foo</xx>@   
wrap :: String -> String -> String



-- |     Looks up quick check predicates in the given modules and tests them.
-- 
--     [Usage:] java -cp fregec.jar frege.tools.Quick [ option ... ] modulespec ...
--     
--     Options:
--     
--     -    -v      print a line for each predicate that passed
--     -    -n num  run _num_ tests per predicate, default is 100
--     -    -p pred1,pred2,... only test the given predicates
--     -    -x pred1,pred2,... do not test the given predicates
--     -    -l  just print the names of the predicates available.
--     
--     Ways to specify modules:
--     
--     - module  the module name (e.g. my.great.Module), will be lookup up in
--               the current class path.
--     - dir/    A directory path. The directory is searched for class files,
--               and for each class files an attempt is made to load it as if
--               the given directory was in the class path. The directory must
--               be the root of the classes contained therein, otherwise the
--               classes won't get loaded.
--     - path-to.jar A jar or zip file is searched for class files, and for each
--               class file found an attempt is made to load it as if the
--               jar was in the class path.
--     
--      The number of passed/failed tests is reported. If any test failed or other
--      errors occurred, the exit code will be non zero.
--      
--      The code will try to heat up your CPU by running tests on all available cores.
--      This should be faster on multi-core computers than running the tests
--      sequentially. It makes it feasible to run more tests per predicate.
--      
module frege.tools.Quick

data Counter


Counter :: Int -> Int -> Bool -> Quick.Counter


instance Eq Quick.Counter


instance Monoid.Monoid Quick.Counter


Opt :: Bool -> Bool -> Bool -> Int -> [String] -> Global.Global -> Quick.Options


data Options


checkField :: Quick.Options -> String -> Class a -> String -> IO Quick.Counter


checkModule :: Quick.Options -> String -> IO Quick.Counter


checkProps :: Quick.Options -> String -> [String] -> IO Quick.Counter


checkThing :: Quick.Options -> String -> IO Quick.Counter


counterMconcat :: QuickCheckGen.Gen QuickCheckProperty.Prop


defaultOptions :: Quick.Options


genName :: QNames.QName


getOpt :: Quick.Options -> [String] -> IO (Quick.Options,[String])

-- |  import a package and extract all toplevel properties   
getProps :: String -> State.StateT Global.Global IO [String]


main :: [String] -> IO Bool

-- |  functionality relies on the absolute name of type 'QC.Gen'   
propName :: QNames.QName


testAborted :: Quick.Counter


testFailed :: Quick.Counter


testPassed :: Quick.Counter

-- |     This does the magic.
--      
--     We know that the type of the item is 'Property' on the Frege level.
--     This will be compiled to something that is a Lambda in Java terms.
--     
--     Hence the cast is a no-op, and the native interface will believe 
--     our claim that the Lambda is a Property and will allow us to
--     use it just like any other 'Property'.
--      
toLambda :: Object -> IO (QuickCheckGen.Gen QuickCheckProperty.Prop)


unAborted :: Quick.Counter -> Quick.Counter



-- |  This is an undocumented module   
module frege.tools.Splitter

appMod :: Global.Global -> String -> IO PrintWriter


ascending :: Global.Global -> [Symbols.SymbolT Global.Global]


ctxDep :: Global.Global -> TreeMap.TreeMap QNames.QName () -> Types.ContextT QNames.QName -> TreeMap.TreeMap QNames.QName ()


dclintro :: [TokenID.TokenID]


dotDep :: PrintWriter -> Global.Global -> TreeMap.TreeMap QNames.QName [QNames.QName] -> [QNames.QName] -> IO ()

-- |  items dot doesn't like as bare word   
dotkeys :: [String]


exprDep :: Global.Global -> Expression.ExprT -> TreeMap.TreeMap QNames.QName ()

-- |     The full range goes from the lower range to the upper range, inclusive.
--     
--     The lower range is determined by going from the original position
--     backwards as long as there are comments or documentation.
--     
--     The upper range is the last non comment or documentation token before
--     the next definition in the ascending list of definitions, or, if
--     there is no next, the last token in the file.
--          
fullRange :: Symbols.SymbolT Global.Global -> Maybe (Symbols.SymbolT Global.Global) -> State.StateT Global.Global IO Positions.Position


ideoff :: State.StateT Global.Global IO (String,Int)

-- |  find the index of a given token       
indexIn :: (ArrayElem a,Eq a) => a -> JArray a -> Maybe Int


main :: [String] -> IO ()

-- |     Update symbol positions with their full range computed by 'fullRange'.
--          
makeRanges :: [Symbols.SymbolT Global.Global] -> State.StateT Global.Global IO ()


nameDep :: Global.Global -> TreeMap.TreeMap QNames.QName () -> QNames.QName -> TreeMap.TreeMap QNames.QName ()

-- |  Create a new package and return a 'PrintWriter' for it.   
newMod :: Global.Global -> String -> IO PrintWriter


ours :: Global.Global -> [Symbols.SymbolT Global.Global]


printDep :: (Nice.Nice b,Ord a,Eq b,Nice.Nice a) => Global.Global -> TreeMap.TreeMap a [b] -> [a] -> IO ()


printHeader :: PrintWriter -> String -> IO ()


printImpDcl :: Global.Global -> PrintWriter -> SourceDefinitions.DefinitionS -> IO ()


printImports :: Global.Global -> PrintWriter -> IO ()


printMods :: Global.Global -> String -> Maybe String -> [QNames.QName] -> [QNames.QName] -> [Symbols.SymbolT Global.Global] -> IO ()


printRange :: Global.Global -> Symbols.SymbolT Global.Global -> IO ()


rhoDep :: Global.Global -> TreeMap.TreeMap QNames.QName () -> Types.RhoT QNames.QName -> TreeMap.TreeMap QNames.QName ()


sigmaDep :: Global.Global -> Types.SigmaT QNames.QName -> TreeMap.TreeMap QNames.QName ()


split :: [String] -> State.StateT Global.Global IO (String,Int)


symDep :: Global.Global -> Symbols.SymbolT Global.Global -> TreeMap.TreeMap QNames.QName ()

-- |   make filename from package name  @x.y.z.Packet@ =>  @dest/x/y/z/Packet.suffix@   
targetPath :: Global.Global -> String -> String -> String


tauDep :: Global.Global -> TreeMap.TreeMap QNames.QName () -> Types.TauT QNames.QName -> TreeMap.TreeMap QNames.QName ()


usage :: IO ()



-- |     This program creates a parser from the result of running
--     @byacc -v@ on a yacc grammar. It reads the resulting
--     files "y.tab.c" and "y.output" in the
--     current directory and uses the information therein to
--     construct a frege program.
-- 
--     Each grammar rule is associated with a reduction function of type
--     >  item1 -> ... -> item2 -> result
--     where the item types are either tokens (provided as input to the parser)
--     or results of other grammar rules.
--     All rules of a nonterminal grammar symbol will have the same result type.
--     Example:
-- 
--     > %{
--     > package Calculator
--     > numberFrom :: Token -> Double
--     > %}
--     >
--     > %token NUMBER PI
--     > %start sum
--     > %%
--     > sum : product '+' product { \a\_\b -> a + b }  // was: $$ = $1 + $3
--     >       | product                                // was: $$ = $1
--     >       ;
--     > product: term '*' term { \a\b\c -> a * b }
--     >       | term
--     >       ;
--     > term: NUMBER              { numberFrom }
--     >       | PI                { const 3.14159 }
--     >       | '-' term          { \_\b -> negate b }
--     >       | '(' sum ')'       { \_\b\_ -> b }
--     >       ;
--     > %%
--     > data TokenID = NUMBER | PI | OPERATOR
--     > derive Show TokenID
--     > derive Ord TokenID
-- 
--     > data Token = N Double | Pi | Op Char
--     > derive Show Token
-- 
--     > yyshowToken = Token.show
-- 
--     > yyniceToken (N d) = show d
--     > yyniceToken Pi = "pi"
--     > yyniceToken (Op c) = show c
-- 
--     > yytoken :: Token -> TokenID
--     > yytoken (N _) = NUMBER
--     > yytoken Pi    = PI
--     > yytoken Op    = OPERATOR
--     >
--     > yychar :: Token -> Char
--     > yychar (Op c) = c
--     > yychar _ = const '§'  // paragraph symbol not used elsewhere
--     >
--     > yyfromId NUMBER = N 42.0
--     > yyfromId PI     = PI
--     > // yyfromId OPERATOR = not needed, as the parser knows nothing of OPERATOR
--     >
--     > yyfromCh :: Char -> Token
--     > yyfromCh c = Op c
--     >
--     > yyline = const 0      // no way to know in this example
-- 
--     So far, this is just a good old yacc grammar, except that the semantic actions
--     are frege expressions, and the code before an after the "%%" markers is
--     frege code.
-- 
--     Each semantic action is expected to be a function that
--     takes as many arguments as there are items in its rule.
--     Hence, in the first rule of nonterminal "sum" the left product will be bound
--     to /a/, the "+" token is ignored and the right product to /b/. A missing action
--     is equivalent to the identity function, therefore in the second rule of nonterminal
--     "sum", the sum will be just the product.
-- 
--     The parser generated from this will have a function
--     > yyparse :: [Token] -> Maybe Double
--     since Double is the result type of the rules associated with the start symbol and
--     tokens are obviously of type Token (due to application of user supplied function numberFrom).
--     The result will be 'Nothing' if the parser could not reduce the start symbol (i.e.,
--     when there were nonrecoverable syntax errors) and ('Just' x) otherwise, where /x/ is
--     the result of one of the semantic actions associated with the "%start" symbol.
-- 
--     The parser itself does not make any assumptions about what a token is. Instead, it
--     relies on the following user supplied functions:
-- 
--     > yytoken  :: token -> tid
--     > yyfromId :: tid -> token
-- 
--     where /token/ is the type of tokens and /tid/ is the type of the token constants
--     defined in the "%token" directive. The /yytoken/ function must be total, i.e. all possible
--     token values must produce some token constant, yet this does not have to be one of the
--     constants that is listed in the "%token" directive.
-- 
--     The /yyfromId/ function
--     must produce an example token value for each token constant the parser knows of
--     through the "%token" diretive. Both functions have to be there only when a "%token"
--     directive is present.
-- 
-- 
--     If the grammar uses character constants, the following functions must be present:
-- 
--     > yychar :: token -> Char
--     > yyfromCh :: Char -> token
-- 
--     The /yychar/ function must be total, all possible token values must be
--     mapped to some character. Use a character value that is not used in the
--     grammar for tokens that have no representation as a character value.
-- 
--     The /yyfromCh/ function maps back characters to token values. The /yyfrom../
--     functions are used in error recovery to supply tokens that are expected,
--     but missing.
-- 
-- 
--     Here is an example of how the parser may determine what to do in state 42:
--     > yyaction 42 tok = case yychar tok of
--     >       '*'   -> Shift 57
--     >       _ -> case yytoken tok of
--     >           NUMBER -> Shift 96
--     >           _      -> Reduce 5
-- 
--     In addition, the parser needs the following functions:
--     > yynice :: token -> String
--     > yyshow :: token -> String
--     > yyline :: token -> Show:a
--     > yyerror :: Show:a -> String -> c
-- 
--     /yynice/ is used by the parser to construct error messages like this
--     > "syntax error, expected ',', found " ++ yynice errortoken
--     > "syntax error, expected IDENTIFIER, found " ++ yynice errortoken
--     > "syntax error on " ++ yynice errortoken
-- 
--     /yyshow/ is used in trace output and is intended
--     for a most detailed display of tokens as
--     they are recognized by the parser.
-- 
--     /yyline/ is used to extract line number information from a token,
--     it is thus a good idea to design the lexical analyzer so that a token
--     is able to tell where it was found.
-- 
--     /yyerror/ is used to emit messages about syntax errors. The first argument
--     will be either the string "EOF" or the result of applying /yyline/ to a token.
--     The second argument is a string that describes the error. The result of yyerror is
--     evaluated, but ignored.
--      
module frege.tools.YYgen

A :: YYgen.Todo -> YYgen.Item -> Int -> YYgen.Action


Acc :: YYgen.Item


Accept :: YYgen.Todo


data Action


Def :: YYgen.Item


End :: YYgen.Item


instance Eq YYgen.Item


instance Eq YYgen.Prod


Error :: YYgen.Todo


Goto :: YYgen.Todo


data Item


Lit :: String -> YYgen.Item


NT :: String -> YYgen.Item


instance Ord YYgen.Item


instance Ord YYgen.Prod


data Prod


Prod :: Int -> YYgen.Item -> [YYgen.Item] -> YYgen.Prod


Reduce :: YYgen.Todo


Shift :: YYgen.Todo


instance Show YYgen.Action


instance Show YYgen.Item


instance Show YYgen.Prod


instance Show YYgen.Todo


instance Show YYgen.YYState


St :: Int -> [YYgen.Prod] -> [YYgen.Action] -> [YYgen.Action] -> YYgen.YYState


T :: String -> YYgen.Item


data Todo


data YYState


actions :: [YYgen.YYState] -> [(Int,String)]


altgotos :: [YYgen.Prod] -> [YYgen.YYState] -> [(Int,Int,Int)] -> [(Int,Int,Int)]


altgotos2 :: [YYgen.Prod] -> [YYgen.YYState] -> [(Int,[(Int,Int)])]

-- |  concatenate two lists, strings or whatever   
-- 
--   > empty ++ x == x && x ++ empty == x   
append :: ListSemigroup α => α β -> α β -> α β


cantwrite :: String -> FileNotFoundException -> IO ()


collectacceptactions :: YYgen.YYState -> Bool


collecteactions :: YYgen.YYState -> Bool


compiletypes :: TreeMap.TreeMap String String -> [String] -> String


eactions :: [YYgen.YYState] -> [(Int,String)]


extrrule :: YYgen.YYState -> [YYgen.Prod]


extrrules :: [YYgen.YYState] -> [YYgen.Prod]

-- |  give back file content as list of lines   
fileContent :: String -> IO [String]


format1 :: String -> Int -> String


genacc :: Show a => a -> YYgen.Prod -> String


gengos :: (Show b,Show c,ListSource a,Ord d,Show d,Ord c,Ord b) => a (d,c,b) -> String


gengoto1 :: a -> YYgen.Action -> [YYgen.Prod] -> [(a,Int,Int)]


gengoto2 :: YYgen.Action -> [YYgen.Prod] -> [(Int,Int)] -> [(Int,Int)]


gengotos1 :: [YYgen.Prod] -> YYgen.YYState -> [(Int,Int,Int)]


gengotos2 :: [YYgen.Prod] -> YYgen.YYState -> (Int,[(Int,Int)])


genitem :: Int -> YYgen.Item -> String


genitems :: [YYgen.Item] -> [String]


genprod :: Maybe a -> YYgen.Prod -> [(Int,String)] -> String


genrule :: YYgen.Prod -> String


genshowsi :: [String] -> String


genst :: YYgen.YYState -> String


genstate :: Show a => a -> [YYgen.Prod] -> YYgen.Action -> String

-- |     @filter p xs@ returns the list of elements _x_ from _xs_ where (_p x_) holds.
-- 
--     'filter' will not stop to evaluate its argument list until the first/next
--     element with the property asked for is found. For example
-- 
--     > filter (==true) (repeat false)
-- 
--     will loop forever, whereas
-- 
--     > filter even [1..] 
-- 
--     will faithfully deliver the list of positive integers that are divisible by 2,
--     one by one.
--          
grep :: (a->Bool) -> [a] -> [a]


listmax :: Int


listred :: Show a => (a,String) -> String


loadRessource :: Maybe a -> Net.URLClassLoader -> IO [String]


loadUrl :: Net.URL -> IO [String]


main :: [String] -> IO ()


mainIO :: Maybe String -> String -> IO ()


mkState :: (Int,[String]) -> YYgen.YYState


niceitem :: YYgen.Item -> String


numbertypes :: Ord a => Int -> [a] -> TreeMap.TreeMap a Int -> TreeMap.TreeMap a Int


numprod :: YYgen.Prod -> (Int,String)


pracase :: Show a => String -> [(Int,a)] -> PrintWriter -> IO ()

-- |  * create frege code for go tabs
--       
printgos :: [(Int,[(Int,Int)])] -> PrintWriter -> IO ()


printpr :: Maybe a -> [YYgen.YYState] -> [(Int,String)] -> PrintWriter -> IO ()


printreds :: Show a => [(a,String)] -> PrintWriter -> IO ()


printstates :: [YYgen.YYState] -> PrintWriter -> IO ()


recoveries :: TreeMap.TreeMap String String -> [YYgen.YYState] -> [(Int,String)]


ressource :: Maybe a -> String


scanlines :: [String] -> ([String],[(Int,[String])])


scanytablines :: [String] -> ([String],[String],[(Int,String)],[(String,String)],TreeMap.TreeMap String String)


sortfst :: Ord a => (a,b) -> (a,c) -> Bool


sortgos :: (Ord b,Ord c) => (b,d,c) -> (b,a,c) -> Ordering

-- |  remove carriage returns from strings   
uncr :: String -> String


yygenpar :: Maybe a -> IO [String]



-- |     Provide services for documentation
--       
module frege.tools.doc.Utilities

(:-) :: Utilities.Text -> Utilities.Text -> Utilities.Text


A :: String -> Utilities.Attr

-- |  attribute values for use in 'Text'   
data Attr


Bold :: Utilities.Attr


Code :: Utilities.Attr


DItem :: Utilities.PKind


DL :: Maybe String -> [(Utilities.Text,[Utilities.Paragraph])] -> Utilities.Paragraph


Doc :: [Utilities.Paragraph] -> Utilities.Docu

-- |  Represents an abstract HTML document.   
data Docu

-- |  symbols like &forall; &rarr; ...   
E :: String -> Utilities.Text


instance Eq (Types.ContextT QNames.QName)


instance Eq (Types.RhoT QNames.QName)


instance Eq (Types.SigmaT QNames.QName)


instance Eq (Types.TauT QNames.QName)


instance Eq Utilities.PKind


Header :: Utilities.PKind


Italic :: Utilities.Attr


LI :: [Utilities.Paragraph] -> Utilities.Paragraph

-- |  <a name="#label">text<\/a>   
Label :: QNames.QName -> Utilities.Text -> Utilities.Text


Normal :: Utilities.Attr


OItem :: Utilities.PKind


OUL :: Bool -> Maybe String -> [Utilities.Paragraph] -> Utilities.Paragraph


instance Ord (Types.ContextT QNames.QName)


instance Ord (Types.RhoT QNames.QName)


instance Ord (Types.SigmaT QNames.QName)


instance Ord (Types.TauT QNames.QName)


instance Ord Kinds.Kind

-- |  plain text   
P :: String -> Utilities.Text

-- |  * we have the following parapgraph kinds:
--  * - plain
--  * - headers
--  * - unordered list item
--  * - ordered list item
--  * - definition list item
--  * - preformatted
--       
data PKind

-- |  reference to a package with optional item   
PRef :: Packs.Pack -> Maybe String -> Utilities.Text -> Utilities.Text


Par :: String -> Utilities.Text -> Utilities.Paragraph

-- |  Represents an abstract paragraph.   
data Paragraph


Plain :: Utilities.PKind


Pre :: Utilities.PKind

-- |  <a href="...">N.n<\/a>   
Ref :: QNames.QName -> Utilities.Text -> Utilities.Text

-- |  concatenation of 2 texts   
Seq :: Utilities.Text -> Utilities.Text -> Utilities.Text


instance Show Net.URI

-- |  text with character attributes   
T :: Utilities.Attr -> Utilities.Text -> Utilities.Text

-- |  Represents an abstract text sequence   
data Text


UItem :: Utilities.PKind

-- |  generic label   
XLbl :: String -> Utilities.Text -> Utilities.Text

-- |  generic ref   
XRef :: String -> Utilities.Text -> Utilities.Text


altcode :: [(Utilities.Text,a)] -> [(Utilities.Text,a)]


amper :: Regex

-- |  a unresolved reference   
badref :: String -> Utilities.Text

-- |  transform a text to bold text   
bold :: Utilities.Text -> Utilities.Text


break :: Utilities.Text

-- |  transform a text to text in monospaced font   
code :: Utilities.Text -> Utilities.Text


code1 :: Utilities.Text -> Utilities.Text


code2 :: Utilities.Text -> Utilities.Text


dCtx :: QNameMatcher.QNameMatcher a => Global.Global -> [Types.ContextT a] -> Utilities.Text


dRho :: Global.Global -> Types.RhoT QNames.QName -> [Bool] -> Utilities.Text


dRho2 :: Global.Global -> Types.RhoT QNames.QName -> [Bool] -> Utilities.Text

-- |     document a 'Sigma' type
--      
dSigma :: Global.Global -> Types.SigmaT QNames.QName -> [Bool] -> Utilities.Text


dTau :: QNameMatcher.QNameMatcher a => Global.Global -> Types.TauT a -> Utilities.Text


ditem :: String -> Bool

-- |  convenience function to create a pseudo paragraph   
div :: Utilities.Text -> Utilities.Paragraph


dl :: Maybe String -> [(Utilities.Text,[Utilities.Paragraph])] -> Utilities.Paragraph


docSym :: Global.Global -> Symbols.SymbolT Global.Global -> (Utilities.Text,[Utilities.Paragraph])

-- |  * compile a doc comment to a list of paragraphs
--       
docit :: Global.Global -> Maybe String -> [Utilities.Paragraph]


docop :: TokenID.TokenID -> Utilities.Text

-- |  * create doc paragraphs from tagged paragraphs
--       
docpars :: Global.Global -> [(Utilities.PKind,[String])] -> [Utilities.Paragraph]


drex :: Regex

-- |  * drop empty strings from the front of a list
--       
dropEmpty :: [String] -> [String]


eArrow :: Utilities.Text


eForall :: Utilities.Text


emitCss :: State.StateT Global.Global IO ()


emitHtml :: Bool -> Utilities.Docu -> State.StateT Global.Global IO ()

-- |  transform a text to emphasized text   
emph :: Utilities.Text -> Utilities.Text

-- |  a reference to a function or constructor name   
fref :: QNames.QName -> Global.Global -> Utilities.Text


gt :: Regex

-- |  convenience function to create a heading of level 1   
h1 :: Utilities.Text -> Utilities.Paragraph

-- |  convenience function to create a heading of level 2   
h2 :: Utilities.Text -> Utilities.Paragraph

-- |  convenience function to create a heading of level 3   
h3 :: Utilities.Text -> Utilities.Paragraph

-- |  convenience function to create a heading of level 4   
h4 :: Utilities.Text -> Utilities.Paragraph


header :: String -> Bool

-- |  create a full HTML page with CSS and documentation   
htmlDoc :: Utilities.Docu -> State.StateT Global.Global IO ()

-- |  * emit a HTML structure
--       
htmlParagraph :: Utilities.Paragraph -> State.StateT Global.Global IO ()


htmlText :: Utilities.Text -> State.StateT Global.Global IO ()

-- |  * check if a list contains only empty lines
--       
isEnd :: [String] -> Bool

-- |  check if this is a normal paragraph line   
item :: String -> Bool

-- |   @joined sep xs@ concatenates all strings in /xs/,
--   and inserts /sep/ between any two elements of /xs/.
-- 
--   If /xs/ is empty, the result is an empty string. If /sep/ is an empty string,
--   then the result is just the concatenation of the strings in /xs/.
-- 
--   Example:
--   > joined ", " ["aaa", "bbb", "ccc"] == "aaa, bbb, ccc"
--       
join :: String -> [String] -> String


joins :: Int -> (a->Utilities.Text) -> [a] -> Utilities.Text


joint :: String -> (a->Utilities.Text) -> [a] -> Utilities.Text

-- |  create a label  for a variable or a constructor   
label :: QNames.QName -> Utilities.Text

-- |  check if this is the start of a list item   
litem :: String -> Bool

-- |  * convert a list of lines to a list of paragraphs
--       
lsToPs :: [String] -> [[String]]


lt :: Regex

-- |  * compile a string with markup to 'Text'
--       
markup :: Global.Global -> String -> Utilities.Text


oitem :: String -> Bool

-- |  convenience function to create a numbered list   
ol :: Maybe String -> [Utilities.Paragraph] -> Utilities.Paragraph


orex :: Regex

-- |  Give a list of sigmas and throws clauses of the overloads for this one   
overSig :: Global.Global -> Symbols.SymbolT a -> [(Types.SigmaT QNames.QName,[Types.TauT QNames.QName])]

-- |  Give the function that is overloaded with this one.   
overloadOf :: Global.Global -> Symbols.SymbolT Global.Global -> [Symbols.SymbolT Global.Global]

-- |  * Check whether @file1@ is newer than @file2@
--  *
--  * If both files are modified at the same time, @file1@ is considered newer
--  * thus @File.new "X.class" `newer` File.new "X.java"@ works as expected.
--  *
--  * If @file1@ does not exist, it is *not* newer than any file.
--  **
-- newer :: File -> File -> Bool
-- newer file1 file2
--     | file1.exists = file1.lastModified >= file2.lastModified
--     | otherwise = false
--      
-- 
-- 
--  * given a package name and an extension, create a file name
--  * e.g.
--  * >packToFile "frege.system.IO" ".fr" == frege/system/IO.fr
--       
packToFile :: String -> String -> String


packToFileRef :: Packs.Pack -> Global.Global -> IO String

-- |  convenience function to create an ordinary paragraph   
par :: Utilities.Text -> Utilities.Paragraph

-- |  check for paragraph type   
pres :: String -> Bool

-- |  * Checks the property that, after applying 'unws',
--  * a string is either empty or it contains at least a non space character
--       
prop_unws :: QuickCheckGen.Gen QuickCheckProperty.Prop

-- |  * given a directory name and a file or directory name,
--  * compute the name of the directory relative to that filename, e.g.
--  * > relPath "foo"   "foo"         == "."
--  * > relPath "foo"   "foo/x.html"  == "."
--  * > relPath "foo"   "bar/z.html"  == "../foo"
--       
relPath :: Maybe (MutableIO File) -> Maybe (MutableIO File) -> IO String


resolves :: Global.Global -> String -> Utilities.Text

-- |  makes a single text from a list of texts   
seq :: [Utilities.Text] -> Utilities.Text


spaces :: Int -> Utilities.Text


spc :: Utilities.Text

-- |  a reference to a symbol   
sref :: Symbols.SymbolT a -> Global.Global -> Utilities.Text


symArrow :: Global.Global -> String


symDarrow :: Global.Global -> String

-- |  a double colon in spaces, could be ∷ symbol if options allow   
symDcolon :: Global.Global -> String


symForall :: Global.Global -> String

-- |  tag paragraph with kind, each paragraph must have at least one line   
tagP :: [String] -> (Utilities.PKind,[String])

-- |  plain text   
text :: String -> Utilities.Text

-- |  a reference to a type name   
tref :: QNames.QName -> Global.Global -> Utilities.Text


uitem :: String -> Bool

-- |  convenience function to create an itemized list   
ul :: Maybe String -> [Utilities.Paragraph] -> Utilities.Paragraph


ungt :: StringJ a -> StringJ a

-- |  remove 'Label' from 'Text'   
unlabel :: Utilities.Text -> Utilities.Text

-- |  * break up a long string into individual lines
--       
unnl :: String -> [String]

-- |  * remove leading \"  *  \" or just leading spaces from a string
--       
unws :: String -> String

